CON ' Header
''
''   ###    ### #########   ######       #####    ### ####   ### ###          ### #########
''    ###    #   ##     #  ##    ##        ##     #    ##     #   ###        ###   ##     #
''    # ##   #   ##  #    ##      ##    #   ##   #     ##     #   # ##      # ##   ##  #
''    #  ##  #   #####   ###      ###  ###   ## #      ##     #   #  ##    #  ##   #####
''    #   ## #   ##  #    ##      ##    #     ##       ##     #   #   ##  #   ##   ##  #
''    #    ###   ##      # ##    ##           ##        ##   #    #    ###    ##   ##      #
''   ###    ### #########   ######           ####        ####    ###    #    #### #########
''
''                                    MAX 256 MEGA
''                                   PROP-GEAR SPEC
''
CON ' Common Constants

MASTER_CLK = 24_100_000
CLK_MULTIPLIER = 14

'DEBUG_BAUD = 1_000_000
DEBUG_LOG_SIZE = 16*1024*1024

_CLKFREQ = MASTER_CLK * CLK_MULTIPLIER ' Ignore this unless you're debugging - final clock is set by video driver

UPPER_LOAD = $5_C000
INPUT_LOAD = $3_9000

VINT_LOCK = 9
STATIC_LOCKS = decod VINT_LOCK

CON

#include "config.spin2"

DAT ' startup code & zero page
              org
              coginit #0,##UPPER_LOAD
              orgh $14
_clkf         long 0
_clkm         long 0

_mk_init_ptr    long @mk_init ' < $1C
_drawbuffer_ptr long @draw_buffer ' < $20
_palette_ptr    long @palette32   ' < $24
_vramlo_ptr     long @vram_low    ' < $28
_vramhi_ptr     long @vram_high   ' < $2C
_zk_init_ptr    long @zk_init ' < $30
_lspc_load_ptr  long @lspc_entry ' < $34
_blt_load_ptr   long @blt_entry ' < $38
_opnb_init_ptr  long @opn_init ' < $3C
_ma_init_ptr    long @ma_entry ' < $40
_input_load_ptr long INPUT_LOAD ' < $44

curpalette_base_l long @palette32
z80_command_b byte 0
z80_reply_b   byte 0
opn_timerAflag byte 0
opn_timerBflag byte 0
opn_register  word 0
_lspc_modereg word 0
_lspc_animctr byte 0

              orgh $60
              ' control bit format is %ET_DCBA_RLDU (E=sElect,T=sTart)
io_pl1_padw   word 0 ' < $60 (populated by USB code)
io_pl2_padw   word 0 ' < $62 (populated by USB code)

              orgh $80
              ' Stuff set by upcode
_exr_prog_base  long 0 ' < $80: Lower 68k ROM
_exr_port_base  long 0 ' < $84: Upper 68k ROM
_exr_port_bkmsk long 0 ' < $88: Upper ROM bankswitch mask
_exr_bios_base  long 0 ' < $8C: BIOS ROM
_exr_adpa_base  long 0 ' < $90: ADPCM A ROM
_exr_adpb_base  long 0 ' < $94: ADPCM B ROM
_exr_char_base  long 0 ' < $98: Sprite base
_exr_fixt_base  long 0 ' < $9C: Fix tile base
_exr_z80p_base  long 0 ' < $A0: Z80 ROM
_ext_char_bits  long 31 ' < $A4: Tile ID zerox mask


              ' ADPCM poll interface
adpcm_pollbox   long 0[7]

              ' mailbox for 68k ROM reads
_progrq_addr  long 0
_progrq_length long 0
_progrq_target long 0
_mk_cogatn_w  word 0
_ma_cogatn_w  word 0
_zk_cogatn_w  word 0

              orgh $F8
video_line_ctr          long 0
video_frame_ctr         long 0


CON ' MotoKore 68000 constants

#0,MK_CARRY_BIT,MK_OVER_BIT,MK_ZERO_BIT,MK_NEG_BIT,MK_EXT_BIT

MK_SUPER_BIT = 13
MK_TRACE_BIT = 15

MK_CARRY_MASK = 1<<MK_CARRY_BIT
MK_OVER_MASK  = 1<<MK_OVER_BIT
MK_ZERO_MASK  = 1<<MK_ZERO_BIT
MK_NEG_MASK   = 1<<MK_NEG_BIT
MK_EXT_MASK   = 1<<MK_EXT_BIT

MK_SUPER_MASK = 1<<MK_SUPER_BIT
MK_TRACE_MASK = 1<<MK_TRACE_BIT


MK_ROMQUE_SIZE = 16 ' words


DAT ' MotoKore 68000 cog resident code
              org
mk_cogbase
mk_d0         long 0
mk_d1         long 0
mk_d2         long 0
mk_d3         long 0
mk_d4         long 0
mk_d5         long 0
mk_d6         long 0
mk_d7         long 0
mk_a0         long 0
mk_a1         long 0
mk_a2         long 0
mk_a3         long 0
mk_a4         long 0
mk_a5         long 0
mk_a6         long 0
mk_a7         long 0

mk_othersp    long 0
mk_sr         long 0

mk_nibble_impl_tbl
              long mk_nibble_0 ' 0 (immediate ops)
              long mk_nibble_1 ' 1 (MOVE BYTE)
              long mk_nibble_2 ' 2 (MOVE LONG)
              long mk_nibble_3 ' 3 (MOVE WORD)
              long mk_nibble_4 ' 4 (weird stuff idk)
              long mk_nibble_5 ' 5 (ADDQ/SUBQ and also Scc/DBcc)
              long mk_nibble_6 ' 6 (branches)
              long mk_nibble_7 ' 7 (MOVEQ)
              long mk_nibble_8 ' 8 (OR and stuffs)
              long mk_nibble_9 ' 9 (subtracts)
              long mk_nibble_A ' A (LINE A EMULATOR TRAP)
              long mk_nibble_B ' B (CMP and EOR)
              long mk_nibble_C ' C (AND or stuffs)
              long mk_nibble_D ' D (adds)
              long mk_nibble_E ' E (Bit shifts)
              long mk_nibble_F ' F (LINE F EMULATOR TRAP)


mk_condition_truth_table
              '' Remember, status register is %XNZVC
              long $10001 * %1111_1111_1111_1111 '' %0000 : True
              'long $10001 * %0000_0000_0000_0000 '' %0001 : False
              long $10001 * %0000_0101_0000_0101 '' %0010 : High
              'long $10001 * %1111_1010_1111_1010 '' %0011 : Low or same
              long $10001 * %0101_0101_0101_0101 '' %0100 : carry clear
              'long $10001 * %1010_1010_1010_1010 '' %0101 : carry set
              long $10001 * %0000_1111_0000_1111 '' %0110 : not equal
              'long $10001 * %1111_0000_1111_0000 '' %0111 : equal
              long $10001 * %0011_0011_0011_0011 '' %1000 : overflow clear
              'long $10001 * %1100_1100_1100_1100 '' %1001 : overflow set
              long $10001 * %0000_0000_1111_1111 '' %1010 : plus
              'long $10001 * %1111_1111_0000_0000 '' %1011 : minus
              long $10001 * %1100_1100_0011_0011 '' %1100 : greater or equal (N==V)
              'long $10001 * %0011_0011_1100_1100 '' %1101 : less than (N!=V)
              long $10001 * %0000_1100_0000_0011 '' %1110 : greater than (N==V)&!Z (???)
              'long $10001 * %1111_0011_1111_1100 '' %1111 : less or equal (N!=V)|Z (???)

mk_shift_impl_tbl
              long mk_do_asr
              long mk_do_asl
              long mk_do_lsr
              long mk_do_lsl
              long mk_do_roxr
              long mk_do_roxl
              long mk_do_ror
              long mk_do_rol

mk_flowop_impl_tbl
              long mk_hub_reset
              long mk_hub_nop
              long mk_hub_stop
              long mk_hub_rte
              long mk_illegal
              long mk_hub_rts
              long mk_hub_trapv
              long mk_hub_rtr

mk_setup_ea8_tab
              long mk_setup_rom_common + %0_00000_10_1100_110_111000<<10        ' $0x_xxxx (PROG ROM)
              long mk_setup_ram_common + %0_11_11_00_00<<10                     ' $1x_xxxx (WORK RAM)
              long mk_setup_rom_common + %0_00000_01_1111_110_110100<<10        ' $2x_xxxx (PORT ROM)
              long mk_setup_io8                                                 ' $3x_xxxx (I/O)
              long mk_setup_palette8 + %0_1111_1111_0000<<10                    ' $4x_xxxx (PALETTE)
              long mk_setup_palette8 + %0_1111_1111_0000<<10                    ' $5x_xxxx (PALETTE)
              long mk_setup_palette8 + %0_1111_1111_0000<<10                    ' $6x_xxxx (PALETTE)
              long mk_setup_palette8 + %0_1111_1111_0000<<10                    ' $7x_xxxx (PALETTE)
              long mk_setup_memcard8                                            ' $8x_xxxx (MEMCARD (not present))
              long mk_setup_memcard8                                            ' $9x_xxxx (MEMCARD (not present))
              long mk_setup_memcard8                                            ' $Ax_xxxx (MEMCARD (not present))
              long mk_setup_memcard8                                            ' $Bx_xxxx (MEMCARD (not present))
              long mk_setup_rom_common + %0_00000_10_1111_110_001110<<10        ' $Cx_xxxx (BIOS ROM)
              long mk_setup_nvram8                                              ' $Dx_xxxx (NVRAM (not present))
              long mk_setup_nothing8                                            ' $Ex_xxxx (unmapped)
              long mk_setup_nothing8                                            ' $Fx_xxxx (unmapped)
mk_setup_ea16_tab
              long mk_setup_rom_common + %0_00000_10_1010_101_111000<<10        ' $0x_xxxx (PROG ROM)
              long mk_setup_ram_common + %0_11_00_11_00<<10                     ' $1x_xxxx (WORK RAM)
              long mk_setup_rom_common + %0_00000_01_1111_101_110100<<10        ' $2x_xxxx (PORT ROM)
              long mk_setup_io16                                                ' $3x_xxxx (I/O)
              long mk_setup_palette16 + %0_1111_0000<<10                        ' $4x_xxxx (PALETTE)
              long mk_setup_palette16 + %0_1111_0000<<10                        ' $5x_xxxx (PALETTE)
              long mk_setup_palette16 + %0_1111_0000<<10                        ' $6x_xxxx (PALETTE)
              long mk_setup_palette16 + %0_1111_0000<<10                        ' $7x_xxxx (PALETTE)
              long mk_setup_memcard16                                           ' $8x_xxxx (MEMCARD (not present))
              long mk_setup_memcard16                                           ' $9x_xxxx (MEMCARD (not present))
              long mk_setup_memcard16                                           ' $Ax_xxxx (MEMCARD (not present))
              long mk_setup_memcard16                                           ' $Bx_xxxx (MEMCARD (not present))
              long mk_setup_rom_common + %0_00000_10_1111_101_001110<<10        ' $Cx_xxxx (BIOS ROM)
              long mk_setup_nvram16                                             ' $Dx_xxxx (NVRAM (not present))
              long mk_setup_nothing16                                           ' $Ex_xxxx (unmapped)
              long mk_setup_nothing16                                           ' $Fx_xxxx (unmapped)
mk_setup_ea32_tab
              long mk_setup_rom_common + %0_00000_10_0110_011_111000<<10        ' $0x_xxxx (PROG ROM)
              long mk_setup_ram_common  + %0_00_11_11_00<<10                    ' $1x_xxxx (WORK RAM)
              long mk_setup_rom_common + %0_00000_01_1111_011_110100<<10        ' $2x_xxxx (PORT ROM)
              long mk_setup_io32                                                ' $3x_xxxx (I/O)
              long mk_setup_palette32 + %0_0000<<10                             ' $4x_xxxx (PALETTE)
              long mk_setup_palette32 + %0_0000<<10                             ' $5x_xxxx (PALETTE)
              long mk_setup_palette32 + %0_0000<<10                             ' $6x_xxxx (PALETTE)
              long mk_setup_palette32 + %0_0000<<10                             ' $7x_xxxx (PALETTE)
              long mk_setup_memcard32                                           ' $8x_xxxx (MEMCARD (not present))
              long mk_setup_memcard32                                           ' $9x_xxxx (MEMCARD (not present))
              long mk_setup_memcard32                                           ' $Ax_xxxx (MEMCARD (not present))
              long mk_setup_memcard32                                           ' $Bx_xxxx (MEMCARD (not present))
              long mk_setup_rom_common + %0_00000_10_1111_011_001110<<10        ' $Cx_xxxx (BIOS ROM)
              long mk_setup_nvram32                                             ' $Dx_xxxx (NVRAM (not present))
              long mk_setup_nothing32                                           ' $Ex_xxxx (unmapped)
              long mk_setup_nothing32                                           ' $Fx_xxxx (unmapped)


mk_rd_nothing
        _ret_ mov mk_memvalue,#0

mk_rd8_reg
        _ret_ getbyte mk_memvalue,0-0,#0
mk_wr8_reg
        _ret_ setbyte 0-0,mk_memvalue,#0
mk_rd16_reg
        _ret_ getword mk_memvalue,0-0,#0
mk_wr16_reg
        _ret_ setword 0-0,mk_memvalue,#0
mk_rd32_reg
        _ret_ mov mk_memvalue,0-0
mk_wr32_reg
        _ret_ mov 0-0,mk_memvalue

mk_rd8_rom
              setq #2
              wrlong mk_romio_addr,#_progrq_addr
              cogatn mk_romio_atnval
              waitatn
mk_rd8_ram
        _ret_ rdbyte mk_memvalue,mk_eacache
mk_wr8_ram
              'call #mk_debug_wrchk8
        _ret_ wrbyte mk_memvalue,mk_eacache

mk_rd16_rom
              setq #2
              wrlong mk_romio_addr,#_progrq_addr
              cogatn mk_romio_atnval
              waitatn
mk_rd16_ram
              rdword mk_memvalue,mk_eacache
        _ret_ movbyts mk_memvalue,#%%3201
mk_wr16_ram
              'call #mk_debug_wrchk16
              movbyts mk_memvalue,#%%3201
        _ret_ wrword mk_memvalue,mk_eacache

mk_rd32_rom
              setq #2
              wrlong mk_romio_addr,#_progrq_addr
              cogatn mk_romio_atnval
              waitatn
mk_rd32_ram
              rdlong mk_memvalue,mk_eacache
        _ret_ movbyts mk_memvalue,#%%0123
mk_wr32_ram
              'call #mk_debug_wrchk32
              movbyts mk_memvalue,#%%0123
        _ret_ wrlong mk_memvalue,mk_eacache

mk_wrrom      ret ' obviously nothing

mk_rdimm
        _ret_ mov mk_memvalue,mk_eacache

mk_wrportbank
              mov mk_memtmp3,mk_effaddr
              zerox mk_memtmp3,#19
              cmp mk_memtmp3,##$FFFF0 wc
              'debug("Bankswitch write: ",uhex_long(mk_memvalue,mk_effaddr,mk_virtualpc))
              setq #1
              rdlong mk_memtmp0,#_exr_port_base
              shl mk_memvalue,#20 ' 1 MB steps
              and mk_memtmp1,mk_memvalue
              add mk_memtmp0,mk_memtmp1
        if_ae mov mk_port_base,mk_memtmp0
              ret wcz


mk_longio_tmp long 0

mk_rd32_io
              call #mk_rd16_io
              getword mk_longio_tmp,mk_memvalue,#0
              add mk_eacache,#2
              call #mk_rd16_io
        _ret_ setword mk_memvalue,mk_longio_tmp,#1
mk_wr32_io
              mov mk_longio_tmp,mk_memvalue
              shr mk_memvalue,#16
              call #mk_wr16_io
              add mk_eacache,#2
              getword mk_memvalue,mk_longio_tmp,#0
              ' fall through
mk_wr16_io
              getnib pa,mk_effaddr,#4
              shr pa,#1
              jmprel pa
              jmp #.todo                        ' C0_xxxx (watchdog)
              jmp #iog_z80port_wr16             ' C2_xxxx (Z80 command)
              jmp #.undecoded                   ' C4_xxxx (nothing?)
              jmp #.undecoded                   ' C6_xxxx (nothing?)
              jmp #.undecoded                   ' C8_xxxx (nothing?)
              jmp #iog_latch_wr16               ' CA_xxxx (latches)
              jmp #iog_lspc_wr16                ' CC_xxxx (LSPC)
              'jmp #.undecoded                  ' CE_xxxx (nothing?)

.undecoded
              debug("undecoded IO WORD WRITE: ",uhex_(mk_effaddr),uhex_long(mk_virtualpc))
.todo
              ret wcz ' undecoded IO?

mk_wr8_io
              'debug("mk_wr8_io ",uhex(mk_effaddr))
              getnib pa,mk_effaddr,#4
              shr pa,#1
              jmprel pa
              jmp #.todo                        ' C0_xxxx (watchdog)
              jmp #iog_z80port_wr8              ' C2_xxxx (Z80 command)
              jmp #.undecoded                   ' C4_xxxx (nothing?)
              jmp #.undecoded                   ' C6_xxxx (nothing?)
              jmp #.undecoded                   ' C8_xxxx (nothing?)
              jmp #iog_latch_wr8                ' CA_xxxx (latches)
              jmp #iog_lspc_wr8                 ' CC_xxxx (LSPC)
              'jmp #.undecoded                  ' CE_xxxx (nothing?)
.undecoded
.todo
              ret wcz

mk_rd16_io
              getnib pa,mk_effaddr,#4
              shr pa,#1
              jmprel pa
              jmp #iog_p1stuff_rd16             ' C0_xxxx (P1 controls,etc)
              jmp #iog_status_a_rd16            ' C2_xxxx (Status A / Z80 reply)
              jmp #iog_p2stuff_rd16             ' C4_xxxx (P2 controls,etc)
              jmp #.undecoded                   ' C6_xxxx (nothing?)
              jmp #iog_status_b_rd16            ' C8_xxxx (Status B)
              jmp #.undecoded                   ' CA_xxxx (latches)
              jmp #iog_lspc_rd16                ' CC_xxxx (LSPC)
              'jmp #.undecoded                  ' CE_xxxx (nothing?)

.undecoded
              'debug("undecoded IO WORD READ: ",uhex(mk_effaddr))
              mov mk_memvalue,#0 ' TODO
              ret wcz ' undecoded IO?


mk_rd8_io
              bitl mk_eacache,#0 wcz
              call #mk_rd16_io
              bitc mk_eacache,#0
        if_nc getbyte mk_memvalue,mk_memvalue,#1
        if_c  getbyte mk_memvalue,mk_memvalue,#0
              ret wcz


mk_rd8_vector
              getbyte pa,mk_effaddr,#0
              xor pa,#3
              add pa,mk_vectors_ptr
        _ret_ rdbyte mk_memvalue,pa
mk_rd16_vector
              getbyte pa,mk_effaddr,#0
              xor pa,#2
              add pa,mk_vectors_ptr
        _ret_ rdword mk_memvalue,pa
mk_rd32_vector
              getbyte pa,mk_effaddr,#0
              bitl pa,#1 wcz
              add pa,mk_vectors_ptr
              rdlong mk_memvalue,pa
              add pa,#4
        if_c  rdlong pa,pa
        if_c  rolword mk_memvalue,pa,#1
              ret wcz

mk_wr_sr
              xor mk_memvalue,mk_sr
              testn mk_memvalue,#255 wz
              xor mk_memvalue,mk_sr
              testb mk_sr,#MK_SUPER_BIT wc
  if_nz_or_nc jmp #mk_hub_wr_sr

mk_wr_ccr
              setq #%11111
              muxq mk_sr,mk_memvalue
              ret wcz
mk_rd_sr
        _ret_ mov mk_memvalue,mk_sr


mk_illegal
              debug("ILLEGAL INSTRUCTION ",uhex_word(mk_opword),uhex_long(mk_virtualpc))
              'drvh #38
              mov pb,#$10
              jmp #mk_hub_trapit


mk_nextop
              'debug("registers: ",ubin_word(mk_sr),13,uhex_reg_array(#mk_d0,#8),13,uhex_reg_array(#mk_a0,#8))
              'debug("last 16 RAM bytes: ",uhex_byte_array(#main_ram + $FFF0,#16))
              'tjnz mk_debug_ctr,#mk_nextop_nohook
              'jatn mk_cogatnptr
mk_ihook1     nop
mk_ihook2     nop
mk_nextop_nohook
              'cmp mk_virtualpc,mk_debug_tripwire wz
        'if_z drvh #38
       'if_z  mov mk_debug_tripwire,#0
       'if_z   mov mk_debug_ctr,#1
              'incmod mk_debug_ctr,##7919-1 wc
              'debug("getting op with ",uhex_long(mk_virtualpc))
              'debug(uhex_long_(mk_virtualpc))
              'debug(uhex_word_array(#@fake_rom+$200,#4))
              call mk_getopf
              'debug("got op: ",uhex_word(mk_opword))
              'debug("got op: ",uhex_word_(mk_opword)," before ",uhex_long_(mk_virtualpc))
              'tjnz mk_debug_tripwire,#.no_trace
              'tjz mk_debug_ctr,#.no_trace
              'sub mk_debug_ctr,#1
              'cmp mk_debug_tripwire,mk_virtualpc wz
        'if_nz jmp #.no_trace
      'if_nc jmp #.no_trace
              'debug("tripwired' ",uhex_long(mk_virtualpc))
              'call #mk_check_core_integrity
              'debug("got: ",uhex_word_(mk_opword)," before ",uhex_long_(mk_virtualpc))
              'debug("registers: ",ubin_word(mk_sr),10,13,uhex_reg_array(#mk_d0,#8),10,13,uhex_reg_array(#mk_a0,#8))

              'debug("got op: ",uhex_word(mk_opword)," before ",uhex_long(mk_virtualpc),uhex_long(mk_a3))
              'waitx ##174_00
.no_trace
              push #mk_nextop
              getnib mk_memtmp0,mk_opword,#3
              altd mk_memtmp0,#mk_nibble_impl_tbl
              jmp 0-0

mk_irq1ptr    long @mk_hub_irq1
mk_irq2ptr    long @mk_hub_irq2
'mk_cogatnptr long @mk_hub_cogatn


mk_write_second_reg_or_ea '' for ops that have two directional modes
              testb mk_opword,#8 wc
        if_c  jmp mk_writef
mk_write_second_reg
              neg pb,#1
              shr pb,mk_shiftit
              setq pb
              and mk_opword,mk_dreg_mask ' assume we don't need it anymore
              alti mk_opword,#%000_100_000
        _ret_ muxq 0-0,mk_memvalue


mk_nibble_0   ' Immediate ops (decode headache!)
              testb mk_opword,#8 wc
              test mk_opword,#%110_000 wz
              testb mk_opword,#3 andz
        if_c_and_z jmp #mk_hub_movep
        if_c  jmp #.register_bitop ' not actually an immediate op...
              getnib mk_optmp2,mk_opword,#2
              cmp mk_optmp2,#%1000 wz
        if_z  jmp #.imm_bitop
              ' ok, we know it's a sized ***I type op
              mov pb,mk_opword
              call #mk_getopimm_auto
              'debug("xxxI type op... imm is ",uhex_long(mk_optmp1))
              mov pb,mk_opword
              and pb,#%111_111
              cmp pb,#%111_100 wz ' <- if Z, is op to SR/CCR
        if_z  mov mk_readf,#mk_rd_sr
        if_z  mov mk_shiftit,#16
        if_z  testb mk_opword,#6 wc
        if_z_and_c  mov mk_writef,#mk_wr_sr
        if_z_and_nc mov mk_writef,#mk_wr_ccr
        if_nz callpb mk_opword,#mk_setup_operand_auto

              call mk_readf
              cmp mk_optmp2,#%1100 wz
        if_z  jmp #mk_cmp_swapped ' CMPI (doesn't write)
              push mk_writef ' setup write return
              cmp mk_optmp2,#%0110 wz
        if_z  jmp #mk_add_common ' ADDI
              cmp mk_optmp2,#%0100 wz
        if_z  jmp #mk_sub_common ' SUBI
              ' ok, only logic ops left
              setr mk_thelogicop,#%0101000_01 ' P2 AND WZ opcode (assume this if no other logic op)
              cmp mk_optmp2,#%0000 wz
        if_z  setr mk_thelogicop,#%0101010_01 ' P2 OR WZ opcode
              cmp mk_optmp2,#%1010 wz
        if_z  setr mk_thelogicop,#%0101011_01 ' P2 XOR WZ opcode
              jmp #mk_multilogic_common

.imm_bitop
              push #.bitop_common
              jmp #mk_getopimm8
.register_bitop
              mov pb,mk_opword
              shr pb,#9
              and pb,#7
              alts pb,#mk_d0
              mov mk_optmp1,0-0
.bitop_common
              test mk_opword,#%110_000 wz ' Register op?
              mov pb,mk_opword
        if_z  call #mk_setup_reg32
        if_nz and mk_optmp1,#7
        if_nz call #mk_setup_operand8
              call mk_readf
              'debug("doing bitop with ",uhex_byte(mk_optmp1),uhex_long(mk_memvalue))
              testbn mk_memvalue,mk_optmp1 wc
              bitc mk_sr,#MK_ZERO_BIT
              testb mk_opword,#6 wz
              testb mk_opword,#7 wc
        if_00 ret ' BTST
              and mk_optmp1,#31 ' bitfield-sensitive ops ahead
        if_01 bitnot mk_memvalue,mk_optmp1 ' BCHG
        if_1x bitz mk_memvalue,mk_optmp1 ' BCLR/BSET
              'debug("bitop result ",uhex_long(mk_memvalue))
              jmp mk_writef



mk_cmp
              callpb mk_opword,#mk_setup_operand_auto
              call mk_readf
              push #mk_cmp_common
              jmp #mk_get_second_reg

mk_cmp_swapped
              xor mk_memvalue,mk_optmp1
              xor mk_optmp1,mk_memvalue
              xor mk_memvalue,mk_optmp1
mk_cmp_common
              'debug("in mk_cmp_common ",uhex_long(mk_d0),uhex_long(mk_memvalue),uhex_long(mk_optmp1),udec(mk_shiftit))
              shl mk_memvalue,mk_shiftit
              shl mk_optmp1,mk_shiftit
              ' NOTE: the operands are swapped compared to sub_common
              ' generate stupid overflow flag
              mov mk_optmp0,mk_optmp1
              subs mk_optmp0,mk_memvalue wc
              testb mk_optmp0,#31 xorc
              bitc mk_sr,#MK_OVER_BIT
              ' do actual sub
              sub mk_optmp1,mk_memvalue wcz
              bitc mk_sr,#MK_CARRY_BIT
              bitz mk_sr,#MK_ZERO_BIT
              testb mk_optmp0,#31 wc
        _ret_ bitc mk_sr,#MK_NEG_BIT


mk_cmpa
              testb mk_opword,#8 wc ' long sized?
        if_nc callpb mk_opword,#mk_setup_operand16
        if_c  callpb mk_opword,#mk_setup_operand32
              call mk_readf
        if_nc signx mk_memvalue,#15
              mov pb,mk_opword
              shr pb,#9
              and pb,#7
              alts pb,#mk_a0
              mov mk_optmp1,0-0
              mov mk_shiftit,#0
              jmp #mk_cmp_common




mk_nibble_9
mk_nibble_D
              ' ADD/SUB (X/A)
              ' check for ADDA/SUBA
              test mk_opword,#%11_000_000 wcz
        if_00 jmp #mk_addsuba
              ' check for ADDX/SUBX
              test mk_opword,#%110_000 wz
              testb mk_opword,#8 andz
        if_z  jmp #mk_hub_addsubx

              ' Okay, normal ADD/SUB
              callpb mk_opword,#mk_setup_operand_auto
              call mk_readf
              call #mk_get_second_reg
              push #mk_write_second_reg_or_ea
              testb mk_opword,#14 wc ' C = ADD,NC = SUB ?
        if_nc jmp #mk_sub_withdir
              ' fall through
mk_add_common
              shl mk_memvalue,mk_shiftit
              shl mk_optmp1,mk_shiftit
              ' generate stupid overflow flag
              mov mk_optmp0,mk_optmp1
              adds mk_optmp0,mk_memvalue wc
              testb mk_optmp0,#31 xorc
              bitc mk_sr,#MK_OVER_BIT
              ' do actual add
              add mk_memvalue,mk_optmp1 wcz
              muxc mk_sr,#MK_CARRY_MASK|MK_EXT_MASK
              bitz mk_sr,#MK_ZERO_BIT
              testb mk_optmp0,#31 wc
              bitc mk_sr,#MK_NEG_BIT

        _ret_  shr mk_memvalue,mk_shiftit

mk_sub_withdir
              ' if dir bit clear, swap operands
              testb mk_opword,#8 wc
        if_nc xor mk_memvalue,mk_optmp1
        if_nc xor mk_optmp1,mk_memvalue
        if_nc xor mk_memvalue,mk_optmp1
mk_sub_common
              'debug("in mk_sub_common ",uhex_long(mk_d0),uhex_long(mk_memvalue),uhex_long(mk_optmp1),udec(mk_shiftit))
              shl mk_memvalue,mk_shiftit
              shl mk_optmp1,mk_shiftit

              ' generate stupid overflow flag
              mov mk_optmp0,mk_memvalue
              subs mk_optmp0,mk_optmp1 wc
              testb mk_optmp0,#31 xorc
              bitc mk_sr,#MK_OVER_BIT
              ' do actual sub
              sub mk_memvalue,mk_optmp1 wcz
              muxc mk_sr,#MK_CARRY_MASK|MK_EXT_MASK
              bitz mk_sr,#MK_ZERO_BIT
              testb mk_optmp0,#31 wc
              bitc mk_sr,#MK_NEG_BIT

        _ret_  shr mk_memvalue,mk_shiftit

mk_addsuba
              setq mk_dreg_mask
              muxq .adda_op,mk_opword
              testb mk_opword,#8 wc ' long sized?
        if_nc callpb mk_opword,#mk_setup_operand16
        if_c  callpb mk_opword,#mk_setup_operand32
              call mk_readf
              'debug("in mk_adda: ",uhex_long(mk_memvalue))
        if_nc signx mk_memvalue,#15
              testb mk_opword,#14 wc ' C = ADDA,NC = SUBA ?
.adda_op _ret_ sumnc mk_a0,mk_memvalue


' Memory R/W primitives
mk_setup_operand_auto ' with ea-supplying op in pb
                 ' make sure size field is not %11 (will be treated as 16bit)
              testb pb,#6 wc
        if_c  jmp #mk_setup_operand16
              testb pb,#7 wc
        if_c  jmp #mk_setup_operand32
              ' Fall through!
mk_setup_operand8
              'debug("in mk_setup_operand8 ",ubin(pb))
              mov mk_shiftit,#24
mk_setup_operand8_move
              test pb,#%110_000 wz
        if_z  jmp #mk_setup_reg8
              and pb,#%00_111_111
              cmp pb,#%00_111_100 wc
        if_ae jmp #mk_setup_imm8
              call #mk_compute_ea
mk_setup_ea8
              'debug("in mk_setup_ea8 ",uhex_long(mk_effaddr))
              getnib pb,mk_effaddr,#5
              altd pb,#mk_setup_ea8_tab
              execf 0-0



mk_setup_operand16
              'debug("in mk_setup_operand16 ",ubin(pb))
              mov mk_shiftit,#16
mk_setup_operand16_move
              test pb,#%110_000 wz
        if_z  jmp #mk_setup_reg16
              and pb,#%00_111_111
              cmp pb,#%00_111_100 wc
        if_ae jmp #mk_setup_imm16
              or  pb,#%01_000_000
              call #mk_compute_ea
mk_setup_ea16
              testb mk_effaddr,#0 wc
        if_c  jmp #mk_address_error
              getnib pb,mk_effaddr,#5
              altd pb,#mk_setup_ea16_tab
              execf 0-0


mk_setup_operand32
              mov mk_shiftit,#0
mk_setup_operand32_move
              test pb,#%110_000 wz
        if_z  jmp #mk_setup_reg32
              and pb,#%00_111_111
              cmp pb,#%00_111_100 wc
        if_ae jmp #mk_setup_imm32
              or  pb,#%10_000_000
              call #mk_compute_ea
mk_setup_ea32
              testb mk_effaddr,#0 wc
        if_c  jmp #mk_address_error
              getnib pb,mk_effaddr,#5
              altd pb,#mk_setup_ea32_tab
              execf 0-0


mk_ea_impl_tbl
              long mk_ea_direct
              long mk_ea_postinc
              long mk_ea_predec
              long mk_ea_displace
              long mk_ea_index
              long mk_ea_headache


mk_multilogic
              call #mk_get_second_reg
              callpb mk_opword,#mk_setup_operand_auto
              call mk_readf
              push #mk_write_second_reg_or_ea
mk_multilogic_common
              shl mk_memvalue,mk_shiftit
              shl mk_optmp1,mk_shiftit

mk_thelogicop and mk_memvalue,mk_optmp1 wz

              bitz mk_sr,#MK_ZERO_BIT
              testb mk_memvalue,#31 wz
              bitz mk_sr,#MK_NEG_BIT
              andn mk_sr,#MK_CARRY_MASK|MK_OVER_MASK
        _ret_ shr mk_memvalue,mk_shiftit


mk_getop_ram
              mov mk_memtmp0,mk_virtualpc
              add mk_virtualpc,#2
              setword mk_memtmp0,#1,#1 ' main_ram!
              rdword mk_opword,mk_memtmp0
        _ret_ movbyts mk_opword,#%%3201

mk_getop_rom
              'debug("in getop_rom with ",udec(mk_romque_left))
              djf mk_romque_left,#mk_romque_refill
              add mk_virtualpc,#2
              rdword mk_opword,ptra++
              movbyts mk_opword,#%%3201
              ret wcz
mk_romque_left    long 0



mk_romio_area_ptr long @mk_romio_area
mk_romio_area_ptr_shr2 long @mk_romio_area >> 2
mk_romque_area_ptr long @mk_romque_area
mk_dreg_mask      long %111_000_000_000

mk_vectors_mask long $FF_FF80
mk_bit31      long 1<<31


mk_cogvar_start

mk_debug_tripwire long $03c9da+2
mk_debug_ctr  long 0

mk_vram_curr  long 0
mk_vram_modulo long 0

mk_vectors_ptr res 1

mk_prog_base    res 1
mk_port_base    res 1
mk_bios_base    res 1

mk_virtualpc  res 1 ' PC in virtual space
mk_effaddr    res 1 ' calculated effective address
mk_shiftit    res 1 ' operand MSB shift
mk_branchdisplace res 1 ' branch target
mk_opword     res 1 ' opcode

mk_readf      res 1 ' operand read pointer
mk_writef     res 1 ' operand write pointer
mk_getopf     res 1 ' opword get pointer

mk_optmp0     res 1
mk_optmp1     res 1
mk_optmp2     res 1

mk_eatmp0     res 1
mk_eatmp1     res 1

mk_romio_addr   res 1
mk_romio_length res 1
mk_romio_target res 1

mk_romqueio_addr res 1
mk_romqueio_length res 1
mk_romqueio_target res 1

mk_romque_base res 1
mk_romque_zerox res 1

mk_romio_atnval res 1


              fit $1F0
              org $1F0

mk_memtmp0    res 1
mk_memtmp1    res 1
mk_memtmp2    res 1
mk_memtmp3    res 1
mk_memvalue   res 1 ' memory read/write value
mk_eacache    res 1 ' remapped EA
              fit $1F6
DAT ' MotoKore 68000 LUT resident code
mk_lutbase
              org 512


mk_move_shoot_the_shit ' handle all the common MOVE stuff
               ' Doing MOVEA?
              test mk_opword,#%110_000_000 wz
              testb mk_opword,#6 andz
        if_z  jmp #.movea
              signx mk_memvalue,pa wcz
              bitc mk_sr,#MK_NEG_BIT
              bitz mk_sr,#MK_ZERO_BIT
              andn mk_sr,#MK_OVER_MASK|MK_CARRY_MASK
.mangle_ea2   ' format for second operand is stupid
              setnib mk_opword,#0,#3
              mov pa,mk_opword
              and pa,#%111_000_000
              shl pa,#6
              or mk_opword,pa
        _ret_ shr mk_opword,#9
.movea
              shr mk_opword,#9
              and mk_opword,#7
              altr mk_opword,#mk_a0
              signx mk_memvalue,pa
              jmp #mk_nextop ' don't need the rest of the op


mk_nibble_1 ' MOVE (byte)
              callpb mk_opword,#mk_setup_operand8_move
              call mk_readf
              callpa #7,#mk_move_shoot_the_shit
              callpb mk_opword,#mk_setup_operand8_move
              'debug("in move.b, writing ",uhex_byte(mk_memvalue)," to ",uhex_long(mk_effaddr))
              jmp mk_writef

mk_nibble_3 ' MOVE (word)
              'debug("in move.w")
              callpb mk_opword,#mk_setup_operand16_move
              call mk_readf
              callpa #15,#mk_move_shoot_the_shit
              callpb mk_opword,#mk_setup_operand16_move
              'debug("in move.w, writing ",uhex_word(mk_memvalue)," to ",uhex_long(mk_effaddr))
              jmp mk_writef

mk_nibble_2 ' MOVE (long)
              callpb mk_opword,#mk_setup_operand32_move
              call mk_readf
              callpa #31,#mk_move_shoot_the_shit
              callpb mk_opword,#mk_setup_operand32_move
              jmp mk_writef


mk_nibble_5 ' ADDQ/SUBQ/Scc/DBcc
              test mk_opword,#%11_000_000 wcz
        if_00 jmp #mk_nibble_5_not_addsub
              ' get operand
              mov mk_optmp1,mk_opword
              shr mk_optmp1,#9 wc ' C = SUBQ, NC = ADDQ
              and mk_optmp1,#7 wz
        if_z  mov mk_optmp1,#8
              ' Check if An reg
              test mk_opword,#%110_000 wz
              testb mk_opword,#3 andz
        if_z  jmp #.addsubq_areg
              callpb mk_opword,#mk_setup_operand_auto
              call mk_readf
              push mk_writef
        if_c  jmp #mk_sub_common
              jmp #mk_add_common

.addsubq_areg
              and mk_opword,#7
              altd mk_opword,#mk_a0
        _ret_ sumc 0-0,mk_optmp1


mk_nibble_5_not_addsub
              ' Check if DBCC
              test mk_opword,#%110_000 wz
              testb mk_opword,#3 andz
        if_z  jmp #mk_dbcc
              ' got SCC
              callpb mk_opword,#mk_setup_operand8
              call mk_readf ' <- yes, this is stupid but accurate
              getnib pb,mk_opword,#2
              shr pb,#1 wc
              altd pb,#mk_condition_truth_table
              testb 0-0,mk_sr xorc
              muxc mk_memvalue,#255
              jmp mk_writef


mk_romque_refill
              mov mk_romqueio_target,mk_romque_area_ptr
              mov mk_romqueio_length,#MK_ROMQUE_SIZE/2
              mov mk_romque_left,#MK_ROMQUE_SIZE wcz ' clear C and Z
              mov mk_romqueio_addr,mk_virtualpc
              zerox mk_romqueio_addr,mk_romque_zerox' Limit to 1 MB range
              add mk_romqueio_addr,mk_romque_base
              ' Handle not long-aligned access
              rczr mk_romqueio_addr wcz
        if_z  jmp #mk_address_error_debug ' TODO: maybe make AE function code read program in this case?
        if_c  sub  mk_romqueio_target,#2
        if_c  add  mk_romqueio_length,#1
              setq #2
              wrlong mk_romqueio_addr,#_progrq_addr
              cogatn mk_romio_atnval
              mov ptra,mk_romque_area_ptr
              waitatn
              jmp #mk_getop_rom


mk_compute_ea ' CAN AND WILL OVERWRITE FLAGS
              'debug("In mk_compute_ea ",ubin(pb))
              mov mk_eatmp1,pb
              shr mk_eatmp1,#3 wcz '< just to drive the point home
              and mk_eatmp1,#7
              altd mk_eatmp1,#mk_ea_impl_tbl - 2 ' non-memory modes shouldn't appear here
              jmp 0-0

mk_ea_direct
              and pb,#7
              alts pb,#mk_a0
        _ret_ mov mk_effaddr,0-0

mk_nibble_E   ' shifts
              andn mk_sr,#MK_OVER_MASK|MK_CARRY_MASK ' These are cleared by default
              test mk_opword,#%11_000_000 wcz
        if_00 jmp #.memshift
              mov pb,mk_opword
              andn pb,#%00_111_000
              call #mk_setup_operand_auto
              xor mk_shiftit,#31 ' <- change into MSB's index
              ' get shift amount
              call #mk_get_second_reg
              testb mk_opword,#5 wc
        if_nc mov mk_optmp1,pb wz
  if_nc_and_z mov mk_optmp1,#8
              and mk_optmp1,#63 wz
              ' move shift mode bits into place
              testb mk_opword,#8 wz
              shr  mk_opword,#2
              bitz mk_opword,#0
.do_shift
              call mk_readf
              'debug("regshift amount is ",udec(mk_optmp1),"also, ",udec(mk_shiftit)," shift val is ",uhex_long(mk_memvalue))
              and mk_opword,#7
              altd mk_opword,#mk_shift_impl_tbl
              call 0-0
.done
              zerox mk_memvalue,mk_shiftit wz
              testb mk_memvalue,mk_shiftit wc
              bitc mk_sr,#MK_NEG_BIT
              bitz mk_sr,#MK_ZERO_BIT
              'debug("shift result ",uhex_long(mk_memvalue))
              jmp mk_writef

.memshift
              mov pb,mk_opword
              call #mk_setup_operand16
              mov mk_shiftit,#15
              mov mk_optmp1,#1
              shr mk_opword,#8 ' get shift mode bits into place
              jmp #.do_shift

mk_zeroroxx
              testb mk_sr,#MK_EXT_BIT wc
        _ret_ bitc mk_sr,#MK_CARRY_BIT
mk_zeroshift
        _ret_ bitl mk_sr,#MK_CARRY_BIT

mk_do_asr
              tjz mk_optmp1,#mk_zeroshift
              rep @.loop,mk_optmp1
              testb mk_memvalue,mk_shiftit wz
              shr mk_memvalue,#1 wc
              bitz mk_memvalue,mk_shiftit
.loop
        _ret_ muxc mk_sr,#MK_EXT_MASK|MK_CARRY_MASK

mk_do_asl
              tjz mk_optmp1,#mk_zeroshift
              rep @.loop,mk_optmp1
              testb mk_memvalue,mk_shiftit wc
              shl mk_memvalue,#1
              testb mk_memvalue,mk_shiftit wz
        if_z_ne_c bith mk_sr,#MK_OVER_BIT
.loop
        _ret_ muxc mk_sr,#MK_EXT_MASK|MK_CARRY_MASK

mk_do_lsr
              tjz mk_optmp1,#mk_zeroshift
              rep @.loop,mk_optmp1
              shr mk_memvalue,#1 wc
.loop
        _ret_ muxc mk_sr,#MK_EXT_MASK|MK_CARRY_MASK

mk_do_lsl
              tjz mk_optmp1,#mk_zeroshift
              rep @.loop,mk_optmp1
              testb mk_memvalue,mk_shiftit wc
              shl mk_memvalue,#1
.loop
        _ret_ muxc mk_sr,#MK_EXT_MASK|MK_CARRY_MASK

mk_do_ror
              tjz mk_optmp1,#mk_zeroshift
              rep @.loop,mk_optmp1
              shr mk_memvalue,#1 wc
              bitc mk_memvalue,mk_shiftit
.loop
        _ret_ muxc mk_sr,#MK_CARRY_MASK

mk_do_rol
              tjz mk_optmp1,#mk_zeroshift
              rep @.loop,mk_optmp1
              testb mk_memvalue,mk_shiftit wc
              rcl mk_memvalue,#1
.loop
        _ret_ muxc mk_sr,#MK_CARRY_MASK

mk_do_roxr
              tjz mk_optmp1,#mk_zeroroxx
              rep @.loop,mk_optmp1
              testb mk_sr,#MK_EXT_BIT wz
              shr mk_memvalue,#1 wc
              bitz mk_memvalue,mk_shiftit
              muxc mk_sr,#MK_EXT_MASK|MK_CARRY_MASK
.loop
              ret
mk_do_roxl
              tjz mk_optmp1,#mk_zeroroxx
              rep @.loop,mk_optmp1
              testb mk_sr,#MK_EXT_BIT wc
              testb mk_memvalue,mk_shiftit wz
              rcl mk_memvalue,#1
              muxz mk_sr,#MK_EXT_MASK|MK_CARRY_MASK
.loop
              ret




mk_readrom_ea32
              mov mk_romio_length,#2
              skipf #%10
mk_readrom_ea
              mov pa,mk_effaddr
              mov mk_romio_length,#1
              rczr pa wcz
              mov mk_romio_target,mk_romio_area_ptr
        if_c  sub mk_romio_target,#2
        if_z  sub mk_romio_target,#1

              jmp #$

mk_setup_nothing8
mk_setup_nothing16
mk_setup_nothing32
mk_setup_memcard8
mk_setup_memcard16
mk_setup_memcard32
mk_setup_nvram8
mk_setup_nvram16
mk_setup_nvram32
              mov  mk_readf,#mk_rd_nothing
              mov  mk_writef,#mk_wrrom
              ret wcz

mk_setup_palette8
              mov  mk_writef,##pal32_wr8
              mov  mk_readf,##pal32_rd8
mk_setup_palette16
              mov  mk_writef,##pal32_wr16
              mov  mk_readf,##pal32_rd16
mk_setup_palette32
              mov  mk_writef,##pal32_wr32
              mov  mk_readf,##pal32_rd32
              'debug("mk_setup_palette canary")
              ret  wcz


mk_setup_rom_common
              mov  mk_romio_addr,mk_effaddr
              zerox mk_romio_addr,#19
              add  mk_romio_addr,mk_prog_base
              add  mk_romio_addr,mk_port_base
              zerox mk_romio_addr,#16
              add  mk_romio_addr,mk_bios_base

              mov  mk_readf,#mk_rd8_rom
              mov  mk_readf,#mk_rd16_rom
              mov  mk_readf,#mk_rd32_rom

              test mk_effaddr,mk_vectors_mask wz
        if_z  mov  mk_readf,#mk_rd8_vector
        if_z  mov  mk_readf,#mk_rd16_vector
        if_z  mov  mk_readf,#mk_rd32_vector

              mov  mk_writef,#mk_wrrom
              mov  mk_writef,#mk_wrportbank

              mov  mk_eacache,mk_romio_area_ptr_shr2 wcz ' Clear CZ
              rczr mk_romio_addr wcz
              rczl mk_eacache
              mov mk_romio_target,mk_romio_area_ptr
              mov mk_romio_length,#2
              ret  wcz

mk_setup_ram_common
              mov mk_eacache,mk_effaddr
              setword mk_eacache,#@main_ram>>16,#1

              mov  mk_readf,#mk_rd8_ram
              mov  mk_writef,#mk_wr8_ram

              mov  mk_readf,#mk_rd16_ram
              mov  mk_writef,#mk_wr16_ram

              mov  mk_readf,#mk_rd32_ram
              mov  mk_writef,#mk_wr32_ram

              ret wcz


mk_setup_reg8
              ' Address register 8 bit ops are illegal, so don't care
              and pb,#%1_111
              sets mk_rd8_reg,pb
              setd mk_wr8_reg,pb
              mov  mk_readf,#mk_rd8_reg
              mov  mk_writef,#mk_wr8_reg
              ret wcz
mk_setup_io8
              mov  mk_eacache,mk_effaddr
              zerox mk_eacache,#19
              mov  mk_readf,#mk_rd8_io
              mov  mk_writef,#mk_wr8_io
              'debug("in mk_setup_io8 ",uhex_long(mk_effaddr))
              'jmp pb wcz
              ret wcz


mk_setup_imm8
              call #mk_setup_imm16
              and mk_eacache,#255
              ret wcz

mk_setup_reg16
              'debug("in mk_setup_reg16 ",ubin(pb))
        'if_nz jmp #mk_setup_areg ' Address register is always 32 bit
              and pb,#%1_111
              sets mk_rd16_reg,pb
              setd mk_wr16_reg,pb
              mov  mk_readf,#mk_rd16_reg
              mov mk_writef,#mk_wr16_reg
              ret wcz
mk_setup_ram16
              mov mk_eacache,mk_effaddr
              setword mk_eacache,#@main_ram>>16,#1
              mov  mk_readf,#mk_rd16_ram
              mov  mk_writef,#mk_wr16_ram
              ret wcz
mk_setup_io16
              mov  mk_eacache,mk_effaddr
              zerox mk_eacache,#19
              mov  mk_readf,#mk_rd16_io
              mov  mk_writef,#mk_wr16_io
              ret wcz
mk_setup_imm16
              mov mk_eatmp0,mk_opword
              call mk_getopf
              mov mk_eacache,mk_opword
              mov mk_opword,mk_eatmp0
              mov  mk_readf,#mk_rdimm
              mov  mk_writef,#mk_illegal
              ret wcz

mk_setup_reg32
              and pb,#%1_111
              sets mk_rd32_reg,pb
              setd mk_wr32_reg,pb
              mov  mk_readf,#mk_rd32_reg
              mov  mk_writef,#mk_wr32_reg
              ret wcz
mk_setup_ram32
              mov mk_eacache,mk_effaddr
              setword mk_eacache,#@main_ram>>16,#1
              mov  mk_readf,#mk_rd32_ram
              mov  mk_writef,#mk_wr32_ram
              ret wcz


mk_setup_io32
              mov  mk_eacache,mk_effaddr
              zerox mk_eacache,#19
              mov  mk_readf,#mk_rd32_io
              mov  mk_writef,#mk_wr32_io
              ret wcz
mk_setup_imm32
              call #mk_setup_imm16
              mov mk_eatmp0,mk_opword
              call mk_getopf
              rolword mk_eacache,mk_opword,#0
              mov mk_opword,mk_eatmp0
              ret wcz


mk_nibble_4   ' AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
              mov pb,mk_opword ' set this up
              testb mk_opword,#8 wc
        if_c  jmp #.lea_chk  ' got LEA or CHK
              testb mk_opword,#11 wc
        if_nc jmp #.negop_or_srmove ' got NEGX/CLR/NEG/NOT or SR move
              testb mk_opword,#9 wc
        if_c  jmp #.complex ' got one of.. those..
              testb mk_opword,#7 wc
        if_c  jmp #.movem_ext   ' got MOVEM/EXT
              testb mk_opword,#6 wc
        if_nc jmp #mk_hub_nbcd  ' got NBCD
              ' must be SWAP/PEA
              test mk_opword,#%110_000 wz
        if_z  jmp #.swap
              ' ok, PEA
              call #mk_compute_ea ' mk_opword already in PB
              mov mk_memvalue,mk_effaddr
              sub mk_a7,#4
              mov mk_effaddr,mk_a7
              call #mk_setup_ea32
              jmp mk_writef

.complex
              testb mk_opword,#10 wc
        if_nc jmp #mk_hub_tst_tas
              testb mk_opword,#7 wc
        if_c  jmp #.jmp_jsr
              testb mk_opword,#5 wc
        if_nc jmp #mk_hub_link_trap
              testb mk_opword,#4 wc
        if_nc jmp #mk_hub_moveusp
              mov mk_optmp0,mk_opword
              and mk_optmp0,#7
              altd mk_optmp0,#mk_flowop_impl_tbl
              jmp 0-0

.jmp_jsr
              call #mk_compute_ea
              mov mk_branchdisplace,mk_effaddr
              sub mk_branchdisplace,mk_virtualpc
              testb mk_opword,#6 wc ' if NC, got JSR
        if_c  jmp #mk_dobranch
              jmp #mk_call


.swap
              and mk_opword,#15
              altd mk_opword,#mk_d0
              movbyts 0-0,#%%1032
              altd mk_opword,#mk_d0
              shl 0-0,#0 wcz
              bitc mk_sr,#MK_NEG_BIT
              bitz mk_sr,#MK_ZERO_BIT
        _ret_ andn mk_sr,#MK_OVER_MASK|MK_CARRY_MASK


.lea_chk
              testb mk_opword,#6 wc
        if_nc jmp #mk_hub_chk ' got CHK
              ' do LEA
              call #mk_compute_ea ' mk_opword already in PB
              setnib mk_opword,#1,#3
              alti mk_opword,#%000_100_000
        _ret_ mov 0-0,mk_effaddr

.movem_ext
              ' An mode here is technically illegal. We just treat it as extend.
              test mk_opword,#%110_000 wz
        if_nz jmp #mk_hub_movem
              testb mk_opword,#6 wc
        if_nc call #mk_setup_operand16
        if_c  call #mk_setup_operand32
              call mk_readf
        if_nc signx mk_memvalue,#7 wcz
        if_c  signx mk_memvalue,#15 wcz
              bitc mk_sr,#MK_NEG_BIT
              bitz mk_sr,#MK_ZERO_BIT
              andn mk_sr,#MK_OVER_MASK|MK_CARRY_MASK
              jmp mk_writef

.negop_or_srmove
              test mk_opword,#%11_000_000 wcz
        if_00 jmp #mk_hub_srmove ' is move from/to SR/CCR
              call #mk_setup_operand_auto ' mk_opword already in PB
              call mk_readf
              shl mk_memvalue,mk_shiftit
              testb mk_opword,#9 wz
        if_z  jmp #.clr_not ' got CLR or NOT
              ' ok, must be NEG/NEGX
              testb mk_opword,#10 wc
        if_nc jmp #mk_hub_negx
              ' got NEG
              neg mk_memvalue wcz
              bitc mk_sr,#MK_NEG_BIT
              bitz mk_sr,#MK_ZERO_BIT
              muxnz mk_sr,#MK_EXT_MASK|MK_CARRY_MASK
              cmp mk_memvalue,mk_bit31 wz
              bitz mk_sr,#MK_OVER_BIT
              sar mk_memvalue,mk_shiftit
              jmp mk_writef

.clr_not
              testbn mk_opword,#10 wz ' Z set if CLR
        if_z  mov mk_memvalue,#0 wc
        if_nz not mk_memvalue wc
              bitc mk_sr,#MK_NEG_BIT
              andn mk_sr,#MK_CARRY_MASK|MK_OVER_MASK
              shr mk_memvalue,mk_shiftit wz
              bitz mk_sr,#MK_ZERO_BIT
              jmp mk_writef






mk_nibble_C   ' MULx/AND/EXG/ABCD
              test mk_opword,#%11_000_000 wcz
        if_00 jmp #mk_hub_mul ' MULU/MULS
              test mk_opword,#%110_000 wz
              testb mk_opword,#8 andz
        if_nz setr mk_thelogicop,#%0101000_01 ' P2 AND WZ opcode
        if_nz jmp #mk_multilogic ' AND
              test mk_opword,#%11_000_000 wz
        if_z  jmp #mk_hub_abcd
              jmp #mk_hub_exg

mk_nibble_8   ' DIVx/OR/SBCD
              test mk_opword,#%11_000_000 wcz
        if_00 jmp #mk_hub_div ' DIVU/DIVS
              test mk_opword,#%110_000 wz
              testb mk_opword,#8 andz
        if_nz setr mk_thelogicop,#%0101010_01 ' P2 OR WZ opcode
        if_nz jmp #mk_multilogic ' OR
              'test mk_opword,#%11_000_000 wz
              jmp #mk_hub_sbcd

mk_nibble_B   ' CMP (M/A)
              ' check for CMPA
              test mk_opword,#%11_000_000 wcz
        if_00 jmp #mk_cmpa
              ' check for CMP
              testb mk_opword,#8 wc
        if_nc jmp #mk_cmp
              ' check for CMPM
              test mk_opword,#%110_000 wz
              testb mk_opword,#3 andz
        if_z  jmp #mk_hub_cmpm
              ' Ok, is EOR
              setr mk_thelogicop,#%0101011_01 ' P2 XOR WZ opcode
              jmp #mk_multilogic ' XOR


mk_dbcc       ' DBcc
              ' compute destination first...
              call #mk_getopimm16
              signx mk_optmp1,#15
              sub mk_optmp1,#2
              mov mk_branchdisplace,mk_optmp1
              ' check condition
              getnib pb,mk_opword,#2
              shr pb,#1 wc
              altd pb,#mk_condition_truth_table
              testb 0-0,mk_sr xorc
        if_c  ret ' terminated...
              and mk_opword,#7
              alts mk_opword,#mk_d0
              getword mk_optmp0,0-0,#0
              sub mk_optmp0,#1 wc
              altd mk_opword,#mk_d0
              setword 0-0,mk_optmp0,#0
        if_nc jmp #mk_dobranch
              ret

mk_get_second_reg
              mov pb,mk_opword
              shr pb,#9
              and pb,#7
              alts pb,#mk_d0
        _ret_ mov mk_optmp1,0-0

mk_getopimm_auto
              testb pb,#6 wc
        if_c  jmp #mk_getopimm16
              testb pb,#7 wc
        if_c  jmp #mk_getopimm32
              ' fall through!
mk_getopimm8
              mov mk_optmp0,mk_opword
              call mk_getopf
              getbyte mk_optmp1,mk_opword,#0
        _ret_ mov mk_opword,mk_optmp0
mk_getopimm16
              mov mk_optmp0,mk_opword
              call mk_getopf
              mov mk_optmp1,mk_opword
        _ret_ mov mk_opword,mk_optmp0
mk_getopimm32
              mov mk_optmp0,mk_opword
              call mk_getopf
              mov mk_optmp1,mk_opword
              call mk_getopf
              rolword mk_optmp1,mk_opword,#0
        _ret_ mov mk_opword,mk_optmp0



mk_call
              ' Push return address on stack
              sub mk_a7,#4
              mov mk_effaddr,mk_a7
              call #mk_setup_ea32
              mov mk_memvalue,mk_virtualpc
              call mk_writef
              'debug("SP after call: ",uhex_long(mk_a7),uhex_long(mk_virtualpc),shex_long(mk_branchdisplace))
              jmp #mk_dobranch

mk_nibble_6   ' branches
              ' compute destination
              mov mk_optmp1,mk_opword
              signx mk_optmp1,#7 wz
        if_z  call #mk_getopimm16
              signx mk_optmp1,#15
        if_z  sub mk_optmp1,#2
              mov mk_branchdisplace,mk_optmp1
              ' check condition
              getnib pb,mk_opword,#2
              shr pb,#1 wcz
        if_c_and_z jmp #mk_call
              altd pb,#mk_condition_truth_table
              testb 0-0,mk_sr xorc
        if_nc ret
              ' fall through
mk_dobranch
              'debug(uhex_long(mk_virtualpc),shex_long(mk_branchdisplace))
              'mov mk_optmp0,mk_virtualpc '' <--- DELETE THIS WHEN DONE DEBUGGING
              add mk_virtualpc,mk_branchdisplace
              {
              'cmp mk_virtualpc,##$2000 wz
        'if_e   jmp #.sussy_wussy
              cmp mk_virtualpc,##$03b18c wcz
        if_nz cmp mk_virtualpc,##$03b186 wcz
        if_nz cmp mk_virtualpc,##$03b5f6 wcz
        if_e  jmp #.sussy_wussy
              cmps mk_branchdisplace,##$FFFFFF wc
        if_ae jmp #.sussy_wussy
              cmps mk_branchdisplace,##-$FFFFFF wc
        if_ae jmp #.not_a_sussy_baka
.sussy_wussy
              debug("Sussy branch from ",uhex_long_(mk_optmp0)," to ",uhex_long_(mk_virtualpc),uhex_word(mk_opword),uhex_long(mk_d0,mk_a0,mk_a1,mk_a2,mk_a6))
              'jmp #$
.not_a_sussy_baka '}
              'debug("branching ",shex(mk_branchdisplace)," to ",uhex_long(mk_virtualpc))
              testb mk_virtualpc,#0 wc
        if_c  jmp #mk_address_error_debug ' TODO: maybe make AE function code read program in this case?
              tjz ptra,#.notfast ' if que not active, this isn't relevant
              ' see if fast branch within que is ok
              sar mk_branchdisplace,#1
              sub mk_romque_left,mk_branchdisplace
              cmp mk_romque_left,#MK_ROMQUE_SIZE+1 wc ' see below
              'debug("would be ",sdec(mk_romque_left))
              ' C set means that (romque_left>=0 && romque_left <= MK_ROMQUE_SIZE). That is the valid range
              ' (Yes, 0 is valid for our purposes, since that will just correctly refill the que on the next getop call)
        if_nc jmp #.notfast
              shl mk_branchdisplace,#1
              add ptra,mk_branchdisplace
              jmp #mk_nextop
.notfast
              mov mk_romque_left,#0
              mov ptra,#0
              'mov pb,mk_virtualpc
              'zerox pb,#23
              getnib pb,mk_virtualpc,#5
              jmprel pb

              jmp #.progexec
              jmp #.ramexec
              jmp #.portexec
              jmp #mk_address_error_debug
              jmp #mk_address_error_debug
              jmp #mk_address_error_debug
              jmp #mk_address_error_debug
              jmp #mk_address_error_debug
              jmp #mk_address_error_debug
              jmp #mk_address_error_debug
              jmp #mk_address_error_debug
              jmp #mk_address_error_debug
              jmp #.biosexec
              jmp #mk_address_error_debug
              jmp #mk_address_error_debug
              jmp #mk_address_error_debug

.progexec
              mov mk_romque_zerox,#19
              mov mk_romque_base,mk_prog_base
              mov mk_getopf,#mk_getop_rom
              jmp #mk_nextop
.portexec
              mov mk_romque_zerox,#19
              mov mk_romque_base,mk_port_base
              mov mk_getopf,#mk_getop_rom
              jmp #mk_nextop
.biosexec
              mov mk_romque_zerox,#16
              mov mk_romque_base,mk_bios_base
              mov mk_getopf,#mk_getop_rom
              jmp #mk_nextop
.ramexec
              mov mk_getopf,#mk_getop_ram
              jmp #mk_nextop


              '' DEBUG NONSENSE: DELETE WHEN DONE
              {
mk_debug_wrchk8
              cmp mk_eacache,##@main_ram+$1510 wz
        if_ne cmp mk_eacache,##@main_ram+$1511 wz
        if_ne cmp mk_eacache,##@main_ram+$1512 wz
        if_ne cmp mk_eacache,##@main_ram+$1513 wz
        if_ne ret wcz
              debug("wrchk8: ",uhex_byte_(mk_memvalue),uhex_word_(mk_eacache),uhex_long_(mk_virtualpc))
              ret wcz
              '' DEBUG NONSENSE: DELETE WHEN DONE
mk_debug_wrchk16
              cmp mk_eacache,##@main_ram+$1510 wz
        if_ne cmp mk_eacache,##@main_ram+$1512 wz
        if_ne ret wcz
              debug("wrchk16: ",uhex_word_(mk_memvalue),uhex_word_(mk_eacache),uhex_long_(mk_virtualpc))
              ret wcz
              '' DEBUG NONSENSE: DELETE WHEN DONE
mk_debug_wrchk32
              cmp mk_eacache,##@main_ram+$150C wz
        if_ne cmp mk_eacache,##@main_ram+$1510 wz
        'if_ne cmp mk_eacache,##@main_ram+$C642 wz
        'if_ne cmp mk_memvalue,##$9BEA_3228    wz
        if_ne ret wcz
              debug("wrchk32: ",uhex_long_(mk_memvalue),uhex_word_(mk_eacache),uhex_long_(mk_virtualpc),uhex_long(mk_d0),uhex_long(mk_a0))
              ret wcz
'}
              {
mk_debug_wrchk8
              getword mk_memtmp0,mk_a7,#0
              getword mk_memtmp1,mk_eacache,#0
              sub mk_memtmp1,mk_memtmp0
              cmp mk_memtmp1,#16 wc
        if_ae ret wcz
              debug("wrchk8: ",uhex_byte_(mk_memvalue),uhex_word_(mk_a7,mk_eacache),uhex_long_(mk_virtualpc),uhex_long_(mk_a0))
              ret wcz
              '}

              fit 1024


DAT ' MotoKore 68000 hub resident code

              orgh

mk_ea_predec
              mov mk_eatmp0,pb
              and mk_eatmp0,#7
              shr pb,#6
              decod pb ' is now step value
              cmp mk_eatmp0,#7 wz ' A7 is a special snowflake...
        if_z  fge pb,#2

              altd mk_eatmp0,#mk_a0
              sub 0-0,pb
              alts mk_eatmp0,#mk_a0
        _ret_ mov mk_effaddr,0-0

mk_ea_postinc
              mov mk_eatmp0,pb
              and mk_eatmp0,#7
              shr pb,#6
              decod pb ' is now step value
              cmp mk_eatmp0,#7 wz ' A7 is a special snowflake...
        if_z  fge pb,#2

              alts mk_eatmp0,#mk_a0
              mov mk_effaddr,0-0
              altd mk_eatmp0,#mk_a0
        _ret_ add 0-0,pb

mk_ea_displace
              and pb,#7
              alts pb,#mk_a0
              mov mk_effaddr,0-0

              mov mk_eatmp1,mk_opword ' backup
              call mk_getopf
              signx mk_opword,#15
              add mk_effaddr,mk_opword
        _ret_ mov mk_opword,mk_eatmp1 ' restore


mk_ea_index
              and pb,#7
              alts pb,#mk_a0
              mov mk_effaddr,0-0
              'debug(if(mk_debug_ctr),"from address register: ",uhex_long_(mk_effaddr))

              mov mk_eatmp1,mk_opword ' backup
              call mk_getopf
              ' handle index reg
              getnib pb,mk_opword,#3
              alts pb,#mk_d0
              mov pb,0-0
              testb mk_opword,#11 wc
        if_nc signx pb,#15
              'debug(if(mk_debug_ctr),"from index register: ",uhex_long_(pb))
              add mk_effaddr,pb
              ' handle displacement
              signx mk_opword,#7
              'debug(if(mk_debug_ctr),"from displacement: ",uhex_long_(mk_opword))
               add mk_effaddr,mk_opword
              'debug(if(mk_debug_ctr),"final: ",uhex_long_(mk_effaddr))
        _ret_ mov mk_opword,mk_eatmp1 ' restore


mk_ea_headache
              mov mk_eatmp1,mk_opword ' backup
              call mk_getopf
              'debug("in mk_ea_headache ",uhex_word(mk_opword))
              testb pb,#0 wz
              testb pb,#1 wc
        if_01 jmp #.longabs
        if_11 jmp #.index
              signx mk_opword,#15 ' absolute short or PC displacement
              mov mk_effaddr,mk_opword
        if_1x add mk_effaddr,mk_virtualpc
        if_1x sub mk_effaddr,#2
        _ret_ mov mk_opword,mk_eatmp1 ' restore

.longabs
              mov  mk_effaddr,mk_opword
              call mk_getopf
              rolword mk_effaddr,mk_opword,#0
        _ret_ mov mk_opword,mk_eatmp1 ' restore

.index
              mov mk_effaddr,mk_virtualpc
              sub mk_effaddr,#2
              ' handle index reg
              getnib pb,mk_opword,#3
              alts pb,#mk_d0
              mov pb,0-0
              testb mk_opword,#11 wc
        if_nc signx pb,#15
              add mk_effaddr,pb
              ' handle displacement
              signx mk_opword,#7
              add mk_effaddr,mk_opword
              'debug("computed address for (d8,PC,Dn) is ",uhex_long(mk_effaddr),uhex_long(mk_virtualpc))
        _ret_ mov mk_opword,mk_eatmp1 ' restore


mk_hub_wr_sr
              ' Status register write escalated
              ' C is still super bit from SR
        if_nc mov pb,#$20 ' privilege violation
        if_nc jmp #mk_hub_trapit
mk_hub_set_sr
              'debug("in mk_hub_set_sr ",uhex_word(mk_sr,mk_memvalue),uhex_long(mk_virtualpc))
              testb mk_sr,#MK_SUPER_BIT wc
              testb mk_memvalue,#MK_SUPER_BIT xorc
              ' switching supervisor/user: swap stack pointers
        if_c  xor mk_a7,mk_othersp
        if_c  xor mk_othersp,mk_a7
        if_c  xor mk_a7,mk_othersp

              ' configure hooks
              and mk_memvalue,##%10100111_00011111
              testb mk_memvalue,#MK_TRACE_BIT wc
        if_c  mov mk_ihook1,##(%1111_1101100_0<<20) + @mk_hub_tracehook ' JMP #\mk_hub_tracehook
        if_c  jmp #.no_irqhooks
              ' check irq level
              getnib pb,mk_memvalue,#2
              cmp pb,#2 wc
        if_ae mov mk_ihook1,#0 ' NOP
        if_b  mov mk_ihook1,##(%1111_1011110_010_000000101<<9)+mk_irq2ptr ' JSE2 mk_irq2ptr
              cmp pb,#1 wc
        if_ae mov mk_ihook2,#0 ' NOP
        if_b  mov mk_ihook2,##(%1111_1011110_010_000000100<<9)+mk_irq1ptr ' JSE1 mk_irq1ptr
.no_irqhooks

              mov mk_sr,mk_memvalue
              ret wcz

mk_hub_irq2
              mov pb,#2
              setse2 #4 ' disable event (set to LUT write trigger) until ACK
              skip #%11
mk_hub_irq1
              setse1 #4 ' disable event (set to LUT write trigger) until ACK
              mov pb,#1
mk_hub_do_irq
              'debug("running IRQ ",udec(pb))
              'debug(uhex_word_array(#@vdp_ram+$FB60,#2))
              'waitx ##10_000_000
              ' get vector
              mov mk_optmp0,pb
              shl mk_optmp0,#2
              add mk_optmp0,mk_vectors_ptr
              add mk_optmp0,#$60
              rdlong mk_branchdisplace,mk_optmp0
              sub mk_branchdisplace,mk_virtualpc
              ' set supervisor mode, unset trace mode and set interrupt priority
              mov mk_optmp2,mk_sr
              mov mk_memvalue,mk_sr
              bith pb,#MK_SUPER_BIT-8
              setbyte mk_memvalue,pb,#1
              call #mk_hub_set_sr
              ' push PC
              sub mk_a7,#4
              mov mk_effaddr,mk_a7
              call #mk_setup_ea32
              mov mk_memvalue,mk_virtualpc
              call mk_writef
              ' push SR
              sub mk_a7,#2
              mov mk_effaddr,mk_a7
              call #mk_setup_ea16
              mov mk_memvalue,mk_optmp2
              call mk_writef
              'waitx ##_CLKFREQ/120
              jmp #mk_dobranch




mk_hub_tracehook
              getnib pb,mk_sr,#2
              cmp pb,#2 wc
        if_b  JSE2 mk_irq2ptr
              cmp pb,#1 wc
        if_b  JSE1 mk_irq1ptr
              mov pb,#$24
              jmp #mk_hub_trapit


mk_nibble_A   ' Line A emulator
              mov pb,#$28
              jmp #mk_hub_trapit

mk_nibble_F   ' Line F emulator
              mov pb,#$2C
              ' fall through
mk_hub_trapit
              debug("handling trap with vector ",uhex_(pb)," @ ",uhex_long(mk_virtualpc))
              ' get vector
              add pb,mk_vectors_ptr
              rdlong mk_branchdisplace,pb
              sub mk_branchdisplace,mk_virtualpc
              ' set supervisor mode, unset trace mode
              mov mk_optmp2,mk_sr
              mov mk_memvalue,mk_sr
              bith mk_memvalue,#MK_SUPER_BIT
              bitl mk_memvalue,#MK_TRACE_BIT
              call #mk_hub_set_sr
              ' push PC
              sub mk_a7,#4
              mov mk_effaddr,mk_a7
              call #mk_setup_ea32
              mov mk_memvalue,mk_virtualpc
              call mk_writef
              ' push SR
              sub mk_a7,#2
              mov mk_effaddr,mk_a7
              call #mk_setup_ea16
              mov mk_memvalue,mk_optmp2
              call mk_writef
              jmp #mk_dobranch

mk_address_error_debug
              'drvh #38
              debug("special edition spicy address error ")
              'jmp #$
mk_address_error ' can basically only happen due to misalignment?
              debug("something something address error ",uhex_long(mk_effaddr),uhex_long(mk_virtualpc),uhex_long(mk_optmp0),uhex_word(mk_opword))
              debug(uhex_reg_array(#mk_d0,#8))
              debug(uhex_reg_array(#mk_a0,#8))
              wrlong ##$FF00FF_00,##palette32+4*16*256-4
              jmp #$
              ' get vector
              mov mk_optmp1,mk_vectors_ptr
              add mk_optmp1,#$0C
              rdlong mk_branchdisplace,mk_optmp1
              sub mk_branchdisplace,mk_virtualpc
              mov mk_optmp1,mk_effaddr ' save for later
              ' set supervisor mode, unset trace mode
              mov mk_optmp2,mk_sr
              mov mk_memvalue,mk_sr
              bith mk_memvalue,#MK_SUPER_BIT
              bitl mk_memvalue,#MK_TRACE_BIT
              call #mk_hub_set_sr
              ' push PC
              sub mk_a7,#4
              mov mk_effaddr,mk_a7
              call #mk_setup_ea32
              mov mk_memvalue,mk_virtualpc
              call mk_writef
              ' push SR
              sub mk_a7,#2
              mov mk_effaddr,mk_a7
              call #mk_setup_ea16
              mov mk_memvalue,mk_optmp2
              call mk_writef
              ' push instruction in progress (maybe)
              sub mk_a7,#2
              mov mk_effaddr,mk_a7
              call #mk_setup_ea16
              mov mk_memvalue,mk_opword
              call mk_writef
              ' push erroneous address
              sub mk_a7,#4
              mov mk_effaddr,mk_a7
              call #mk_setup_ea32
              mov mk_memvalue,mk_optmp1
              call mk_writef
              ' push flags
              sub mk_a7,#2
              mov mk_effaddr,mk_a7
              call #mk_setup_ea16
              ' slight problem: we don't know half this shit
              mov mk_memvalue,#%10_001 ' assume it's a data read. It's probably a data read. Isn't it?
              testb mk_optmp2,#MK_SUPER_BIT wc
              bitc mk_memvalue,#2 ' we do know what mode we were in though
              call mk_writef
              jmp #mk_dobranch








mk_hub_stop
              call #mk_getopimm16
              debug("STOP instruction ",uhex_word(mk_opword),uhex_word(mk_optmp1)," encountered")
              'debug(uhex_word_array(#vdp_ram+$C418,#16))
               mov mk_memvalue,mk_optmp1
               call #mk_wr_sr
.waitloop
              '' TODO: re-enable interrupt support
              {
              pollatn wc
        if_c  rdbyte pb,#atn_command wc
        if_c  jmp #mk_hub_hotreset
              }
              getnib pb,mk_sr,#2
              cmp pb,#2 wc
        if_b  JSE2 mk_irq2ptr
              cmp pb,#1 wc
        if_b  JSE1 mk_irq1ptr
              jmp #.waitloop
              debug("jooo wtf")

mk_hub_reset
              debug("RESET instruction ",uhex_word(mk_opword)," encountered")
              jmp #$

mk_hub_nop
              waitx #32 ' make NOP slow to fix Z80 race condition in some Data East games (magdrop2 etc)
              cmp mk_opword,##$4E71 wz
        if_z  ret
              debug("weird NOP ? ",uhex_word(mk_opword),uhex_long(mk_virtualpc))
              ret



mk_hub_rte
              testb mk_sr,#MK_SUPER_BIT wc
        if_nc mov pb,#$20 ' privilege violation
        if_nc jmp #mk_hub_trapit
              mov mk_effaddr,mk_a7
              call #mk_setup_ea16
              call mk_readf
              mov mk_optmp2,mk_memvalue ' only write SR after we're done popping
              add mk_a7,#2
              mov mk_effaddr,mk_a7
              call #mk_setup_ea32
              call mk_readf
              mov mk_branchdisplace,mk_memvalue
              sub mk_branchdisplace,mk_virtualpc
              add mk_a7,#4
              'debug("RTE from ",uhex_long_(mk_virtualpc)," to ",uhex_long(mk_memvalue))
              mov mk_memvalue,mk_optmp2 ' only write SR after we're done popping
              call #mk_wr_sr
              jmp #mk_dobranch

mk_hub_rtr
              mov mk_effaddr,mk_a7
              call #mk_setup_ea16
              call mk_readf
              call #mk_wr_ccr
              add mk_a7,#2
              ' fall through
mk_hub_rts
              mov mk_effaddr,mk_a7
              call #mk_setup_ea32
              call mk_readf
              'debug("SP before RTS: ",uhex_long(mk_a7),uhex_long(mk_memvalue),uhex_long(mk_virtualpc))
              mov mk_branchdisplace,mk_memvalue
              sub mk_branchdisplace,mk_virtualpc
              add mk_a7,#4
              jmp #mk_dobranch


mk_hub_trapv
              testb mk_sr,#MK_OVER_BIT wc
        if_nc ret
              mov pb,#$1C
              jmp #mk_hub_trapit

mk_hub_moveusp
              testb mk_sr,#MK_SUPER_BIT wc
        if_nc mov pb,#$20
        if_nc jmp #mk_hub_trapit ' TODO: proper non-supervisor trap
              mov pb,mk_opword
              and pb,#7
              testb mk_opword,#3 wc ' if C, read USP, if NC, write USP
              'debug("in mk_hub_moveusp ",uhex_word(mk_opword),udec(pb),uhex_long(mk_othersp),uhex_long(mk_nibble_impl_tbl+3),uhex_long(inb))
        if_c  altd pb,#mk_a0
        if_c  mov 0-0,mk_othersp
        if_nc alts pb,#mk_a0
        if_nc mov mk_othersp,0-0
              'debug("in mk_hub_moveusp again ",uhex_word(mk_opword),udec(pb),uhex_long(mk_othersp),uhex_long(mk_nibble_impl_tbl+3))
              ret



mk_hub_tst_tas
              getbyte mk_optmp0,mk_opword,#0
              cmp mk_optmp0,#%11_111_100 wz
        if_z  jmp #mk_illegal
              test mk_opword,#%11_000_000 wcz
        if_00 andn pb,#%11_000_000 ' convert TAS to TST.B (Note: if_00 here really means ""if_11"" (not zero and even parity))
              call #mk_setup_operand_auto
              call mk_readf
              'debug("in TST/TAS with ",uhex_long(mk_virtualpc),uhex_word(mk_opword),uhex(mk_memvalue),uhex(mk_shiftit),uhex(mk_d0))
              shl mk_memvalue,mk_shiftit wz
              testb mk_memvalue,#31 wc
              bitc mk_sr,#MK_NEG_BIT
              bitz mk_sr,#MK_ZERO_BIT
              andn mk_sr,#MK_OVER_MASK|MK_CARRY_MASK
              'debug("SR after",ubin_word(mk_sr))
              test mk_opword,#%11_000_000 wcz
        if_c_or_z ret ' not TAS
              test mk_opword,#%00_111_000 wz
        'if_nz ret ' not register TAS (memory TAS is broken due to buggy SEGA bus logic)
              shr mk_memvalue,#24
              or mk_memvalue,#$80
              jmp mk_writef

mk_hub_link_trap
              testb mk_opword,#4 wc
        if_nc jmp #.trap
              testb mk_opword,#3 wc
        if_c  jmp #.unlk
              ' okay, LINK
              sub mk_a7,#4
              mov mk_effaddr,mk_a7
              mov mk_optmp0,mk_opword
              and mk_optmp0,#7
              call #mk_setup_ea32
              alts mk_optmp0,#mk_a0
              mov mk_memvalue,0-0
              call mk_writef
              altd mk_optmp0,#mk_a0
              mov 0-0,mk_a7
              call #mk_getopimm16
              signx mk_optmp1,#15
        _ret_ add mk_a7,mk_optmp1


.unlk         ' UNLK
              mov mk_optmp0,mk_opword
              and mk_optmp0,#7
              alts mk_optmp0,#mk_a0
              mov mk_a7,0-0
              mov mk_effaddr,mk_a7
              call #mk_setup_ea32
              call mk_readf
              altd mk_optmp0,#mk_a0
              mov 0-0,mk_memvalue
        _ret_ add mk_a7,#4


.trap
              getnib pb,mk_opword,#0
              shl pb,#2
              add pb,#$80
              jmp #mk_hub_trapit


mk_nibble_7 ' MOVEQ
              mov pb,mk_opword
              and pb,mk_dreg_mask
              signx mk_opword,#7 wcz
              bitc mk_sr,#MK_NEG_BIT
              bitz mk_sr,#MK_ZERO_BIT
              andn mk_sr,#MK_OVER_MASK|MK_CARRY_MASK
              alti pb,#%000_100_000
.moveop _ret_ mov mk_d0,mk_opword


mk_hub_movem  ' MOVEM
              'debug("in mk_hub_movem ",uhex_long(mk_a0))
              call #mk_getopimm16
              testb mk_opword,#10 wc
        if_c  neg mk_optmp2,#1
        if_c  jmp #.movem_do_read
              'debug(ubin_word(mk_opword))
              test mk_opword,#%011_000 wz
        if_z  mov mk_optmp2,#mk_a7
        if_z  jmp #.movem_do_predec_write
              mov mk_optmp2,#0
              call #mk_compute_ea
              jmp #.movem_write

              ' MOVEM normal write
.writeloop
              testb mk_opword,#6 wc ' long/word ?
        if_c  call #mk_setup_ea32
        if_nc call #mk_setup_ea16
              call mk_writef
        if_c  add mk_effaddr,#4
        if_nc add mk_effaddr,#2
.movem_write
              'debug("at .movem_write ",uhex_long(mk_optmp2),uhex_long(mk_effaddr),ubin_word(mk_optmp1))
              alti mk_optmp2,#%000_000_111 ' increment register ptr
              mov mk_memvalue,0-0
              'debug("got value ",uhex_long(mk_memvalue),uhex_long(mk_optmp2))
              shr mk_optmp1,#1 wcz
        if_c  jmp #.writeloop
        if_nc_and_nz jmp #.movem_write
              ret



              ' MOVEM predec write
.movem_do_predec_write
              mov pb,mk_opword
              and pb,#7
              alts pb,#mk_a0
              mov mk_effaddr,0-0
              jmp #.movem_predec_write

.predec_write_loop
              testb mk_opword,#6 wc ' long/word ?
        if_c  sub mk_effaddr,#4
        if_nc sub mk_effaddr,#2
        if_c  call #mk_setup_ea32
        if_nc call #mk_setup_ea16
              call mk_writef
.movem_predec_write
              'debug("at .movem_predec_write ",uhex_long(mk_optmp2),uhex_long(mk_effaddr),ubin_word(mk_optmp1),uhex_word(mk_opword))
              alti mk_optmp2,#%000_000_110 ' decrement register ptr
              mov mk_memvalue,0-0
              shr mk_optmp1,#1 wcz
        if_c  jmp #.predec_write_loop
        if_nc_and_nz jmp #.movem_predec_write
              ' done.
              and mk_opword,#7
              altd mk_opword,#mk_a0
        _ret_ mov 0-0,mk_effaddr

              ' MOVEM read
.movem_do_read
              call #mk_compute_ea
              jmp #.movem_read

.readloop

              testb mk_opword,#6 wc ' long/word ?
        if_c  call #mk_setup_ea32
        if_nc call #mk_setup_ea16
              call mk_readf
        if_nc signx mk_memvalue,#15
              altd mk_optmp2,#mk_d0
              mov 0-0,mk_memvalue
        if_c  add mk_effaddr,#4
        if_nc add mk_effaddr,#2
.movem_read
              'debug("at .movem_read",uhex_long(mk_optmp2),uhex_long(mk_effaddr),ubin_word(mk_optmp1),uhex_word(mk_opword))
              add mk_optmp2,#1
              shr mk_optmp1,#1 wcz
        if_c  jmp #.readloop
        if_nc_and_nz jmp #.movem_read
              ' if empty
              mov pb,mk_opword
              and pb,#%111_000
              cmp pb,#%011_000 wz ' is postinc mode?
        if_nz ret
              and mk_opword,#7
              altd mk_opword,#mk_a0
        _ret_ mov 0-0,mk_effaddr




mk_hub_movep  ' MOVEP
              debug("in mk_hub_movep")
              ' compute address
              call #mk_getopimm16
              signx mk_optmp1,#15
              mov mk_effaddr,mk_optmp1
              getnib pb,mk_opword,#0 ' will be %1xxx
              alts pb,#mk_d0
              add mk_effaddr,0-0

              testb mk_opword,#7 wc
        if_c  jmp #.movep_write

              call #mk_setup_ea8
              call mk_readf
              rolbyte mk_optmp2,mk_memvalue,#0
              add mk_effaddr,#2
              call #mk_setup_ea8
              call mk_readf
              rolbyte mk_optmp2,mk_memvalue,#0
              testb mk_opword,#6 wc
        if_nc mov mk_shiftit,#16
        if_nc jmp #.read_done
              mov mk_shiftit,#0
              add mk_effaddr,#2
              call #mk_setup_ea8
              call mk_readf
              rolbyte mk_optmp2,mk_memvalue,#0
              add mk_effaddr,#2
              call #mk_setup_ea8
              call mk_readf
              rolbyte mk_optmp2,mk_memvalue,#0
.read_done
              mov mk_memvalue,mk_optmp2
              jmp #mk_write_second_reg


.movep_write
              call #mk_get_second_reg
              testb mk_opword,#6 wc
        if_nc shl mk_optmp1,#16
              call #mk_setup_ea8
              getbyte mk_memvalue,mk_optmp1,#3
              call mk_writef
              add mk_effaddr,#2
              call #mk_setup_ea8
              getbyte mk_memvalue,mk_optmp1,#2
              call mk_writef
              testb mk_opword,#6 wc
        if_nc ret
              add mk_effaddr,#2
              call #mk_setup_ea8
              getbyte mk_memvalue,mk_optmp1,#1
              call mk_writef
              add mk_effaddr,#2
              call #mk_setup_ea8
              getbyte mk_memvalue,mk_optmp1,#0
              jmp mk_writef



mk_hub_mul    ' MULU/MULS
              mov pb,mk_opword
              call #mk_setup_operand16
              call mk_readf
              mov pb,mk_opword
              and pb,mk_dreg_mask
              testb mk_opword,#8 wc ' set c if signed
        if_nc alti pb,#%000_100_000
        if_nc mul 0-0,mk_memvalue wz
        if_c  alti pb,#%000_100_000
        if_c  muls 0-0,mk_memvalue wz
              bitz mk_sr,#MK_ZERO_BIT
              alti pb,#%000_100_000
              testb 0-0,#31 wz
              bitz mk_sr,#MK_NEG_BIT
        _ret_ andn mk_sr,#MK_CARRY_MASK|MK_OVER_MASK

mk_hub_div    ' DIVU/DIVS
              mov pb,mk_opword
              call #mk_setup_operand16
              call mk_readf ' get divider
              mov pb,mk_opword
              shr pb,#9
              and pb,#7
              alts pb,#mk_d0
              mov mk_optmp0,0-0 ' get divisor
              tjz mk_memvalue,#.by_zero
              mov mk_optmp1,#0 ' bit 0 holds appropriate result sign
              testb mk_opword,#8 wz ' set z if signed
        if_z  signx mk_memvalue,#15
        if_z  abs mk_memvalue wc
        if_z_and_c bitnot mk_optmp1,#0
        if_z  abs mk_optmp0 wc
        if_z_and_c bitnot mk_optmp1,#0
              qdiv mk_optmp0,mk_memvalue
              bitl mk_sr,#MK_CARRY_BIT
              getqx mk_memvalue    ' quotient
              getqy mk_optmp0      ' remainder
              ' Apply sign
              testb mk_optmp1,#0 wc
              negc mk_memvalue
              negc mk_optmp0
              testb mk_memvalue,#15 wc
              bitc mk_sr,#MK_NEG_BIT
              ' Check overflow
              mov mk_optmp1,mk_memvalue
              testb mk_opword,#8 wz ' set z if signed
        if_z  signx mk_memvalue,#15
        if_nz zerox mk_memvalue,#15
              cmp mk_optmp1,mk_memvalue wz
              bitnz mk_sr,#MK_OVER_BIT
        if_nz bith mk_sr,#MK_NEG_BIT ' Undocumented flag
        if_nz ret
              ' set Z flag (not set on overflow?)
              cmp mk_memvalue,#0 wz
              bitz mk_sr,#MK_ZERO_BIT
              ' write back
              setword mk_memvalue,mk_optmp0,#1
              altd pb,#mk_d0
        _ret_ mov 0-0,mk_memvalue

.by_zero
              mov pb,#$14
              ' Strange flags...
              andn mk_sr,#MK_CARRY_MASK|MK_OVER_MASK|MK_NEG_MASK
              testb mk_opword,#8 wc ' set c if signed
        if_c  bith mk_sr,#MK_ZERO_BIT
        if_c  jmp #mk_hub_trapit
              shr mk_optmp0,#16
              cmps mk_optmp0,#0 wcz
              bitz mk_sr,#MK_ZERO_BIT
              bitc mk_sr,#MK_NEG_BIT
              jmp #mk_hub_trapit


mk_hub_srmove
              call #mk_setup_operand16
              testb mk_opword,#10 wc ' FROM (NC) or TO (C) SR
        if_nc push mk_writef
        if_nc jmp #mk_rd_sr
              testb mk_opword,#9 wz ' if to SR, to whole SR (Z) or CCR only (NZ)
        if_z  push #mk_wr_sr
        if_nz push #mk_wr_ccr
              jmp mk_readf



mk_hub_exg
              ' okay got EXG
              ' encoding is a bit stupid, see manual
              mov pb,mk_opword
              and pb,#7 ' register Y
              mov pa,mk_opword
              shr pa,#9
              and pa,#7 ' register X
              testb mk_opword,#3 wc
              testb mk_opword,#7 wz
        if_c  add pb,#8
        if_c_and_nz add pa,#8
              alts pb,#mk_d0
              mov mk_optmp0,0-0
              alts pa,#mk_d0
              mov mk_optmp1,0-0
              altd pb,#mk_d0
              mov 0-0,mk_optmp1
              altd pa,#mk_d0
        _ret_ mov 0-0,mk_optmp0


mk_hub_abcd   ' ABCD
              ' isolate register nos
              mov mk_optmp0,mk_opword
              and mk_optmp0,#7 ' source
              mov mk_optmp2,mk_opword
              shr mk_optmp2,#9
              and mk_optmp2,#7 ' destination
              ' check for -(An),-(An) mode
              testb mk_opword,#3 wc
        if_c  jmp #.memmode
              alts mk_optmp0,#mk_d0
              getbyte mk_optmp1,0-0,#0
              alts mk_optmp2,#mk_d0
              getbyte mk_memvalue,0-0,#0
.doit
              ' See: https://github.com/flamewing/68k-bcd-verifier/blob/master/bcd-emul.cc#L52
              ' compute ss
              testb mk_sr,#MK_EXT_BIT wc
              mov mk_optmp0,mk_memvalue
              addx mk_optmp0,mk_optmp1
              ' compute bc
              mov mk_optmp2,mk_memvalue
              and mk_optmp2,mk_optmp1
              andn mk_memvalue,mk_optmp0 ' note: don't need the original operands anymore
              or mk_optmp2,mk_memvalue
              andn mk_optmp1,mk_optmp0 ' note: ^^
              or mk_optmp2,mk_optmp1
              and mk_optmp2,#$88
              ' compute dc
              mov mk_memvalue,mk_optmp0
              add mk_memvalue,#$66
              xor mk_memvalue,mk_optmp0
              and mk_memvalue,#$110
              shr mk_memvalue,#1
              ' compute corf
              or mk_memvalue,mk_optmp2
              sca mk_memvalue,##$4000 ' equivalent to >> 2
              sub mk_memvalue,0-0
              ' compute result
              add mk_memvalue,mk_optmp0
              ' write to register if needed
              testb mk_opword,#3 wc
        if_nc and mk_opword,mk_dreg_mask ' don't need opword anymore
        if_nc alti mk_opword,#%000_100_000
        if_nc setbyte 0-0,mk_memvalue,#0
              ' compute carry
              testb mk_optmp0,#7 wc
              testbn mk_memvalue,#7 andc
              testb mk_optmp2,#7 orc
              muxc mk_sr,#MK_CARRY_MASK|MK_EXT_MASK
              ' compute overflow
              testbn mk_optmp0,#7 wc
              testb mk_memvalue,#7 andc
              bitc mk_sr,#MK_OVER_BIT
              ' compute zero flag
              test mk_memvalue,#255 wz
        if_nz bitl mk_sr,#MK_ZERO_BIT
              ' compute neg flag
              testb mk_memvalue,#7 wc
        _ret_ bitc mk_sr,#MK_NEG_BIT
              ' returns either to nextop or mk_writef
.memmode
              altd mk_optmp0,#mk_a0
              sub  0-0,#1
              alts mk_optmp0,#mk_a0
              mov  mk_effaddr,0-0
              call #mk_setup_ea8
              call mk_readf
              mov mk_optmp1,mk_memvalue
              altd mk_optmp2,#mk_a0
              sub  0-0,#1
              alts mk_optmp2,#mk_a0
              mov  mk_effaddr,0-0
              call #mk_setup_ea8
              ' - jmp into mk_readf
              ' - returns into .doit
              ' - returns into mk_writef
              push mk_writef
              loc pb,#.doit
              push pb
              jmp mk_readf


mk_hub_sbcd
              ' isolate register nos
              mov mk_optmp0,mk_opword
              and mk_optmp0,#7 ' source
              mov mk_optmp2,mk_opword
              shr mk_optmp2,#9
              and mk_optmp2,#7 ' destination
              ' check for -(An),-(An) mode
              testb mk_opword,#3 wc
        if_c  jmp #.memmode
              alts mk_optmp0,#mk_d0
              getbyte mk_optmp1,0-0,#0
              alts mk_optmp2,#mk_d0
              getbyte mk_memvalue,0-0,#0
.doit
              ' See: https://github.com/flamewing/68k-bcd-verifier/blob/master/bcd-emul.cc#L80
              ' compute dd
              testb mk_sr,#MK_EXT_BIT wc
              mov mk_optmp0,mk_memvalue
              subx mk_optmp0,mk_optmp1
              ' compute bc
              not mk_optmp2,mk_memvalue
              and mk_optmp2,mk_optmp1
              not  mk_memvalue ' note: don't need the original operands anymore
              and mk_memvalue,mk_optmp0
              or mk_optmp2,mk_memvalue
              and mk_optmp1,mk_optmp0 ' note: ^^
              or mk_optmp2,mk_optmp1
              and mk_optmp2,#$88
              ' compute corf
              mov mk_memvalue,mk_optmp2
              sca mk_memvalue,##$4000 ' equivalent to >> 2
              sub mk_memvalue,0-0
              ' compute result
              subr mk_memvalue,mk_optmp0
              ' write to register if needed
              testb mk_opword,#3 wc
        if_nc and mk_opword,mk_dreg_mask ' don't need opword anymore
        if_nc alti mk_opword,#%000_100_000
        if_nc setbyte 0-0,mk_memvalue,#0
              ' compute carry
              testbn mk_optmp0,#7 wc
              testb mk_memvalue,#7 andc
              testb mk_optmp2,#7 orc
              muxc mk_sr,#MK_CARRY_MASK|MK_EXT_MASK
              ' compute overflow
              testb mk_optmp0,#7 wc
              testbn mk_memvalue,#7 andc
              bitc mk_sr,#MK_OVER_BIT
              ' compute zero flag
              test mk_memvalue,#255 wz
        if_nz bitl mk_sr,#MK_ZERO_BIT
              ' compute neg flag
              testb mk_memvalue,#7 wc
        _ret_ bitc mk_sr,#MK_NEG_BIT
              ' returns either to nextop or mk_writef
.memmode
              altd mk_optmp0,#mk_a0
              sub  0-0,#1
              alts mk_optmp0,#mk_a0
              mov  mk_effaddr,0-0
              call #mk_setup_ea8
              call mk_readf
              mov mk_optmp1,mk_memvalue
              altd mk_optmp2,#mk_a0
              sub  0-0,#1
              alts mk_optmp2,#mk_a0
              mov  mk_effaddr,0-0
              call #mk_setup_ea8
              ' - jmp into mk_readf
              ' - returns into .doit
              ' - returns into mk_writef
              push mk_writef
              loc pb,#.doit
              push pb
              jmp mk_readf




mk_hub_nbcd
              'debug ("in NBCD with ",uhex(mk_opword))
              call #mk_setup_operand8 ' opword still in PB!
              call mk_readf
              ' See: https://github.com/flamewing/68k-bcd-verifier/blob/master/bcd-emul.cc#L104
              ' compute dd
              neg mk_optmp0,mk_memvalue
              testb mk_sr,#MK_EXT_BIT wc
        if_c  sub mk_optmp0,#1
              ' compute bc
              mov mk_optmp2,mk_memvalue
              or mk_optmp2,mk_optmp0
              and mk_optmp2,#$88
              ' compute corf
              mov mk_memvalue,mk_optmp2
              sca mk_memvalue,##$4000 ' equivalent to >> 2
              sub mk_memvalue,0-0
              ' compute result
              subr mk_memvalue,mk_optmp0
              ' compute carry
              testbn mk_optmp0,#7 wc
              testb mk_memvalue,#7 andc
              testb mk_optmp2,#7 orc
              muxc mk_sr,#MK_CARRY_MASK|MK_EXT_MASK
              ' compute overflow
              testb mk_optmp0,#7 wc
              testbn mk_memvalue,#7 andc
              bitc mk_sr,#MK_OVER_BIT
              ' compute zero flag
              test mk_memvalue,#255 wz
        if_nz bitl mk_sr,#MK_ZERO_BIT
              ' compute neg flag
              testb mk_memvalue,#7 wc
              bitc mk_sr,#MK_NEG_BIT
              jmp mk_writef



mk_hub_addsubx
              'debug("in mk_hub_addsubx")
              ' isolate register nos
              mov mk_optmp0,mk_opword
              and mk_optmp0,#7 ' source
              mov mk_optmp2,mk_opword
              shr mk_optmp2,#9
              and mk_optmp2,#7 ' destination
              ' check for -(An),-(An) mode
              testb mk_opword,#3 wc
        if_c  jmp #.memmode
              ' read source
              mov pb,mk_opword ' operand is already register
              call #mk_setup_operand_auto
              call mk_readf
              mov mk_optmp1,mk_memvalue
              ' read destination
              mov pb,mk_opword
              getnib pb,mk_opword,#2
              shr pb,#1
              setq #%11_000_000
              muxq pb,mk_opword
              call #mk_setup_operand_auto
              call mk_readf
              testb mk_opword,#14 wc ' C = ADD,NC = SUB ?
        if_nc jmp #.do_sub
              ' fall  through
.do_add
              'debug("in .do_add with ",uhex(mk_memvalue),uhex(mk_optmp1),udec(mk_shiftit))
              testb mk_sr,#MK_EXT_BIT wc
              ' must be rcl for correct ripple carry
              rcl mk_memvalue,mk_shiftit
              rcl mk_optmp1,mk_shiftit
              ' generate stupid overflow flag
              mov mk_optmp0,mk_optmp1
              addsx mk_optmp0,mk_memvalue wc
              testb mk_optmp0,#31 xorc
              bitc mk_sr,#MK_OVER_BIT
              ' do actual add
              testb mk_sr,#MK_EXT_BIT wc
              addx mk_memvalue,mk_optmp1 wcz
              muxc mk_sr,#MK_CARRY_MASK|MK_EXT_MASK
              testb mk_optmp0,#31 wc
              bitc mk_sr,#MK_NEG_BIT
              sar mk_memvalue,mk_shiftit wz
        if_nz bitl mk_sr,#MK_ZERO_BIT
              'debug("got result ",uhex(mk_memvalue))
              jmp mk_writef

.do_sub
              shl mk_memvalue,mk_shiftit
              shl mk_optmp1,mk_shiftit
              ' generate stupid overflow flag
              mov mk_optmp0,mk_memvalue
              testb mk_sr,#MK_EXT_BIT wc
              subsx mk_optmp0,mk_optmp1 wc
              testb mk_optmp0,#31 xorc
              bitc mk_sr,#MK_OVER_BIT
              ' do actual sub
              testb mk_sr,#MK_EXT_BIT wc
              subx mk_memvalue,mk_optmp1 wcz
              muxc mk_sr,#MK_CARRY_MASK|MK_EXT_MASK
              testb mk_optmp0,#31 wc
              bitc mk_sr,#MK_NEG_BIT
              sar mk_memvalue,mk_shiftit wz
        if_nz bitl mk_sr,#MK_ZERO_BIT
              jmp mk_writef

.memmode
              ' read source
              mov pb,mk_opword
              xor pb,#%101_000 ' turn into -(An) (is %001_xxx to begin with)
              call #mk_setup_operand_auto
              call mk_readf
              mov mk_optmp1,mk_memvalue
              ' read destination
              mov pb,mk_opword
              getnib pb,mk_opword,#2
              shr pb,#1
              setq #%11_000_000
              muxq pb,mk_opword
              or pb,#%100_000 ' turn into -(An) (is %001_xxx to begin with)
              call #mk_setup_operand_auto
              testb mk_opword,#14 wc ' C = ADD,NC = SUB ?
        if_c  loc pb,#.do_add
        if_nc loc pb,#.do_sub
              push pb
              jmp mk_readf



mk_hub_negx
              '' NOTE: operand is already set up and shifted
              mov mk_optmp1,mk_memvalue
              mov mk_memvalue,#0
              mov mk_optmp0,#0
              testb mk_sr,#MK_EXT_BIT wc
              subsx mk_optmp0,mk_optmp1 wc
              testb mk_optmp0,#31 xorc
              bitc mk_sr,#MK_OVER_BIT
              ' do actual sub
              testb mk_sr,#MK_EXT_BIT wc
              subx mk_memvalue,mk_optmp1 wcz
              muxc mk_sr,#MK_CARRY_MASK|MK_EXT_MASK
              testb mk_optmp0,#31 wc
              bitc mk_sr,#MK_NEG_BIT
              'debug("negx result ",uhex_long(mk_memvalue),ubin(mk_shiftit))
              sar mk_memvalue,mk_shiftit wz
        if_nz bitl mk_sr,#MK_ZERO_BIT
              jmp mk_writef


mk_hub_cmpm
              ' read destination
              getnib pb,mk_opword,#2
              shr pb,#1
              setq #%11_000_000
              muxq pb,mk_opword
              or pb,#%011_000 ' turn into (An)+
              call #mk_setup_operand_auto
              call mk_readf
              mov mk_optmp1,mk_memvalue
              ' read source
              mov pb,mk_opword
              or pb,#%011_000 ' turn into (An)+
              call #mk_setup_operand_auto
              push #mk_cmp_common
              jmp mk_readf

mk_hub_chk
              call #mk_setup_operand16 ' pb already loaded
              call mk_readf
              call #mk_get_second_reg
              andn mk_sr,#MK_OVER_MASK|MK_CARRY_MASK ' Undocumented flags
              cmps mk_optmp1,#0 wcz
              bitz mk_sr,#MK_ZERO_BIT ' Undocumented flag
              mov pb,#$18
        if_b  bith mk_sr,#MK_NEG_BIT
        if_b  jmp #mk_hub_trapit
              cmps mk_optmp1,mk_memvalue wcz
        if_be ret
              bitl mk_sr,#MK_NEG_BIT
              jmp #mk_hub_trapit
{
mk_hub_cogatn
              rdbyte pb,#atn_command wcz
        if_z  jmp #mk_nextop
        if_c  jmp #mk_hub_hotreset
              jmp #mk_hub_cogatn
}

DAT ' MotoKore 68000 init code


              orgh
mk_init
              cogid pa
              decod pa
              wrword pa,#_mk_cogatn_w
              debug(uhex_long_array(#@curpalette_base_l,#1))

              ' load code
              setq #495
              rdlong 0,##@mk_cogbase
              setq2 #511
              rdlong 0,##@mk_lutbase

              ' wait some more
              waitx ##1000000
              rdword mk_romio_atnval,#_ma_cogatn_w


              {
              ' Compute timing constant for H counter emulation
              ' (note that "pixel" here means hcounter values, which are actually 2 pixels)
              rdlong pa,#_clkf
              qmul pa,##round(6.36e-5/211.0*4294967296.0) ' cy/s * s/px -> cy/px
              getqy pa ' cycles per pixel
              getqx pb ' fractional part
              rolword pa,pb,#1
              qfrac #1,pa
              getqx pa ' our timing reciporal
              wrword pa,#vdp_cyc2hcnt_w
              debug("H counter timing constant: ",udec_word_array(#vdp_cyc2hcnt_w,#1))
              ' Compute timing constant for 6-button state machine reset
              rdlong pa,#_clkf
              qdiv pa,##666 ' 1.5 ms - unfortunate reciporal
              getqx pa
              wrlong pa,#io_6btn_timeout
              ' Reset I/O ports (so it seems like we're cold-booting)
              wrbyte #0,#io_pl1_dir
              wrbyte #0,#io_pl2_dir
              wrbyte #0,#io_pl1_out
              wrbyte #0,#io_pl2_out
               }

              ' allocate all the locks like some sort of maniac
              {
              mov pa,#0
              rep @.lockmadness,#16
              locknew pb wc
        if_nc bith pa,pb
.lockmadness
              ' deallocate all the ones we don't want
              andn pa,##STATIC_LOCKS
              mov pb,#0
              rep @.lockmadness2,#16
              shr pa,#1 wc
        if_c  lockret pb
              add pb,#1
.lockmadness2}

{
              rdbyte mk_romio_zerox,#rom_zerox
              sub mk_romio_zerox,#2 ' we apply it to long-unit addresses
              rdlong mk_sram_begin,#sram_map_start
              rdlong mk_sram_stop,#sram_map_end
              ' Reset ROM/SRAM mapping
              rdbyte mk_memvalue,#sram_bankreg
              call #sram_set_bank
}

              ' setup interrupts
              'setse1 #$10+HINT_LOCK
              'setse2 #$10+VINT_LOCK
              'drvl #38 addpins 1 ' DEBUG LEDs

              rdlong mk_prog_base,#_exr_prog_base
              rdlong mk_port_base,#_exr_port_base
              rdlong mk_bios_base,#_exr_bios_base

              debug("before vector cache ",ubin_word(mk_romio_atnval))

              ' cache vector tables
              loc ptra,#mk_vectorcache_game
              mov mk_romio_length,#64
              mov mk_romio_target,ptra
              mov mk_romio_addr,mk_prog_base
              shr mk_romio_addr,#2
              setq #2
              wrlong mk_romio_addr,#_progrq_addr
              cogatn mk_romio_atnval
              waitatn
              ' preswap to little endian
              rep @.vswaplp1,#64
              rdlong pb,ptra
              movbyts pb,#%%0123
              wrlong pb,ptra++
.vswaplp1

              loc ptra,#mk_vectorcache_bios
              mov mk_romio_length,#32
              mov mk_romio_target,ptra
              mov mk_romio_addr,mk_bios_base
              shr mk_romio_addr,#2
              setq #2
              wrlong mk_romio_addr,#_progrq_addr
              cogatn mk_romio_atnval
              waitatn
              ' preswap to little endian
              rep @.vswaplp2,#32
              rdlong pb,ptra
              movbyts pb,#%%0123
              wrlong pb,ptra++
.vswaplp2
              ' copy latter 32 vectors from game
              loc ptrb,#mk_vectorcache_game+32*4
              rep @.vcplp,#32
              rdlong pb,ptrb++
              wrlong pb,ptra++
.vcplp
              debug("after vector cache ",uhex_long_array(#mk_vectorcache_game,#32))
              debug("after vector cache ",uhex_long_array(#mk_vectorcache_bios,#32))
              debug(uhex_long_array(#@curpalette_base_l,#1))

              ' Download Fix tiles
              mov mk_romio_length,#64
              rdlong mk_romio_addr,#_exr_fixt_base
              shr mk_romio_addr,#2
              mov mk_romio_target,##@fix_tiles
              rep @.fixdlloop,##$2_0000/(64*4)
              setq #2
              wrlong mk_romio_addr,#_progrq_addr
              cogatn mk_romio_atnval
              add mk_romio_addr,#64
              add mk_romio_target,#64*4
              waitatn
.fixdlloop

              ' Download M1
              mov mk_romio_length,#64
              rdlong mk_romio_addr,#_exr_z80p_base
              shr mk_romio_addr,#2
              mov mk_romio_target,##@m1_rom
              rep @.z80dlloop,##$2_0000/(64*4)
              setq #2
              wrlong mk_romio_addr,#_progrq_addr
              cogatn mk_romio_atnval
              add mk_romio_addr,#64
              add mk_romio_target,#64*4
              waitatn
.z80dlloop

              rdword pa,#_zk_cogatn_w
              cogatn pa

              {
              mov mk_effaddr,##$40_1FFE
              call #mk_setup_ea16
              mov mk_memvalue,#$000F
              call mk_writef
              }


mk_hub_hotreset
              mov mk_vectors_ptr,##mk_vectorcache_bios ' BIOS vectors are selected on reset!
              'wrbyte #0,#atn_command
              mov mk_sr,##MK_SUPER_MASK + (7<<8)
              'call #mk_check_core_integrity
              ' initialize PC and SP
              mov mk_virtualpc,#0
              rdlong mk_branchdisplace,##mk_vectorcache_bios+$04
              rdlong mk_a7,##mk_vectorcache_bios+$00
              debug("inital pc and sp ",uhex_long(mk_branchdisplace),uhex_long(mk_a7))
              mov ptra,#0
              neg mk_romque_left,#1
              jmp #mk_dobranch

              {
mk_check_core_integrity
              loc ptrb,#@mk_nibble_impl_tbl
              mov mk_eatmp1,#mk_nibble_impl_tbl
              'debug("Checking core integrity...")
.chklp
              cmp mk_eatmp1,#mk_cogvar_start wcz
        if_z  ret wcz
              rdlong mk_eatmp0,ptrb++
              alti mk_eatmp1,#%000_000_111
              mov pb,0-0
              cmp mk_eatmp0,pb wz
              ' ignore intentionally self-modifying code
        if_z jmp #.chklp
        if_nz cmp mk_eatmp1,#mk_ihook1+1 wz
        if_nz cmp mk_eatmp1,#mk_ihook2+1 wz
        if_nz cmp mk_eatmp1,#mk_thelogicop+1 wz
        if_nz cmp mk_eatmp1,#mk_romque_left+1 wz
        if_nz cmp mk_eatmp1,#mk_rd8_reg+1 wz
        if_nz cmp mk_eatmp1,#mk_wr8_reg+1 wz
        if_nz cmp mk_eatmp1,#mk_rd16_reg+1 wz
        if_nz cmp mk_eatmp1,#mk_wr16_reg+1 wz
        if_nz cmp mk_eatmp1,#mk_rd32_reg+1 wz
        if_nz cmp mk_eatmp1,#mk_wr32_reg+1 wz
        if_nz cmp mk_eatmp1,#mk_longio_tmp+1 wz
        if_nz cmp mk_eatmp1,#mk_addsuba+8+1 wz
        if_nz cmp mk_eatmp1,#mk_psram_read_cmd+1 wz
        if_z jmp #.chklp
              drvh #39
              sub mk_eatmp1,#1
              debug("Core integrity violation @ ",uhex_(mk_eatmp1)," expected ",uhex_long_(mk_eatmp0)," got ",uhex_long_(pb),dly(#1000))
              add mk_eatmp1,#1
              jmp #.chklp   '}


CON ' Memory arbiter constants

#ifdef USE_PSRAM16
MA_CHAR_ASHIFT = 1
MA_CHAR_CYCLES = 4
MA_PCM_ASHIFT = 2
MA_PCM_CYCLES = 8
MA_PROGCYSHL = 1
MA_PAGESIZE = 0 addbits 9
MA_BANKSHIFT = 23
#endif

#ifdef USE_PSRAM8
MA_CHAR_ASHIFT = 2
MA_CHAR_CYCLES = 8
MA_PCM_ASHIFT = 3
MA_PCM_CYCLES = 16
MA_PROGCYSHL = 2
MA_PAGESIZE = 0 addbits 8
MA_BANKSHIFT = 23
#endif

#ifdef USE_PSRAM4
MA_CHAR_ASHIFT = 3
MA_CHAR_CYCLES = 16
MA_PCM_ASHIFT = 4
MA_PCM_CYCLES = 32
MA_PROGCYSHL = 3
MA_PAGESIZE = 0 addbits 7
MA_BANKSHIFT = 23
#endif

#ifdef USE_PSRAM_SLOW
MA_CLKDIV = 3
MA_CYMUL = 1
#else
MA_CLKDIV = 2
MA_CYMUL = 2
#endif

DAT ' Memory arbiter (PSRAM)
#ifdef USE_PSRAM_EITHER
              org 0
ma_entry
              cogid pa
              decod pa
              debug("hmmmstve ",udec(pa))
              wrword pa,#_ma_cogatn_w

              ' load LUT code
              setq2 #511
              rdlong 0,##@ma_lutcode

              rdlong ma_char_base,#_exr_char_base
              shr ma_char_base,#2


              fltl #PSRAM_CLK
#ifdef USE_PSRAM_SLOW
              wrpin ##P_PULSE|P_OE|(PSRAM_SYNC_CLOCK ? P_SYNC_IO : P_ASYNC_IO), #PSRAM_CLK
              wxpin ##3 + (2<<16), #PSRAM_CLK
#else
              wrpin ##P_TRANSITION|P_OE|(PSRAM_SYNC_CLOCK ? P_SYNC_IO : P_ASYNC_IO), #PSRAM_CLK
              wxpin #1, #PSRAM_CLK
              drvl #PSRAM_CLK
#endif

              wrpin ##P_INVERT_OUTPUT,#PSRAM_SELECT addpins (PSRAM_BANKS-1)
              drvl #PSRAM_SELECT addpins (PSRAM_BANKS-1)

              wrpin ##(PSRAM_SYNC_DATA ? P_SYNC_IO : P_ASYNC_IO),ma_psram_pinfield

              setxfrq ma_nco_slow
              waitx #200


              ' wait some more
              waitx ##5000
              rdword ma_mk_cogatn_val,#_mk_cogatn_w


              mov ijmp2,#ma_68krequest
              setint2 #EVENT_ATN


ma_lineloop
.linewait

              add ma_adpcm_pollptr,#4
              cmp ma_adpcm_pollptr,#@adpcm_pollbox+7*4 wz
        if_z  sub ma_adpcm_pollptr,#7*4
              rdlong ma_mtmp1,ma_adpcm_pollptr wz
        if_nz call #ma_do_adpcm
              rdlong ma_mtmp1,#video_line_ctr
              sub ma_mtmp1,#1
              cmp ma_mtmp1,ma_curline wz
        if_e  jmp #.linewait


.doline
              mov ma_curline,ma_mtmp1
              mov ma_slotleft,#96
              loc ptrb,#spr_buffer
              testb ma_curline,#0 wc
        if_c  add ptrb,##96*4*4
              testb ma_curline,#1 wc
        if_c  add ptrb,##96*4*4*2

.slotlp
              rdlong ma_mtmp1,ptrb[2] wc
        if_c  jmp #ma_lineloop ' got sentinel

              shl     ma_mtmp1,#MA_CHAR_ASHIFT ' sprite lines are 2 longs
              add     ma_mtmp1,ma_char_base
#ifndef USE_PSRAM_NOBANKS
              mov ma_mtmp3,ma_mtmp1
              shr ma_mtmp3,#MA_BANKSHIFT
              fle ma_mtmp3,#PSRAM_BANKS-1
#endif
              setbyte ma_mtmp1,#$EB,#3
              splitb  ma_mtmp1
              rev     ma_mtmp1
              movbyts ma_mtmp1, #%%0123
              mergeb  ma_mtmp1
              rep @.irqshield,#1
              drvl  ma_psram_pinfield
#ifdef USE_PSRAM_SLOW
              drvl  #PSRAM_CLK ' must be 2 ops before xinit
#ifdef USE_PSRAM_NOBANKS
              nop
#endif
#endif
#ifndef USE_PSRAM_NOBANKS
              altd  ma_mtmp3,#PSRAM_SELECT
#endif
              drvh  #PSRAM_SELECT
              xinit ma_psram_addr_cmd,ma_mtmp1
              wypin #(8+PSRAM_WAIT+MA_CHAR_CYCLES)*MA_CYMUL,#PSRAM_CLK
              setq ma_nco_fast
              xcont #PSRAM_WAIT*MA_CLKDIV+PSRAM_DELAY,#0
              wrfast ma_bit31,ptrb
              waitxmt
              fltl ma_psram_pinfield
              setq ma_nco_slow
              xcont ma_psram_readspr_cmd,#0
              waitxfi
              drvl #PSRAM_SELECT addpins (PSRAM_BANKS-1)
#ifdef USE_PSRAM_SLOW
              fltl  #PSRAM_CLK
#endif
.irqshield
              add ptrb,#4*4
              djnz ma_slotleft,#.slotlp
              'debug("canary alive. Lorem ipsum dolor sit amet. Take it easy!")
              jmp #ma_lineloop



ma_do_adpcm

              'drvh #38

              shl     ma_mtmp1,#MA_PCM_ASHIFT ' ADPCM cache lines are 4 longs
#ifndef USE_PSRAM_NOBANKS
              mov ma_mtmp3,ma_mtmp1
              shr ma_mtmp3,#MA_BANKSHIFT
              fle ma_mtmp3,#PSRAM_BANKS-1
#endif
              setbyte ma_mtmp1,#$EB,#3
              splitb  ma_mtmp1
              rev     ma_mtmp1
              movbyts ma_mtmp1, #%%0123
              mergeb  ma_mtmp1
              rep @.irqshield,#1
              drvl  ma_psram_pinfield
#ifdef USE_PSRAM_SLOW
              drvl  #PSRAM_CLK ' must be 2 ops before xinit
#ifdef USE_PSRAM_NOBANKS
              nop
#endif
#endif
#ifndef USE_PSRAM_NOBANKS
              altd  ma_mtmp3,#PSRAM_SELECT
#endif
              drvh  #PSRAM_SELECT
              xinit ma_psram_addr_cmd,ma_mtmp1
              wypin #(8+PSRAM_WAIT+MA_PCM_CYCLES)*MA_CYMUL,#PSRAM_CLK
              setq ma_nco_fast
              xcont #PSRAM_WAIT*MA_CLKDIV+PSRAM_DELAY,#0
              waitxmt
              fltl ma_psram_pinfield
              mov ma_mtmp3,ma_adpcm_pollptr
              sub ma_mtmp3,#@adpcm_pollbox
              shl ma_mtmp3,#3 ' 4*8 -> 32 bytes per channel
              testb ma_mtmp1,#(MA_PCM_ASHIFT^28) wc ' odd blocks go in odd buffers (bit 0 of original poll value)
        if_c  add ma_mtmp3,#16
              add ma_mtmp3,ma_adpcm_bufferbase
              wrfast ma_bit31,ma_mtmp3
              setq ma_nco_slow
              xcont ma_psram_readpcm_cmd,#0
              waitxfi
              drvl #PSRAM_SELECT addpins (PSRAM_BANKS-1)
#ifdef USE_PSRAM_SLOW
              fltl  #PSRAM_CLK
#endif
.irqshield
        _ret_ wrlong #0,ma_adpcm_pollptr


ma_68krequest
              setq #2
              rdlong ma_prog_addr,#_progrq_addr
              'debug("Got request ",uhex_long(ma_prog_addr,ma_prog_length,ma_prog_target))

              wrfast ma_bit31,ma_prog_target
              mov ma_itmp2,ma_prog_addr
              add ma_itmp2,ma_prog_length
              mov ma_itmp1,ma_prog_addr
              bith ma_itmp1,#MA_PAGESIZE
              add ma_itmp1,#1 ' ma_itmp1 has start of next page
              cmpsub ma_itmp2,ma_itmp1 wcz ' IF C, ma_itmp2 now has longs that cross over boundary
        if_c  sub ma_prog_length,ma_itmp2
              call #ma_psram_read68k
   if_nc_or_z cogatn ma_mk_cogatn_val
   if_nc_or_z reti2
              mov ma_prog_addr,ma_itmp1
              mov ma_prog_length,ma_itmp2
              call #ma_psram_read68k
              cogatn ma_mk_cogatn_val
              reti2

ma_psram_read68k
              mov ma_itmp0,#(8+PSRAM_WAIT)*MA_CYMUL
              shl ma_prog_length,#MA_PROGCYSHL + (encod MA_CYMUL)
              add ma_itmp0,ma_prog_length
#ifdef USE_PSRAM8
              shl ma_prog_addr,#1
#endif
#ifdef USE_PSRAM4
              shl ma_prog_addr,#2
#endif
#ifndef USE_PSRAM_NOBANKS
              mov ma_itmp3,ma_prog_addr
              shr ma_itmp3,#MA_BANKSHIFT
              fle ma_itmp3,#PSRAM_BANKS-1
#endif
              setbyte ma_prog_addr,#$EB,#3
              ' Reverse nibble order
              splitb  ma_prog_addr
              rev     ma_prog_addr
              movbyts ma_prog_addr, #%%0123
              mergeb  ma_prog_addr
              drvl  ma_psram_pinfield
#ifdef USE_PSRAM_SLOW
              drvl  #PSRAM_CLK ' must be 2 ops before xinit
#ifdef USE_PSRAM_NOBANKS
              nop
#endif
#endif
#ifndef USE_PSRAM_NOBANKS
              altd  ma_itmp3,#PSRAM_SELECT
#endif
              drvh  #PSRAM_SELECT
              xinit ma_psram_addr_cmd,ma_prog_addr
              wypin ma_itmp0,#PSRAM_CLK
              setq ma_nco_fast
              xcont #PSRAM_WAIT*MA_CLKDIV+PSRAM_DELAY,#0
              shr ma_prog_length,#encod MA_CYMUL
              setword ma_psram_read68k_cmd,ma_prog_length,#0
              waitxmt
              fltl ma_psram_pinfield
              setq ma_nco_slow
              xcont ma_psram_read68k_cmd,#0
              waitxfi
#ifdef USE_PSRAM_SLOW
              drvl #PSRAM_SELECT addpins (PSRAM_BANKS-1)
        _ret_ fltl #PSRAM_CLK
#else
        _ret_ drvl #PSRAM_SELECT addpins (PSRAM_BANKS-1)
#endif





ma_bit31      'alias
ma_nco_fast   long $8000_0000
#ifdef USE_PSRAM_SLOW
ma_nco_slow   long $2AAAAAAB
#else
ma_nco_slow   long $4000_0000
#endif

#ifdef USE_PSRAM16
ma_psram_pinfield long PSRAM_BASE addpins 15
ma_psram_addr_cmd long (PSRAM_BASE<<17)|X_PINS_ON | X_IMM_8X4_LUT + 8
ma_psram_read68k_cmd long (PSRAM_BASE<<17)|X_WRITE_ON| X_16P_2DAC8_WFWORD
ma_psram_readspr_cmd long (PSRAM_BASE<<17)|X_WRITE_ON| X_16P_2DAC8_WFWORD + MA_CHAR_CYCLES
ma_psram_readpcm_cmd long (PSRAM_BASE<<17)|X_WRITE_ON| X_16P_2DAC8_WFWORD + MA_PCM_CYCLES
#endif

#ifdef USE_PSRAM8
ma_psram_pinfield long PSRAM_BASE addpins 7
ma_psram_addr_cmd long (PSRAM_BASE<<17)|X_PINS_ON | X_IMM_8X4_LUT + 8
ma_psram_read68k_cmd long (PSRAM_BASE<<17)|X_WRITE_ON| X_8P_1DAC8_WFBYTE
ma_psram_readspr_cmd long (PSRAM_BASE<<17)|X_WRITE_ON| X_8P_1DAC8_WFBYTE + MA_CHAR_CYCLES
ma_psram_readpcm_cmd long (PSRAM_BASE<<17)|X_WRITE_ON| X_8P_1DAC8_WFBYTE + MA_PCM_CYCLES
#endif

#ifdef USE_PSRAM4
ma_psram_pinfield long PSRAM_BASE addpins 3
ma_psram_addr_cmd long (PSRAM_BASE<<17)|X_PINS_ON | X_IMM_8X4_4DAC1 + 8
ma_psram_read68k_cmd long (PSRAM_BASE<<17)|X_WRITE_ON| X_4P_4DAC1_WFBYTE
ma_psram_readspr_cmd long (PSRAM_BASE<<17)|X_WRITE_ON| X_4P_4DAC1_WFBYTE + MA_CHAR_CYCLES
ma_psram_readpcm_cmd long (PSRAM_BASE<<17)|X_WRITE_ON| X_4P_4DAC1_WFBYTE + MA_PCM_CYCLES
#endif

ma_adpcm_pollptr long @adpcm_pollbox
ma_adpcm_bufferbase long @adpcm_buffers

ma_prog_addr   res 1
ma_prog_length res 1
ma_prog_target res 1

ma_slotleft res 1
ma_char_base res 1

ma_itmp0      res 1
ma_itmp1      res 1
ma_itmp2      res 1
ma_itmp3      res 1

ma_mtmp0      res 1
ma_mtmp1      res 1
ma_mtmp2      res 1
ma_mtmp3      res 1

ma_curline    res 1

ma_mk_cogatn_val res 1


              fit 496
              org 512
ma_lutcode
#ifdef USE_PSRAM16
              long $0000
              long $1111
              long $2222
              long $3333
              long $4444
              long $5555
              long $6666
              long $7777
              long $8888
              long $9999
              long $AAAA
              long $BBBB
              long $CCCC
              long $DDDD
              long $EEEE
              long $FFFF
#elseifdef USE_PSRAM8
              long $00
              long $11
              long $22
              long $33
              long $44
              long $55
              long $66
              long $77
              long $88
              long $99
              long $AA
              long $BB
              long $CC
              long $DD
              long $EE
              long $FF
#endif

              fit 1024

#endif

DAT ' I/O glue
              orgh

iog_z80port_wr16
              getbyte mk_memvalue,mk_memvalue,#1
iog_z80port_wr8
              debug("Z80 command: ",uhex_byte(mk_memvalue),uhex_long(mk_virtualpc))
              testb mk_eacache,#0 wc
        if_nc rdword pa,#_zk_cogatn_w
        if_nc wrbyte mk_memvalue,#z80_command_b
        if_nc cogatn pa
              ret wcz

iog_status_a_rd16
              rdbyte mk_memvalue,#z80_reply_b
              rolbyte mk_memvalue,#$1F,#0 ' Does a real AES _have_ a STATUS_A, anyways?
              ret wcz

iog_status_b_rd16
              mov mk_memvalue,#%0011
              rdbyte pa,#io_pl2_padw+1
              rczr pa wcz
              modcz _nc,_nz wcz
              rczl mk_memvalue
              rdbyte pa,#io_pl1_padw+1
              rczr pa wcz
              modcz _nc,_nz wcz
              rczl mk_memvalue
              rolbyte mk_memvalue,#0,#0
              ret wcz

iog_p1stuff_rd16
              rdbyte mk_memvalue,#io_pl1_padw
              xor mk_memvalue,#$FF
              rolbyte mk_memvalue,#0,#0 ' DIPSW or SYSTYPE (again, does AES have these?)
              ret wcz

iog_p2stuff_rd16
              rdbyte mk_memvalue,#io_pl2_padw
              xor mk_memvalue,#$FF
              rolbyte mk_memvalue,#0,#0 ' ????
              ret wcz

iog_latch_wr8
              testb mk_eacache,#0 wc
        if_nc ret wcz
iog_latch_wr16
              testb mk_eacache,#4 wc
              getnib pa,mk_eacache,#0
              shr pa,#1
              cmp pa,#1 wz
        if_01 loc pa,#mk_vectorcache_bios
        if_11 loc pa,#mk_vectorcache_game
        if_x1 mov mk_vectors_ptr,pa
              cmp pa,#7 wz
        if_01 loc pa,#palette32 + 256*16*4
        if_11 loc pa,#palette32 + 0
        if_x1 wrlong pa,#curpalette_base_l
              ret wcz


iog_lspc_wr8
              testb mk_eacache,#0 wc
        if_c  ret wcz
              movbyts mk_memvalue,#%%2200
iog_lspc_wr16
              getnib pa,mk_eacache,#0
              mul pa,#4 ' pa is even to begin with, so interval is 8
              jmprel pa
.lspcwr_base
              orgh .lspcwr_base + 0*8*4 ' Set VRAM address
              getword mk_vram_curr,mk_memvalue,#0
              shl mk_vram_curr,#1
              ret wcz
              orgh .lspcwr_base + 1*8*4 ' Write VRAM
              testb mk_vram_curr,#16 wc
        if_c  jmp #.highvram
              loc pa,#vram_low
              add pa,mk_vram_curr
              wrword mk_memvalue,pa
              add mk_vram_curr,mk_vram_modulo
              setword mk_vram_curr,#0,#1
              ret wcz
              orgh .lspcwr_base + 2*8*4 ' Set modulo
              mov mk_vram_modulo,mk_memvalue
              shl mk_vram_modulo,#1
              ret wcz
              orgh .lspcwr_base + 3*8*4 ' Set LSPC mode
              wrword mk_memvalue,#_lspc_modereg
              ret wcz
              orgh .lspcwr_base + 4*8*4 ' Set timer high word
              ret wcz
              orgh .lspcwr_base + 5*8*4 ' Set timer low word
              ret wcz
              orgh .lspcwr_base + 6*8*4 ' IRQ acknowledge
              testb mk_memvalue,#2 wc
        if_c  setse1 #%000_10_0000 + VINT_LOCK
              testb mk_memvalue,#1 wc
        if_c  setse2 #4 ' TODO: Timer IRQ event
              ret wcz
              orgh .lspcwr_base + 7*8*4 ' PAL-only stuff
              ret wcz
.highvram
              loc pa,#vram_high
              mov mk_memtmp0,mk_vram_curr
              shl mk_memtmp0,#2
              testb mk_vram_curr,#11 wc
              testb mk_vram_curr,#10 wz
              bitc mk_memtmp0,#2
              bitz mk_memtmp0,#1
              zerox mk_memtmp0,#11
              add pa,mk_memtmp0
              wrword mk_memvalue,pa
              add mk_vram_curr,mk_vram_modulo
              setword mk_vram_curr,#1,#1
              ret wcz


iog_lspc_rd16
              getnib pa,mk_eacache,#0
              and pa,#6
              cmpsub pa,#2
              mul pa,#4 ' pa is even to begin with, so interval is 8
              jmprel pa
.lspcrd_base
              orgh .lspcrd_base + 0*8*4 ' Read VRAM
              testb mk_vram_curr,#16 wc
        if_c  jmp #.highvram
              loc pa,#vram_low
              add pa,mk_vram_curr
              rdword mk_memvalue,pa
              ret wcz
              orgh .lspcrd_base + 1*8*4 ' Read modulo
              mov mk_memvalue,mk_vram_modulo
              shr mk_memvalue,#1
              ret wcz
              orgh .lspcrd_base + 2*8*4 ' Read LSPC status
              rdbyte mk_memvalue,#_lspc_animctr
              rdlong mk_memtmp0,#video_line_ctr
              add mk_memtmp0,#$100
              shl mk_memtmp0,#7
              setword mk_memtmp0,#0,#1
              or mk_memvalue,mk_memtmp0
              ret wcz
.highvram
              loc pa,#vram_high
              mov mk_memtmp0,mk_vram_curr
              shl mk_memtmp0,#2
              testb mk_vram_curr,#11 wc
              testb mk_vram_curr,#10 wz
              bitc mk_memtmp0,#2
              bitz mk_memtmp0,#1
              zerox mk_memtmp0,#11
              add pa,mk_memtmp0
              rdword mk_memvalue,pa
              ret wcz





DAT ' Palette I/O
              orgh
pal32_wr8
              mov mk_memtmp0,mk_effaddr
              bitl mk_memtmp0,#0 wcz
        if_c  movbyts mk_memvalue,#%%2200
        if_nc movbyts mk_memvalue,#%%3311
              jmp #pal32_wr16_inner

pal32_wr32
              mov mk_longio_tmp,mk_memvalue
              mov mk_memtmp0,mk_effaddr
              add mk_memtmp0,#2
              call #pal32_wr16_inner
              getword mk_memvalue,mk_longio_tmp,#1
              ' Fall through
pal32_wr16
              mov mk_memtmp0,mk_effaddr
pal32_wr16_inner
              'debug("in pal32_wr16_inner with ",uhex_long(mk_memtmp0),uhex_long_array(#@curpalette_base_l,#1))
              shl mk_memtmp0,#1
              zerox mk_memtmp0,#13
              rdlong pa,#curpalette_base_l
              add mk_memtmp0,pa
              ' Convert %DRGB_RRR_GGG_BBB to truecolor (with black = $01 so we can use WMLONG for blitting)
              mov mk_memtmp2,#1
              testb mk_memvalue,#15 wc
              bitnc mk_memtmp2,#2
              movbyts mk_memtmp2,#%%0000
              setnib mk_memtmp2,mk_memvalue,#3
              shr mk_memvalue,#4
              setnib mk_memtmp2,mk_memvalue,#5
              shr mk_memvalue,#4
              setnib mk_memtmp2,mk_memvalue,#7
              shr mk_memvalue,#5 wc ' gets B0 bit
              bitc mk_memtmp2,#11
              rczr mk_memvalue wcz ' gets R0/G0
              bitz mk_memtmp2,#19
              bitc mk_memtmp2,#27

              wrlong mk_memtmp2,mk_memtmp0
              ret wcz

pal32_rd8
              mov mk_memtmp0,mk_effaddr
              bitl mk_memtmp0,#0 wcz
              call #pal32_rd16_inner
        if_c  getbyte mk_memvalue,mk_memvalue,#0
        if_nc getbyte mk_memvalue,mk_memvalue,#1
              ret wcz

pal32_rd32
              'mov mk_memvalue,#0
              mov mk_memtmp0,mk_effaddr
              shl mk_memtmp0,#1
              call #pal32_rd16_inner
              mov mk_memtmp0,mk_effaddr
              shl mk_memtmp0,#1
              add mk_memtmp0,#4
              jmp #pal32_rd16_inner

pal32_rd16
              mov mk_memvalue,#0
              mov mk_memtmp0,mk_effaddr
              shl mk_memtmp0,#1
pal32_rd16_inner
              zerox mk_memtmp0,#13
              rdlong pa,#curpalette_base_l
              add mk_memtmp0,pa
              rdlong mk_memtmp0,mk_memtmp0
              ' Undo truecolor conversion
              testbn mk_memtmp0,#18 wc ' dark bit (from green channel)
              testb mk_memtmp0,#27 wz ' R0
              rczl mk_memvalue
              testb mk_memtmp0,#19 wc ' G0
              testb mk_memtmp0,#11 wz ' B0
              rczl mk_memvalue
              rolnib mk_memvalue,mk_memtmp0,#7
              rolnib mk_memvalue,mk_memtmp0,#5
              rolnib mk_memvalue,mk_memtmp0,#3

              ret wcz



DAT ' LSPC cog
              org
lspc_entry
              'drvl #38 ' DEBUG LED
              {
              '' Generate vertial shrink table
              mov ptra,lspc_shrinkptr
              mov lspc_vshrink,#0
.outer
              mov lspc_tmp1,#0
.inner
              mov lspc_tmp2,lspc_tmp1
              xor lspc_tmp2,#$88
              rev lspc_tmp2
              shr lspc_tmp2,#32-8
              cmp lspc_tmp2,lspc_vshrink wcz
        if_be wrbyte lspc_tmp1,ptra++
              incmod lspc_tmp1,#255 wc
        if_nc jmp #.inner
              incmod lspc_vshrink,#255 wc
        if_nc jmp #.outer
              }

              debug(uhex_byte_array(lspc_shrinkptr,#256))

              'mov lspc_scb3ptr,lspc_vramptr
              'add lspc_scb3ptr,##$8000*2

              'mov lspc_scb1magic,lspc_vramptr
              'add lspc_scb1magic,##381<<7



lspc_linelp
.linewait
              rdlong lspc_tmp1,#video_line_ctr
              'add lspc_tmp1,#3 + 2 ' we're two lines behind the curve
              cmp lspc_tmp1,lspc_curline wz
        if_e  jmp #.linewait
              mov lspc_curline,lspc_tmp1

              rdlong lspc_tile_bits,#_ext_char_bits
              rdword lspc_lspcmode,#_lspc_modereg
              testbn lspc_lspcmode,#3 wc
              bitc lspc_auto4msk,#0 addbits 1
              bitc lspc_auto8msk,#0 addbits 2

              '' Generate sprite data for next line
              '' ==================================================

              mov lspc_slotleft,#96
              mov lspc_sprleft,#381
              mov lspc_chkline,lspc_curline
              ' Prepare writing to sprite buffer
              mov ptra,lspc_sprbufptr
              testb lspc_chkline,#0 wc
        if_c  add ptra,##96*4*4
              testb lspc_chkline,#1 wc
        if_c  add ptra,##96*4*4*2

              cmp lspc_chkline,##-1 wz
        if_z  sub lspc_autotimer,#1 wc
        if_11 getbyte lspc_autotimer,lspc_lspcmode,#1
        if_11 incmod lspc_autoframe,#7
        if_11 wrbyte lspc_autoframe,#_lspc_animctr

              cmp lspc_chkline,#224 wz
        if_z  locktry #VINT_LOCK wc
        if_z  lockrel #VINT_LOCK
        'if_11 drvnot #38

              cmp lspc_chkline,#224 wc
        if_ae jmp #.scan_done ' just fill sentinels if outside of active area

              ' format chkline for fast compares
              subr lspc_chkline,##-16
              shl lspc_chkline,#23

              ' Start iterating reordered high VRAM
              rdfast #0,lspc_vramhiptr
              modc _clr wc
.scanlp
              rflong lspc_tmp1 ' SCB2 in low word, SCB3 in high word
              rflong lspc_tmp4 ' SCB4 in low word, garbo in high word
              testb lspc_tmp1,#6+16 wz ' sticky bit
        if_nz getword lspc_tmp2,lspc_tmp1,#1
        if_nz shl lspc_tmp2,#27 wc ' left justify height. top bit (set->always visible) shifts into C
              sub lspc_tmp1,lspc_chkline
 if_nc_and_nz cmp lspc_tmp1,lspc_tmp2 wc
        if_nc djnz lspc_sprleft,#.scanlp ' 9 op per sprite
        if_nc jmp #.scan_done

              '' Got one! Reel it in, reel it in!
              getword lspc_spry,lspc_tmp1,#1
              shr lspc_spry,#7
              add lspc_tmp1,lspc_chkline ' Undo sub from before to get back SCB2/SCB3
        if_nz getbyte lspc_vshrink,lspc_tmp1,#0
              getnib lspc_hshrink,lspc_tmp1,#2
        if_nz getword lspc_sprx,lspc_tmp4,#0
        if_nz shr lspc_sprx,#7
        if_nz add lspc_sprx,#15
              and lspc_sprx,#511
              ' Vertical computation
              mov lspc_tmp3,lspc_vshrink
              add lspc_tmp3,#1 ' just vshrink + 1

        if_z  jmp #.sticky ' skip over this part if sticky (flag contention / don't have previous SCB3 anymore)
              testb lspc_spry,#8 wz
        if_z xor lspc_spry,#511
              testbn lspc_tmp1,#16 wc
              testbn lspc_tmp1,#21 orc
        if_nc cmp lspc_spry,lspc_tmp3 wc ' Height 33 special case
        if_nc subr lspc_spry,lspc_tmp3
        if_nc add  lspc_spry,lspc_vshrink
        if_nc modz _nz wz
              and lspc_spry,#255
              cmp lspc_spry,lspc_tmp3 wc
              mul lspc_tmp3,lspc_vshrink
              shr lspc_tmp3,#1
              add lspc_tmp3,lspc_spry
              add lspc_tmp3,lspc_shrinkptr
              ' 26 op here
        if_b  rdbyte lspc_yidx,lspc_tmp3
        if_ae mov lspc_yidx,#$FF
              'mov lspc_yidx,lspc_tmp2 ' DEBUG
        if_z xor lspc_yidx,#511
.sticky       ' 36 op here (non-sticky)
              mov lspc_tmp3,lspc_yidx
              shr lspc_tmp3,#4
              shl lspc_tmp3,#2

              neg lspc_tmp4,lspc_sprleft
              shl lspc_tmp4,#7
              add lspc_tmp4,lspc_tmp3
              add lspc_tmp4,lspc_scb1magic
              ' 43 op here
              rdlong lspc_cromaddr,lspc_tmp4 ' SCB1 data

              getword lspc_attribs,lspc_cromaddr,#1
              getnib lspc_tmp1,lspc_cromaddr,#5 ' get tile ID MSBs
              setword lspc_cromaddr,lspc_tmp1,#1
              zerox lspc_cromaddr,lspc_tile_bits
              testb lspc_attribs,#2 wc' auto4
              testb lspc_attribs,#3 wz' auto8
        if_c  setq lspc_auto4msk
        if_z  setq lspc_auto8msk
        if_not_00 muxq lspc_cromaddr,lspc_autoframe
              rolnib lspc_cromaddr,lspc_yidx,#0
              testb lspc_attribs,#1 wc ' vflip
        if_c  xor lspc_cromaddr,#15

              setword lspc_attribs,lspc_sprx,#1
              setnib lspc_attribs,lspc_hshrink,#1
              setq #3
              ' 65 op here
              wrlong lspc_zero1,ptra++
.nextspr
              add lspc_slotleft,lspc_minus1 wcz ' set Z if last slot was used. Always set C (for addx and sticky check)
              addx lspc_sprx,lspc_hshrink ' Adjust X for potential sticky sprite
        if_nz djnz lspc_sprleft,#.scanlp
              ' 73 op total
.scan_done
              ' Fill remaining slots with sentinel values
              tjz lspc_slotleft, #lspc_linelp
              neg lspc_cromaddr,#1
              neg lspc_attribs,#1
              rep #2,lspc_slotleft
              setq #3
              wrlong lspc_zero1,ptra++

              jmp #lspc_linelp

lspc_minus1  long -1

lspc_vramptr   long @vram_low
lspc_vramhiptr long @vram_high
lspc_shrinkptr long @vshrink_lookup
lspc_sprbufptr long @spr_buffer
lspc_scb1magic long @vram_low + (381<<7)

lspc_curline  long -1
lspc_autoframe long 0
lspc_autotimer long 0
lspc_auto4msk long %11
lspc_auto8msk long %111

lspc_zero1    long $1111_1111*2
lspc_zero2    long $1111_1111
lspc_cromaddr long 0
lspc_attribs  long 0

'lspc_scb3ptr res 1

lspc_tmp1     res 1
lspc_tmp2     res 1
lspc_tmp3     res 1
lspc_tmp4     res 1

lspc_spry     res 1
lspc_yidx     res 1
lspc_sprx     res 1
lspc_vshrink  res 1
lspc_hshrink  res 1
lspc_slotleft res 1
lspc_sprleft  res 1

lspc_chkline  res 1
lspc_lspcmode res 1
lspc_tile_bits res 1


DAT ' Blitter cog
              org
blt_entry
              wrlut #0,#0
blt_linelp
.linewait
              rdlong blt_tmp1,blt_linecnt
              sub blt_tmp1,#2
              cmp blt_tmp1,blt_curline wz
        if_e  jmp #.linewait
              mov blt_curline,blt_tmp1
              'debug(udec(blt_curline))

              rdlong blt_colorptr,#curpalette_base_l
              add blt_colorptr,#4

              mov blt_renderptr,blt_renderbase
              testb blt_curline,#0 wc
        if_c add blt_renderptr,##(320+16)*4 '##DRAWBUFFER_WIDTH*4
              mov blt_renderptr_spr,blt_renderptr
              sub blt_renderptr_spr,#15*4

              mov blt_sromline,blt_curline
              and blt_sromline,#7
              mul blt_sromline,#4
              add blt_sromline,blt_sromptr

              ' fill bg color
              mov blt_tmp1,blt_colorptr
              add blt_tmp1,##(256*16-2)*4
              rdlong blt_tmp1,blt_tmp1
              setd .thewr,blt_tmp1
              ror blt_tmp1,#9
              setq blt_augd_mask
              muxq .theaug,blt_tmp1
              nop
              setq #320-1
.theaug       augd #0-0
.thewr        wrlong #0-0,blt_renderptr

              '' Render sprites
              mov blt_slotleft,#96
              mov blt_tmp1,blt_sprbufptr
              testb blt_curline,#0 wc
        if_c  add blt_tmp1,##96*4*4
              testb blt_curline,#1 wc
        if_c  add blt_tmp1,##96*4*4*2
              rdfast #0,blt_tmp1

              jmp #blt_sprloop

blt_shrink_f
              rdlut blt_buffer+0,blt_nibs+0
              rdlut blt_buffer+1,blt_nibs+1
              rdlut blt_buffer+2,blt_nibs+2
              rdlut blt_buffer+3,blt_nibs+3
              rdlut blt_buffer+4,blt_nibs+4
              rdlut blt_buffer+5,blt_nibs+5
              rdlut blt_buffer+6,blt_nibs+6
              rdlut blt_buffer+7,blt_nibs+7
              rdlut blt_buffer+8,blt_nibs+8
              rdlut blt_buffer+9,blt_nibs+9
              rdlut blt_buffer+10,blt_nibs+10
              rdlut blt_buffer+11,blt_nibs+11
              rdlut blt_buffer+12,blt_nibs+12
              rdlut blt_buffer+13,blt_nibs+13
              rdlut blt_buffer+14,blt_nibs+14
              rdlut blt_buffer+15,blt_nibs+15
              setq #15
              wmlong blt_buffer,ptra
blt_sprloop
              djf blt_slotleft,#blt_sprdone
              rflong blt_tpix+0
              rflong blt_tpix+1
              rflong blt_tmp1 wc
        'if_c jmp #blt_sprdone
              rfbyte blt_attr
              rfbyte blt_palette
              rfword ptra

              cmp ptra,#15+320 wc
              getnib blt_tmp1,blt_attr,#1
        if_b  altd blt_tmp1,#blt_shrinktab
              push blt_nodraw

              shl ptra,#2
              add ptra,blt_renderptr_spr

              shl blt_palette,#4+2
              add blt_palette,blt_colorptr
              setq2 #14
              rdlong 1,blt_palette


              'mov blt_tpix+1,##$12345678

              testb blt_attr,#0 wc ' mirror bit
        if_c  jmp #.mirror
              getnib blt_nibs+0,blt_tpix+0,#0
              getnib blt_nibs+1,blt_tpix+0,#1
              getnib blt_nibs+2,blt_tpix+0,#2
              getnib blt_nibs+3,blt_tpix+0,#3
              getnib blt_nibs+4,blt_tpix+0,#4
              getnib blt_nibs+5,blt_tpix+0,#5
              getnib blt_nibs+6,blt_tpix+0,#6
              getnib blt_nibs+7,blt_tpix+0,#7
              getnib blt_nibs+8,blt_tpix+1,#0
              getnib blt_nibs+9,blt_tpix+1,#1
              getnib blt_nibs+10,blt_tpix+1,#2
              getnib blt_nibs+11,blt_tpix+1,#3
              getnib blt_nibs+12,blt_tpix+1,#4
              getnib blt_nibs+13,blt_tpix+1,#5
              getnib blt_nibs+14,blt_tpix+1,#6
        _ret_ getnib blt_nibs+15,blt_tpix+1,#7
.mirror
              getnib blt_nibs+15,blt_tpix+0,#0
              getnib blt_nibs+14,blt_tpix+0,#1
              getnib blt_nibs+13,blt_tpix+0,#2
              getnib blt_nibs+12,blt_tpix+0,#3
              getnib blt_nibs+11,blt_tpix+0,#4
              getnib blt_nibs+10,blt_tpix+0,#5
              getnib blt_nibs+9,blt_tpix+0,#6
              getnib blt_nibs+8,blt_tpix+0,#7
              getnib blt_nibs+7,blt_tpix+1,#0
              getnib blt_nibs+6,blt_tpix+1,#1
              getnib blt_nibs+5,blt_tpix+1,#2
              getnib blt_nibs+4,blt_tpix+1,#3
              getnib blt_nibs+3,blt_tpix+1,#4
              getnib blt_nibs+2,blt_tpix+1,#5
              getnib blt_nibs+1,blt_tpix+1,#6
        _ret_ getnib blt_nibs+0,blt_tpix+1,#7


blt_sprdone
              '' Render Fix layer
              '' =================
              mov ptra,blt_renderptr

              mov ptrb,blt_vramptr
              add ptrb,##$E000
              mov blt_tmp1,blt_curline
              shr blt_tmp1,#3
              add blt_tmp1,#2
              shl blt_tmp1,#1
              add ptrb,blt_tmp1

              rep @.fix_loop,#10

              '' Note: the peculiar instruction order in this loop is to reduce hub latency

              rdlong blt_tile+0,ptrb++[16] ' Use RDLONG so the delta fits (1 cyc penalty sometimes, doesn't matter due to alignment)
              getnib blt_pal+0,blt_tile+0,#3
              shl blt_pal+0,#4+2
              add blt_pal+0,blt_colorptr

              rdlong blt_tile+1,ptrb++[16]
              getnib blt_pal+1,blt_tile+1,#3
              shl blt_pal+1,#4+2
              add blt_pal+1,blt_colorptr

              rdlong blt_tile+2,ptrb++[16]
              getnib blt_pal+2,blt_tile+2,#3
              shl blt_pal+2,#4+2
              add blt_pal+2,blt_colorptr

              rdlong blt_tile+3,ptrb++[16]
              getnib blt_pal+3,blt_tile+3,#3

              zerox blt_tile+0,#11
              shl blt_tile+0,#5
              add blt_tile+0,blt_sromline
              rdlong blt_tpix+0,blt_tile+0

              zerox blt_tile+1,#11
              shl blt_tile+1,#5
              add blt_tile+1,blt_sromline
              rdlong blt_tpix+1,blt_tile+1

              zerox blt_tile+2,#11
              shl blt_tile+2,#5
              add blt_tile+2,blt_sromline
              rdlong blt_tpix+2,blt_tile+2

              zerox blt_tile+3,#11
              shl blt_tile+3,#5
              add blt_tile+3,blt_sromline
              rdlong blt_tpix+3,blt_tile+3


              getnib blt_tmp1,blt_tpix+0,#0

              setq2 #14
              rdlong 1,blt_pal+0

              rdlut blt_buffer+0,blt_tmp1
              getnib blt_tmp1,blt_tpix+0,#1
              rdlut blt_buffer+1,blt_tmp1
              getnib blt_tmp1,blt_tpix+0,#2
              rdlut blt_buffer+2,blt_tmp1
              getnib blt_tmp1,blt_tpix+0,#3
              rdlut blt_buffer+3,blt_tmp1
              getnib blt_tmp1,blt_tpix+0,#4
              rdlut blt_buffer+4,blt_tmp1
              getnib blt_tmp1,blt_tpix+0,#5
              rdlut blt_buffer+5,blt_tmp1
              getnib blt_tmp1,blt_tpix+0,#6
              rdlut blt_buffer+6,blt_tmp1
              getnib blt_tmp1,blt_tpix+0,#7
              rdlut blt_buffer+7,blt_tmp1

              setq2 #14
              rdlong 1,blt_pal+1

              shl blt_pal+3,#4+2
              add blt_pal+3,blt_colorptr

              getnib blt_tmp1,blt_tpix+1,#0
              rdlut blt_buffer+8,blt_tmp1
              getnib blt_tmp1,blt_tpix+1,#1
              rdlut blt_buffer+9,blt_tmp1
              getnib blt_tmp1,blt_tpix+1,#2
              rdlut blt_buffer+10,blt_tmp1
              getnib blt_tmp1,blt_tpix+1,#3
              rdlut blt_buffer+11,blt_tmp1
              getnib blt_tmp1,blt_tpix+1,#4
              rdlut blt_buffer+12,blt_tmp1
              getnib blt_tmp1,blt_tpix+1,#5
              rdlut blt_buffer+13,blt_tmp1
              getnib blt_tmp1,blt_tpix+1,#6
              rdlut blt_buffer+14,blt_tmp1
              getnib blt_tmp1,blt_tpix+1,#7
              rdlut blt_buffer+15,blt_tmp1

              getnib blt_tmp1,blt_tpix+2,#0

              setq2 #14
              rdlong 1,blt_pal+2

              rdlut blt_buffer+16,blt_tmp1
              getnib blt_tmp1,blt_tpix+2,#1
              rdlut blt_buffer+17,blt_tmp1
              getnib blt_tmp1,blt_tpix+2,#2
              rdlut blt_buffer+18,blt_tmp1
              getnib blt_tmp1,blt_tpix+2,#3
              rdlut blt_buffer+19,blt_tmp1
              getnib blt_tmp1,blt_tpix+2,#4
              rdlut blt_buffer+20,blt_tmp1
              getnib blt_tmp1,blt_tpix+2,#5
              rdlut blt_buffer+21,blt_tmp1
              getnib blt_tmp1,blt_tpix+2,#6
              rdlut blt_buffer+22,blt_tmp1
              getnib blt_tmp1,blt_tpix+2,#7
              rdlut blt_buffer+23,blt_tmp1

              setq2 #14
              rdlong 1,blt_pal+3

              getnib blt_tmp1,blt_tpix+3,#0
              rdlut blt_buffer+24,blt_tmp1
              getnib blt_tmp1,blt_tpix+3,#1
              rdlut blt_buffer+25,blt_tmp1
              getnib blt_tmp1,blt_tpix+3,#2
              rdlut blt_buffer+26,blt_tmp1
              getnib blt_tmp1,blt_tpix+3,#3
              rdlut blt_buffer+27,blt_tmp1
              getnib blt_tmp1,blt_tpix+3,#4
              rdlut blt_buffer+28,blt_tmp1
              getnib blt_tmp1,blt_tpix+3,#5
              rdlut blt_buffer+29,blt_tmp1
              getnib blt_tmp1,blt_tpix+3,#6
              rdlut blt_buffer+30,blt_tmp1
              getnib blt_tmp1,blt_tpix+3,#7
              rdlut blt_buffer+31,blt_tmp1

              setq #31
              wmlong blt_buffer,ptra++
.fix_loop
              jmp #blt_linelp

blt_nodraw    long blt_sprloop
blt_shrinktab
              long blt_shrink_0
              long blt_shrink_1
              long blt_shrink_2
              long blt_shrink_3
              long blt_shrink_4
              long blt_shrink_5
              long blt_shrink_6
              long blt_shrink_7
              long blt_shrink_8
              long blt_shrink_9
              long blt_shrink_a
              long blt_shrink_b
              long blt_shrink_c
              long blt_shrink_d
              long blt_shrink_e
              long blt_shrink_f

blt_shrink_0
              rdlut blt_buffer+0,blt_nibs+8
              wmlong blt_buffer,ptra
              jmp #blt_sprloop
blt_shrink_1
              rdlut blt_buffer+0,blt_nibs+4
              rdlut blt_buffer+1,blt_nibs+8
              setq #1
              wmlong blt_buffer,ptra
              jmp #blt_sprloop
blt_shrink_2
              rdlut blt_buffer+0,blt_nibs+4
              rdlut blt_buffer+1,blt_nibs+8
              rdlut blt_buffer+2,blt_nibs+12
              setq #2
              wmlong blt_buffer,ptra
              jmp #blt_sprloop
blt_shrink_3
              rdlut blt_buffer+0,blt_nibs+2
              rdlut blt_buffer+1,blt_nibs+4
              rdlut blt_buffer+2,blt_nibs+8
              rdlut blt_buffer+3,blt_nibs+12
              setq #3
              wmlong blt_buffer,ptra
              jmp #blt_sprloop
blt_shrink_4
              rdlut blt_buffer+0,blt_nibs+2
              rdlut blt_buffer+1,blt_nibs+4
              rdlut blt_buffer+2,blt_nibs+8
              rdlut blt_buffer+3,blt_nibs+12
              rdlut blt_buffer+4,blt_nibs+14
              setq #4
              wmlong blt_buffer,ptra
              jmp #blt_sprloop
blt_shrink_5
              rdlut blt_buffer+0,blt_nibs+2
              rdlut blt_buffer+1,blt_nibs+4
              rdlut blt_buffer+2,blt_nibs+6
              rdlut blt_buffer+3,blt_nibs+8
              rdlut blt_buffer+4,blt_nibs+12
              rdlut blt_buffer+5,blt_nibs+14
              setq #5
              wmlong blt_buffer,ptra
              jmp #blt_sprloop
blt_shrink_6
              rdlut blt_buffer+0,blt_nibs+2
              rdlut blt_buffer+1,blt_nibs+4
              rdlut blt_buffer+2,blt_nibs+6
              rdlut blt_buffer+3,blt_nibs+8
              rdlut blt_buffer+4,blt_nibs+10
              rdlut blt_buffer+5,blt_nibs+12
              rdlut blt_buffer+6,blt_nibs+14
              setq #6
              wmlong blt_buffer,ptra
              jmp #blt_sprloop
blt_shrink_7
              rdlut blt_buffer+0,blt_nibs+0
              rdlut blt_buffer+1,blt_nibs+2
              rdlut blt_buffer+2,blt_nibs+4
              rdlut blt_buffer+3,blt_nibs+6
              rdlut blt_buffer+4,blt_nibs+8
              rdlut blt_buffer+5,blt_nibs+10
              rdlut blt_buffer+6,blt_nibs+12
              rdlut blt_buffer+7,blt_nibs+14
              setq #7
              wmlong blt_buffer,ptra
              jmp #blt_sprloop
blt_shrink_8
              rdlut blt_buffer+0,blt_nibs+0
              rdlut blt_buffer+1,blt_nibs+2
              rdlut blt_buffer+2,blt_nibs+4
              rdlut blt_buffer+3,blt_nibs+6
              rdlut blt_buffer+4,blt_nibs+8
              rdlut blt_buffer+5,blt_nibs+9
              rdlut blt_buffer+6,blt_nibs+10
              rdlut blt_buffer+7,blt_nibs+12
              rdlut blt_buffer+8,blt_nibs+14
              setq #8
              wmlong blt_buffer,ptra
              jmp #blt_sprloop
blt_shrink_9
              rdlut blt_buffer+0,blt_nibs+0
              rdlut blt_buffer+1,blt_nibs+2
              rdlut blt_buffer+2,blt_nibs+3
              rdlut blt_buffer+3,blt_nibs+4
              rdlut blt_buffer+4,blt_nibs+6
              rdlut blt_buffer+5,blt_nibs+8
              rdlut blt_buffer+6,blt_nibs+9
              rdlut blt_buffer+7,blt_nibs+10
              rdlut blt_buffer+8,blt_nibs+12
              rdlut blt_buffer+9,blt_nibs+14
              setq #9
              wmlong blt_buffer,ptra
              jmp #blt_sprloop
blt_shrink_a
              rdlut blt_buffer+0,blt_nibs+0
              rdlut blt_buffer+1,blt_nibs+2
              rdlut blt_buffer+2,blt_nibs+3
              rdlut blt_buffer+3,blt_nibs+4
              rdlut blt_buffer+4,blt_nibs+6
              rdlut blt_buffer+5,blt_nibs+8
              rdlut blt_buffer+6,blt_nibs+9
              rdlut blt_buffer+7,blt_nibs+10
              rdlut blt_buffer+8,blt_nibs+12
              rdlut blt_buffer+9,blt_nibs+14
              rdlut blt_buffer+10,blt_nibs+15
              setq #10
              wmlong blt_buffer,ptra
              jmp #blt_sprloop
blt_shrink_b
              rdlut blt_buffer+0,blt_nibs+0
              rdlut blt_buffer+1,blt_nibs+2
              rdlut blt_buffer+2,blt_nibs+3
              rdlut blt_buffer+3,blt_nibs+4
              rdlut blt_buffer+4,blt_nibs+6
              rdlut blt_buffer+5,blt_nibs+7
              rdlut blt_buffer+6,blt_nibs+8
              rdlut blt_buffer+7,blt_nibs+9
              rdlut blt_buffer+8,blt_nibs+10
              rdlut blt_buffer+9,blt_nibs+12
              rdlut blt_buffer+10,blt_nibs+14
              rdlut blt_buffer+11,blt_nibs+15
              setq #11
              wmlong blt_buffer,ptra
              jmp #blt_sprloop
blt_shrink_c
              rdlut blt_buffer+0,blt_nibs+0
              rdlut blt_buffer+1,blt_nibs+2
              rdlut blt_buffer+2,blt_nibs+3
              rdlut blt_buffer+3,blt_nibs+4
              rdlut blt_buffer+4,blt_nibs+6
              rdlut blt_buffer+5,blt_nibs+7
              rdlut blt_buffer+6,blt_nibs+8
              rdlut blt_buffer+7,blt_nibs+9
              rdlut blt_buffer+8,blt_nibs+10
              rdlut blt_buffer+9,blt_nibs+12
              rdlut blt_buffer+10,blt_nibs+13
              rdlut blt_buffer+11,blt_nibs+14
              rdlut blt_buffer+12,blt_nibs+15
              setq #12
              wmlong blt_buffer,ptra
              jmp #blt_sprloop
blt_shrink_d
              rdlut blt_buffer+0,blt_nibs+0
              rdlut blt_buffer+1,blt_nibs+1
              rdlut blt_buffer+2,blt_nibs+2
              rdlut blt_buffer+3,blt_nibs+3
              rdlut blt_buffer+4,blt_nibs+4
              rdlut blt_buffer+5,blt_nibs+6
              rdlut blt_buffer+6,blt_nibs+7
              rdlut blt_buffer+7,blt_nibs+8
              rdlut blt_buffer+8,blt_nibs+9
              rdlut blt_buffer+9,blt_nibs+10
              rdlut blt_buffer+10,blt_nibs+12
              rdlut blt_buffer+11,blt_nibs+13
              rdlut blt_buffer+12,blt_nibs+14
              rdlut blt_buffer+13,blt_nibs+15
              setq #13
              wmlong blt_buffer,ptra
              jmp #blt_sprloop
blt_shrink_e
              rdlut blt_buffer+0,blt_nibs+0
              rdlut blt_buffer+1,blt_nibs+1
              rdlut blt_buffer+2,blt_nibs+2
              rdlut blt_buffer+3,blt_nibs+3
              rdlut blt_buffer+4,blt_nibs+4
              rdlut blt_buffer+5,blt_nibs+6
              rdlut blt_buffer+6,blt_nibs+7
              rdlut blt_buffer+7,blt_nibs+8
              rdlut blt_buffer+8,blt_nibs+9
              rdlut blt_buffer+9,blt_nibs+10
              rdlut blt_buffer+10,blt_nibs+11
              rdlut blt_buffer+11,blt_nibs+12
              rdlut blt_buffer+12,blt_nibs+13
              rdlut blt_buffer+13,blt_nibs+14
              rdlut blt_buffer+14,blt_nibs+15
              setq #14
              wmlong blt_buffer,ptra
              jmp #blt_sprloop


blt_augd_mask long $007FFFFF

blt_linecnt   long @video_line_ctr
blt_renderbase long @draw_buffer
blt_vramptr  long @vram_low
blt_sromptr   long @fix_tiles
blt_sprbufptr long @spr_buffer

blt_curline   long -1

blt_colorptr  res 1
blt_renderptr res 1
blt_renderptr_spr res 1
blt_sromline  res 1
blt_tmp1      res 1
blt_tmp2      res 1
blt_tmp3      res 1
blt_tmp4      res 1
blt_tiles     res 1
blt_slotleft  res 1
blt_attr      res 1
blt_palette   res 1

blt_tpix      res 4

blt_tile      res 4
blt_pal       res 4

blt_buffer    res 32
blt_nibs      res 16

              fit 496

CON ' ZiKore constants

ZK_HLOP = 1<<10

ZK_CARRY_BIT = 0
ZK_NMODE_BIT = 1
ZK_OVER_BIT  = 2 ' also parity
ZK_HALF_BIT  = 4
ZK_ZERO_BIT  = 6
ZK_SIGN_BIT  = 7

ZK_XYMASK     = %0010_1000
ZK_SIGNXYMASK = %1010_1000

ZK_IFF1_BIT = 0
ZK_IFF2_BIT = 1
ZK_HALT_BIT = 2

ZK_NMI_ON_BIT = 4  ' NMI is enabled?
ZK_NMI_NAK_BIT = 5 ' Outstanding NMI acknowledge?


DAT ' ZiKore Z80 cog resident code
              orgh
z80_ram ' Z80 work RAM overwrites Z80 implementation
              org
zk_cogbase



zk_nextop
              'debug("skip canary")
              'debug(udec(zk_cycles)," elapsed",uhex_word(zk_pc))


zk_nmihook    nop
              rdword pa,#opn_timerAflag wz
zk_irqhook    nop
zk_nextop_nohook
              {
              cmp zk_pc,##$06B2 wz
        'if_nz cmp zk_pc,##$06EF wz
        if_nz cmp zk_pc,##$06D2 wz
        'if_nz cmp zk_pc,##$044E wz
        'if_nz cmp zk_pc,##$0451 wz
        if_nz jmp #.nodebug          '}
              'debug(uhex_word(zk_pc),uhex_long(zk_debc),uhex_word(zk_hl,zk_sp),uhex_byte(zk_accu),ubin_byte(zk_flags))
              'debug(uhex_byte_array(#@fakemem+$FFF0,#16))
.nodebug
              mul zk_cycles,zk_cycletime
              add zk_cycles,zk_lastwait
              getct pa
              sub zk_cycles,pa
              cmps zk_cycles,#1 wc
        if_ae waitx zk_cycles
              getct zk_lastwait

              mov zk_cycles,#1

              mov zk_temphl,zk_hl
              mov zk_hlptr,#zk_hl
              mov zk_tempidx,zk_hl
              mov zk_prefix,#0
              incmod zk_refresh,#127

              call #zk_readcode
              mov zk_opcode,zk_tmp8
              'debug(uhex_byte(zk_opcode))
              rdlut zk_opimpl,zk_opcode
              'debug(uhex_long(zk_opimpl))
              bitl zk_opimpl,#10 wcz ' first instruction can't be skipped, use as flag for (HL) ops
              push #zk_nextop
              execf zk_opimpl


zk_iyprefix
              mov zk_hlptr,#zk_iy
zk_ixprefix
              mov zk_hlptr,#zk_ix

              mov zk_prefix,zk_opcode
              incmod zk_refresh,#127
              add zk_cycles,#1


              call #zk_readcode
              mov zk_opcode,zk_tmp8
              rdlut zk_opimpl,zk_opcode
              bitl zk_opimpl,#10 wcz ' first instruction can't be skipped, use as flag for (HL) ops
        if_nc jmp #.nodisplace
              ' handle index displacement
              mov zk_temphl,zk_hl
              alts zk_hlptr
              mov zk_tempidx,0-0
              mov zk_hlptr,#zk_hl
              call #zk_readcode
              signx zk_tmp8,#7
              add zk_tempidx,zk_tmp8
              execf zk_opimpl

.nodisplace
              alts zk_hlptr
              mov zk_temphl,0-0
              mov zk_tempidx,zk_temphl
              execf zk_opimpl


zk_bitprefix
              call #\zk_readcode
              mov zk_opcode,zk_tmp8
              add zk_cycles,#1
              incmod zk_refresh,#127

              cmp zk_prefix,#0 wz
        if_z  call #zk_getrz
        if_nz call #zk_read8hl

              mov pa,zk_opcode
              shr pa,#3
              and pa,#7

              testb zk_opcode,#7 wc
              testb zk_opcode,#6 wz
        if_00 jmp #.shift
        if_01 jmp #.bit
              bitz zk_tmp8,pa
              ' write result (slightly complex)
              mov pa,zk_opcode
              and pa,#7
              cmp pa,#6 wz
        if_nz cmp zk_prefix,#0 wz
        if_nz push #zk_write8hl
              jmp #\zk_setrz


.bit
              decod pa
              and pa,zk_tmp8 wz
              muxz zk_flags,#(1<<ZK_ZERO_BIT)|(1<<ZK_OVER_BIT)
              bitl zk_flags,#ZK_NMODE_BIT
              bith zk_flags,#ZK_HALF_BIT
              setq #1<<ZK_SIGN_BIT
              muxq zk_flags,pa
              setq #ZK_XYMASK
        _ret_ muxq zk_flags,zk_tmp8


.shift
              push #.shiftdone
              altd pa,#zk_shift_impl_tbl
              execf 0-0

.shiftdone
              ' write result (slightly complex)
              mov pa,zk_opcode
              and pa,#7
              cmp pa,#6 wz
        if_nz cmp zk_prefix,#0 wz
        if_nz push #zk_write8hl
              jmp #\zk_setrz


zk_shift_impl_tbl
              long zk_shiftop + (%1_001_110_01_11110_0<<10) ' RLC
              long zk_shiftop + (%1_001_001_01_11011_0<<10) ' RRC
              long zk_shiftop + (%1_001_110_00_11110_0<<10) ' RL
              long zk_shiftop + (%1_001_001_00_11011_0<<10) ' RR
              long zk_shiftop + (%1_001_110_01_01110_0<<10) ' SLA
              long zk_shiftop + (%1_001_011_01_11000_0<<10) ' SRA
              long zk_shiftop + (%1_001_110_01_10110_0<<10) ' SLL
              long zk_shiftop + (%1_001_011_01_11011_0<<10) ' SRL


zk_extprefix
              call #\zk_readcode
              mov zk_opcode,zk_tmp8
              add zk_cycles,#1
              incmod zk_refresh,#127
              'debug("extend ",uhex_byte(zk_opcode))

              cmp zk_opcode,#$A0 wc
        if_ae jmp #.blockop
              cmp zk_opcode,#$40 wc
        if_b  ret

              mov pa,zk_opcode
              and pa,#7
              altd pa,#zk_ext_impl_tbl
              execf 0-0

.blockop
              '' The undocumented flags on these are cursed.
              test zk_opcode,#%0100_0100 wz
        if_nz ret ' NOP
              rczr zk_opcode wcz ' get operation type into cz
        if_00 add zk_cycles,#2
        if_01 add zk_cycles,#5
        if_1x add zk_cycles,#1
        if_00 skipf ##%00000000_11111_11111_01_1111110_1110_011_111111 ' LD
        if_01 skipf ##%00000011_01010_00000_10_0011110_1101_011_1111   ' CP
        if_10 skipf ##%00001111_10101_11101_01_1100011_0011_100_11     ' IN
        if_11 skipf ##%00111111_10101_11101_01_1111101_0011_011        ' OUT

              getbyte zk_ea,zk_debc,#0 ' IN
              call #\zk_portin ' IN
              call #\zk_read8hl ' everything else

              andn zk_flags,#(1<<ZK_NMODE_BIT)|(1<<ZK_HALF_BIT) ' LD
              bith zk_flags,#ZK_NMODE_BIT ' CP
              testb zk_tmp8,#7 wc ' IN/OUT
              bitc zk_flags,#ZK_NMODE_BIT ' IN/OUT

              mov zk_optmp0,zk_accu ' LD CP
              getbyte zk_optmp0,zk_hl,#0 ' OUT
              getbyte zk_optmp0,zk_debc,#0 ' IN
              testb zk_opcode,#1 wc ' IN
              sumc zk_optmp0,#1 ' IN
              mov zk_optmp1,zk_tmp8 ' CP
              xor zk_optmp1,zk_optmp0 ' CP

              sub zk_optmp0,zk_tmp8 ' CP only
              add zk_optmp0,zk_tmp8 ' LD,IN,OUT

              xor zk_optmp1,zk_optmp0 ' CP
              and zk_optmp0,#255 wz ' CP,IN,OUT
              bitz zk_flags,#ZK_ZERO_BIT ' CP
              testb zk_optmp0,#7 wc ' CP
              bitc  zk_flags,#ZK_SIGN_BIT ' CP

              testb zk_optmp1,#4 wc   ' CP
              cmpr zk_optmp0,#255 wc  ' IN/OUT
              bitc zk_flags,#ZK_HALF_BIT ' CP
              muxc zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_CARRY_BIT) ' IN/OUT
        if_c  sub zk_optmp0,#1  ' CP (subtract HF again for XY flag purposes)

              skipf ##%000_00_000_01_11100100_11001_1111_0000_111111 ' LD
              skipf ##%000_00_111_00_11100100_11111_1111_0000_1111 ' CP
              skipf ##%000_00_111_01_00011001_11010_0000_1111_11   ' IN
              skipf ##%000_00_111_01_00011001_00111_0000_1111      ' OUT


              testb zk_optmp0,#1 wc ' LD,CP
              bitc zk_flags,#5 'LD,CP (sets YF)
              testb zk_optmp0,#3 wc ' LD,CP
              bitc zk_flags,#3 'LD,CP (sets XF)

              getbyte zk_optmp1,zk_debc,#1 ' IN,OUT (get B)
              and zk_optmp0,#7 ' IN,OUT
              xor zk_optmp0,zk_optmp1 wc ' IN,OUT
              bitnc zk_flags,#ZK_OVER_BIT ' IN,OUT

              mov zk_ea,zk_hl  ' IN
              getword zk_ea,zk_debc,#1 ' LD
              call #\zk_write8 ' LD,IN
              getbyte zk_ea,zk_debc,#0 ' OUT
              call #\zk_portout ' OUT

              getword zk_optmp1,zk_debc,#0 ' LD,CP
              decmod zk_optmp1,zk_ffffh wz ' all
              setbyte zk_debc,zk_optmp1,#1 ' IN/OUT
              setword zk_debc,zk_optmp1,#0 ' LD,CP
              bitnz zk_flags,#ZK_OVER_BIT ' LD,CP
              bitz zk_flags,#ZK_ZERO_BIT ' IN,OUT
              setq #ZK_SIGNXYMASK ' IN,OUT
              muxq zk_flags,zk_optmp1 ' IN,OUT

              testb zk_flags,#ZK_ZERO_BIT orz ' CP (A==(HL) can also trigger CPxR break)
              testb zk_opcode,#1 wc ' Get direction (C = dec)

        if_nc incmod zk_ea,zk_ffffh    ' LD
        if_c  decmod zk_ea,zk_ffffh    ' LD
              setword zk_debc,zk_ea,#1 ' LD

        if_nc incmod zk_hl,zk_ffffh
        if_c  decmod zk_hl,zk_ffffh

              testb zk_opcode,#2 wc ' Is repeat code?
 if_c_and_nz  sub zk_pc,#2
 if_c_and_nz  add zk_cycles,#5
              'debug(uhex_byte(zk_tmp8),uhex_long(zk_debc),ubin_byte(zk_flags))
              ret

zk_ext_impl_tbl
              long zk_cio + (%10_11_11_000000<<10) ' IN [BCDEHL0A],(C)
              long zk_cio + (%00_01_11_000000<<10) ' OUT (C),[BCDEHL0A]
              long zk_ext_differentiate + (%0_110_000<<10) ' ADC/SBC with HL
              long zk_ext_differentiate + (%0_101_000<<10) ' 16 bit LD from to (imm16)
              long zk_neg
              long zk_irqret
              long zk_imode
              long zk_ext_differentiate + (%0_011_000<<10) ' miscellany

zk_ext_differentiate
              mov pa,zk_opcode
              shr pa,#3
              and pa,#7

              altd pa,#zk_extmath16_impl_tbl
              altd pa,#zk_extld16_impl_tbl
              altd pa,#zk_extmisc_impl_tbl

              execf 0-0

zk_extmath16_impl_tbl
              long zk_cmath16 + (%0100_000_00_0011_00_1110_0<<10) ' SBC HL,BC
              long zk_cmath16 + (%0100_000_00_1100_00_1110_0<<10) ' ADC HL,BC
              long zk_cmath16 + (%0100_000_00_0011_00_1101_0<<10) ' SBC HL,DE
              long zk_cmath16 + (%0100_000_00_1100_00_1101_0<<10) ' ADC HL,DE
              long zk_cmath16 + (%0100_000_00_0011_00_1011_0<<10) ' SBC HL,HL
              long zk_cmath16 + (%0100_000_00_1100_00_1011_0<<10) ' ADC HL,HL
              long zk_cmath16 + (%0100_000_00_0011_00_0111_0<<10) ' SBC HL,SP
              long zk_cmath16 + (%0100_000_00_1100_00_0111_0<<10) ' ADC HL,SP

zk_extld16_impl_tbl
              long zk_ld_abs16 + (%01110_00<<10) ' LD (imm16),BC
              long zk_ld_abs16 + (%00_11111_00<<10) ' LD BC,(imm16)
              long zk_ld_abs16 + (%01101_00<<10) ' LD (imm16),DE
              long zk_ld_abs16 + (%010_11111_00<<10) ' LD DE,(imm16)
              long zk_ld_abs16 + (%01011_00<<10) ' LD (imm16),HL
              long zk_ld_abs16 + (%00110_11111_00<<10) ' LD HL,(imm16)
              long zk_ld_abs16 + (%00111_00<<10) ' LD (imm16),SP
              long zk_ld_abs16 + (%01110_11111_00<<10) ' LD SP,(imm16)

zk_extmisc_impl_tbl
              long zk_a2i                       ' LD I,A
              long zk_a2r                       ' LD R,A
              long zk_i2a                       ' LD A,I
              long zk_r2a  + (%1_000<<10)       ' LD A,R
              long zk_rxd + (%000_111_00<<10)   ' RRD
              long zk_rxd + (%111_000_00<<10)   ' RLD
              long zk_nextop                    ' NOP
              long zk_nextop                    ' NOP


zk_rxd
              call #\zk_read8hl
              add zk_cycles,#4
              ' RLD
              rolnib zk_tmp8,zk_accu,#0
              getnib pa,zk_tmp8,#2
              setnib zk_tmp8,#0,#2
              ' RRD
              setnib zk_tmp8,zk_accu,#2
              getnib pa,zk_tmp8,#0
              shr zk_tmp8,#4

              setnib zk_accu,pa,#0
              andn zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)
              and zk_accu,#$FF wcz
              bitz zk_flags,#ZK_ZERO_BIT
              bitnc zk_flags,#ZK_OVER_BIT
              setq #ZK_SIGNXYMASK
              muxq zk_flags,zk_accu
              jmp #\zk_write8hl

zk_a2r
              mov zk_refresh,zk_accu
              and zk_refresh,#$7F
        _ret_ mov zk_refreshhi,zk_accu

zk_a2i
        _ret_ mov zk_ivector,zk_accu

zk_r2a
              mov zk_accu,zk_refresh
              setq #$80
              muxq zk_accu,zk_refreshhi
zk_i2a
              mov zk_accu,zk_ivector

              and zk_accu,#$FF wcz
              bitz zk_flags,#ZK_ZERO_BIT
              testb zk_irqenable,#ZK_IFF2_BIT wc
              bitc zk_flags,#ZK_OVER_BIT
              andn zk_flags,#(1<<ZK_NMODE_BIT)|(1<<ZK_HALF_BIT)
              setq #ZK_SIGNXYMASK
        _ret_ muxq zk_flags,zk_accu





zk_imode      ' Don't care, always assume IM1
              ret
zk_irqoff
              andn zk_irqenable,#(1<<ZK_IFF1_BIT)|(1<<ZK_IFF2_BIT)
        _ret_ mov zk_irqhook,#0


zk_irqret     '' RETI/RETN
              '' These are literally the same
              call #\zk_pop16
              mov zk_pc,zk_tmp16
              testb zk_irqenable,#ZK_IFF2_BIT wc
        if_nc ret
zk_irqon
              or zk_irqenable,#(1<<ZK_IFF1_BIT)|(1<<ZK_IFF2_BIT)
              mov zk_irqhook,##(%0101_1101011_000_000000000_000101100)+zk_irqptr<<9 ' IF_NZ JMP zk_irqptr
              jmp #zk_nextop_nohook

zk_irqptr     long zk_doirq'_debug
zk_nmiptr     long zk_donmi

{
zk_doirq_debug
              debug("IRQ")
              jmp #zk_doirq
'}
zk_donmi
              debug("NMI ")
              or zk_irqenable,#(1<<ZK_NMI_NAK_BIT)
              mov zk_nmihook,#0 ' disable NMI until acknowledge
              skipf ##%0_01_00_01_00_1100
zk_doirq
              add zk_cycles,#5
              mov zk_irqhook,#0
              skipf ##%0_10_00_10_00

              test zk_irqenable,#(1<<ZK_HALT_BIT) wz
        if_nz incmod zk_pc,zk_ffffh

              andn zk_irqenable,#(1<<ZK_IFF1_BIT)|(1<<ZK_IFF2_BIT)|(1<<ZK_HALT_BIT) ' IRQ
              andn zk_irqenable,#(1<<ZK_IFF1_BIT)|(1<<ZK_HALT_BIT) ' NMI

              mov zk_tmp16,zk_pc
              call #\zk_push16

              mov zk_pc,#$38 ' IRQ
              mov zk_pc,#$66 ' NMI

              jmp #\zk_nextop

zk_ack_nmi
              bitl zk_irqenable,#ZK_NMI_NAK_BIT
zk_setnmihook
              testb zk_irqenable,#ZK_NMI_ON_BIT wc
              testbn zk_irqenable,#ZK_NMI_NAK_BIT andc
        if_nc mov zk_nmihook,#0
        if_c  mov zk_nmihook,##(%1111_1011110_010_000001110<<9)+zk_nmiptr ' JATN zk_nmiptr
              ret wcz


zk_jump_indir
        _ret_ mov zk_pc,zk_temphl
zk_hl_to_sp
              add zk_cycles,#2
        _ret_ mov zk_sp,zk_temphl

zk_jump
              call #\zk_readcode16
zk_condret
              add zk_cycles,#1 ' Extra cycle in conditional RET

              testb zk_flags,#ZK_ZERO_BIT wc
              testb zk_flags,#ZK_CARRY_BIT wc
              testb zk_flags,#ZK_OVER_BIT wc
              testb zk_flags,#ZK_SIGN_BIT wc

              modc _nc wc
        if_c  call #\zk_nextop
zk_ret
              call #zk_pop16
              mov zk_optmp0,zk_tmp16 ' For every op!
zk_rst
              mov zk_optmp0,zk_opcode
              and zk_optmp0,#%00111000
zk_pushjmp
              mov zk_tmp16,zk_pc
              mov zk_pc,zk_optmp0
              jmp #\zk_push16
              ret



zk_getrz      ' Get value as indicated by opcode Z field
              mov pa,zk_opcode
              and pa,#7
              'debug("in zk_getrz ",uhex_byte(pa))
              add pa,#zk_getrpa-$-1
              jmprel pa
zk_getry      ' Get value as indicated by opcode Y field
              mov pa,zk_opcode
              shr pa,#3
              and pa,#7
zk_getrpa
              jmprel pa
        _ret_ getbyte zk_tmp8,zk_debc,#1   ' B register
        _ret_ getbyte zk_tmp8,zk_debc,#0   ' C register
        _ret_ getbyte zk_tmp8,zk_debc,#3   ' D register
        _ret_ getbyte zk_tmp8,zk_debc,#2   ' E register
        _ret_ getbyte zk_tmp8,zk_temphl,#1 ' H register
        _ret_ getbyte zk_tmp8,zk_temphl,#0 ' L register
              jmp #zk_read8hl              ' (HL)
        _ret_ getbyte zk_tmp8,zk_accu,#0   ' A register

zk_setrz      ' Get value as indicated by opcode Z field
              mov pa,zk_opcode
              and pa,#7
              add pa,#zk_setrpa-$-1
              jmprel pa
zk_setry      ' Get value as indicated by opcode Y field
              mov pa,zk_opcode
              shr pa,#3
              and pa,#7
              'debug("in zk_setry ",uhex_byte(pa,zk_tmp8))
zk_setrpa     jmprel pa
        _ret_ setbyte zk_debc,zk_tmp8,#1   ' B register
        _ret_ setbyte zk_debc,zk_tmp8,#0   ' C register
        _ret_ setbyte zk_debc,zk_tmp8,#3   ' D register
        _ret_ setbyte zk_debc,zk_tmp8,#2   ' E register
              jmp #.seth                   ' H register
              jmp #.setl                   ' L register
              jmp #zk_write8hl             ' (HL)
        _ret_ setbyte zk_accu,zk_tmp8,#0   ' A register

.seth
              setbyte zk_temphl,zk_tmp8,#1
              altd zk_hlptr
        _ret_ mov 0-0,zk_temphl
.setl
              setbyte zk_temphl,zk_tmp8,#0
              altd zk_hlptr
        _ret_ mov 0-0,zk_temphl

zk_push16
              add zk_cycles,#1
              sub zk_sp,#2
              setword zk_sp,#0,#1
              mov zk_ea,zk_sp
              jmp #zk_write16
zk_pop16
              mov zk_ea,zk_sp
              add zk_sp,#2
              setword zk_sp,#0,#1
              jmp #zk_read16

zk_read16hl
              getword zk_ea,zk_tempidx,#0
zk_read16
              call #zk_read8
              getbyte zk_tmp16,zk_tmp8,#0
              add zk_ea,#1
              call #zk_read8
              setbyte zk_tmp16,zk_tmp8,#1
        _ret_ sub zk_ea,#1

zk_read8hl
              getword zk_ea,zk_tempidx,#0
              jmp #zk_read8
zk_readcode
              mov zk_ea,zk_pc
              incmod zk_pc,zk_ffffh
              setword zk_pc,#0,#1
              ' fall through
zk_read8
              add zk_cycles,#3

              getword pa,zk_ea,#0
              modcz _clr,_set wcz
        if_x1 cmpsub pa,zk_ramstart wc
        if_11 add pa,zk_ramptr wz
        if_x1 cmpsub pa,zk_bank0start wc
        if_11 add pa,zk_bank0ptr wz
        if_x1 cmpsub pa,zk_bank1start wc
        if_11 add pa,zk_bank1ptr wz
        if_x1 cmpsub pa,zk_bank2start wc
        if_11 add pa,zk_bank2ptr wz
        if_x1 cmpsub pa,zk_bank3start wc
        if_11 add pa,zk_bank3ptr wz
        if_01 add pa,zk_staticptr

              rdbyte zk_tmp8,pa
              ret wcz


zk_readcode16
              call #zk_readcode
              getbyte zk_tmp16,zk_tmp8,#0
              call #zk_readcode
        _ret_ setbyte zk_tmp16,zk_tmp8,#1

zk_write16hl
              getword zk_ea,zk_tempidx,#0
zk_write16
              getbyte zk_tmp8,zk_tmp16,#0
              call #zk_write8
              add zk_ea,#1
              getbyte zk_tmp8,zk_tmp16,#1
              call #zk_write8
        _ret_ sub zk_ea,#1


zk_write8hl
              getword zk_ea,zk_tempidx,#0
zk_write8
           {  cmp zk_ea,##$FFF8 wz
        if_nz cmp zk_ea,##$FFF9 wz
        if_nz jmp #.nodebug
              debug("write monitor! ",uhex_word(zk_ea),uhex_byte(zk_tmp8))     }
              'debug("in zk_read8 ",uhex_word(zk_ea))
.nodebug
              add zk_cycles,#3

              getword pa,zk_ea,#0
              {
              cmp zk_ea,##$10000 wc
        if_b  jmp #.notsus
              debug("OOB write: ",uhex_long(pa))
.notsus
              }
              cmpsub pa,zk_ramstart wc
        if_c  add pa,zk_ramptr
        if_c  wrbyte zk_tmp8,pa
              ret wcz

zk_portout
              add zk_cycles,#4
              'debug("PORT OUT ",uhex_byte(zk_ea,zk_tmp8)," : "{, zk_tmp8} )
              'tjnz zk_ea,#.nope
              'debug(`ZTerm `(zk_tmp8))
.nope
              testb zk_ea,#3 wc
              testb zk_ea,#2 wz
        if_01 jmp #opn_portwrite
        if_00 wrbyte #0,#z80_command_b
        if_11 wrbyte zk_tmp8,#z80_reply_b
        if_not_10 ret wcz
              ' Enable/disable NMI
              testb zk_ea,#4 wc
              bitnc zk_irqenable,#ZK_NMI_ON_BIT
              jmp #\zk_setnmihook

zk_portin
              add zk_cycles,#4
              'debug("PORT IN ",uhex_byte(zk_ea))
              testb zk_ea,#3 wc
              testb zk_ea,#2 wz
        if_01 jmp #opn_statusread
        if_10 jmp #.bankset
        if_00 rdbyte zk_tmp8,#z80_command_b
        if_00 jmp #\zk_ack_nmi
        if_11 mov zk_tmp8,#$FF ' Not sure what this should do
              ret wcz
.bankset
              cmp zk_opcode,#$DB wz ' IN A,(imm8) opcode
        if_z  getbyte zk_memtmp0,zk_accu,#0
        if_nz getbyte zk_memtmp0,zk_debc,#1
              mov pa,zk_ea
              and pa,#3
              shl zk_memtmp0,#11
              shl zk_memtmp0,pa
              zerox zk_memtmp0,#16 ' Limit to 128k
              altr pa,#zk_bank0ptr
              add zk_memtmp0,zk_staticptr
              mov zk_tmp8,#$FF
              ret wcz


zk_ramstart   long $F800
zk_bank0start long $F000
zk_bank1start long $E000
zk_bank2start long $C000
zk_bank3start long $8000

zk_ramptr     long @z80_ram
zk_bank0ptr   long @m1_rom + $F000
zk_bank1ptr   long @m1_rom + $E000
zk_bank2ptr   long @m1_rom + $C000
zk_bank3ptr   long @m1_rom + $8000
zk_staticptr  long @m1_rom

zk_ffffh      long $FFFF
zk_18000h     long $18000
zk_bit31      long  negx

zk_cycles     long 0
zk_pc         long $0100


zk_flags      long 0
zk_accu       long 0
zk_debc       long 0
zk_sp         long 0
zk_hl         long 0
zk_ix         long 0
zk_iy         long 0
zk_altflags   long 0
zk_altaccu    long 0
zk_altdebc    long 0
zk_althl      long 0
zk_refresh    long 0
zk_refreshhi  long 0
zk_ivector    long 0
zk_irqenable  long 0


zk_cycletime  long CLK_MULTIPLIER*6
zk_lastwait   res 1

zk_opcode     res 1
zk_opimpl     res 1
zk_prefix     res 1
zk_temphl     res 1
zk_tempidx    res 1
zk_hlptr      res 1
zk_tmp16      res 1

zk_optmp0     res 1
zk_optmp1     res 1


              fit $1F0
              org $1F0
zk_memtmp0    res 1
zk_memtmp1    res 1
zk_memtmp2    res 1
zk_memtmp3    res 1
zk_tmp8       res 1 ' memory read/write value
zk_ea         res 1 ' remapped EA
              fit $1F6

DAT ' ZiKore Z80 LUT resident code
              org $200
zk_lutbase
              '' Opcode table
              long zk_nextop                            ' $00: NOP
              long zk_loadimm16 + (%0000_1_111_0<<10)   ' $01: LD BC,imm16
              long zk_a_and_ptr + (%001110<<10)         ' $02: LD (BC),A
              long zk_incdec16+(%0000_1_1111_10_1_11100<<10) ' $03: INC BC
              long zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10) ' $04: INC B
              long zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10) ' $05: DEC B
              long zk_loadimm8                          ' $06: LD B,imm8
              long zk_rolla+(%0_010_110_01_11110_00<<10) ' $07: RLCA
              long zk_ex_af                             ' $08: EX AF,AF'
              long zk_math16+(%0010_111_00_1100_00_1110_1_0<<10) ' $09: ADD HL,BC
              long zk_a_and_ptr + (%000010<<10)         ' $0A: LD A,(BC)
              long zk_incdec16+(%0000_1_1111_01_1_11100<<10) ' $0B: DEC BC
              long zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10) ' $0C: INC C
              long zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10) ' $0D: DEC C
              long zk_loadimm8                          ' $0E: LD C,imm8
              long zk_rolla+(%0_010_001_01_11011_00<<10) ' $0F: RRCA
              long zk_jr + (%01_11_0000_0<<10)          ' $10: DJNZ
              long zk_loadimm16 + (%0001_1_111_0<<10)   ' $11: LD DE,imm16
              long zk_a_and_ptr + (%00110 <<10)+1       ' $12: LD (DE),A
              long zk_incdec16+(%0001_1_1111_10_1_11010<<10) ' $13: INC DE
              long zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10) ' $14: INC D
              long zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10) ' $15: DEC D
              long zk_loadimm8                          ' $16: LD D,imm8
              long zk_rolla+(%0_010_110_00_11110_00<<10) ' $17: RLA
              long zk_jr + (%11_11_1111_0<<10)          ' $18: JR
              long zk_math16+(%0010_111_00_1100_00_1101_1_0<<10) ' $19: ADD HL,DE
              long zk_a_and_ptr + (%00000 <<10)+1       ' $1A: LD A,(DE)
              long zk_incdec16+(%0001_1_1111_01_1_11010<<10) ' $1B: DEC DE
              long zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10) ' $1C: INC E
              long zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10) ' $1D: DEC E
              long zk_loadimm8                          ' $1E: LD E,imm8
              long zk_rolla+(%0_010_001_00_11011_00<<10) ' $1F: RRA
              long zk_jr + (%01_10_1111_0<<10)          ' $20: JR NZ
              long zk_loadimm16 + (%0011_1_111_0<<10)   ' $21: LD HL,imm16
              long zk_ld_abs16 + (%01011_00<<10)        ' $22: LD (imm16),HL
              long zk_incdec16+(%0011_1_1111_10_1_10110<<10) ' $23: INC HL
              long zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10) ' $24: INC H
              long zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10) ' $25: DEC H
              long zk_loadimm8                          ' $26: LD H,imm8
              long zk_daa                               ' $27: DAA
              long zk_jr + (%00_10_1111_0<<10)          ' $28: JR Z
              long zk_math16+(%0010_111_00_1100_00_1011_1_0<<10) ' $29: ADD HL,HL
              long zk_ld_abs16 + (%00110_11111_00<<10)  ' $2A: LD HL,(imm16)
              long zk_incdec16+(%0011_1_1111_01_1_10110<<10) ' $2B: DEC HL
              long zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10) ' $2C: INC L
              long zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10) ' $2D: DEC L
              long zk_loadimm8                          ' $2E: LD L,imm8
              long zk_cpl                               ' $2F: CPL
              long zk_jr + (%01_01_1111_0<<10)          ' $30: JR NC
              long zk_loadimm16 + (%0111_1_111_0<<10)   ' $31: LD SP,imm16
              long zk_ld_abs + (%001111_00<<10)         ' $32: LD (imm16),A
              long zk_incdec16+(%0111_1_1111_10_1_01110<<10) ' $33: INC SP
              long zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)+ZK_HLOP ' $34: INC (HL)
              long zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)+ZK_HLOP ' $35: DEC (HL)
              long zk_loadimm8 + ZK_HLOP                ' $36: LD (HL),imm8
              long zk_scf + (%10 << 10)                 ' $37: SCF
              long zk_jr + (%00_01_1111_0<<10)          ' $38: JR C
              long zk_math16+(%0010_111_00_1100_00_0111_1_0<<10) ' $39: ADD HL,SP
              long zk_ld_abs + (  %0011_00<<10)         ' $3A: LD A,(imm16)
              long zk_incdec16+(%0111_1_1111_01_1_01110<<10)' $3B: DEC SP
              long zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10) ' $3C: INC A
              long zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10) ' $3D: DEC A
              long zk_loadimm8                          ' $3E: LD A,imm8
              long zk_ccf                               ' $3F: CCF
              long zk_nextop                            ' $40: LD B,B (NOP)
              long zk_regmove                           ' $41: LD B,C
              long zk_regmove                           ' $42: LD B,D
              long zk_regmove                           ' $43: LD B,E
              long zk_regmove                           ' $44: LD B,H
              long zk_regmove                           ' $45: LD B,L
              long zk_regmove + ZK_HLOP                 ' $46: LD B,(HL)
              long zk_regmove                           ' $47: LD B,A
              long zk_regmove                           ' $48: LD C,B
              long zk_nextop                            ' $49: LD C,C (NOP)
              long zk_regmove                           ' $4A: LD C,D
              long zk_regmove                           ' $4B: LD C,E
              long zk_regmove                           ' $4C: LD C,H
              long zk_regmove                           ' $4D: LD C,L
              long zk_regmove + ZK_HLOP                 ' $4E: LD C,(HL)
              long zk_regmove                           ' $4F: LD C,A
              long zk_regmove                           ' $50: LD D,B
              long zk_regmove                           ' $51: LD D,C
              long zk_nextop                            ' $52: LD D,D (NOP)
              long zk_regmove                           ' $53: LD D,E
              long zk_regmove                           ' $54: LD D,H
              long zk_regmove                           ' $55: LD D,L
              long zk_regmove + ZK_HLOP                 ' $56: LD D,(HL)
              long zk_regmove                           ' $57: LD D,A
              long zk_regmove                           ' $58: LD E,B
              long zk_regmove                           ' $59: LD E,C
              long zk_regmove                           ' $5A: LD E,D
              long zk_nextop                            ' $5B: LD E,E (NOP)
              long zk_regmove                           ' $5C: LD E,H
              long zk_regmove                           ' $5D: LD E,L
              long zk_regmove + ZK_HLOP                 ' $5E: LD E,(HL)
              long zk_regmove                           ' $5F: LD E,A
              long zk_regmove                           ' $60: LD H,B
              long zk_regmove                           ' $61: LD H,C
              long zk_regmove                           ' $62: LD H,D
              long zk_regmove                           ' $63: LD H,E
              long zk_nextop                            ' $64: LD H,H (NOP)
              long zk_regmove                           ' $65: LD H,L
              long zk_regmove + ZK_HLOP                 ' $66: LD H,(HL)
              long zk_regmove                           ' $67: LD H,A
              long zk_regmove                           ' $68: LD L,B
              long zk_regmove                           ' $69: LD L,C
              long zk_regmove                           ' $6A: LD L,D
              long zk_regmove                           ' $6B: LD L,E
              long zk_regmove                           ' $6C: LD L,H
              long zk_nextop                            ' $6D: LD L,L (NOP)
              long zk_regmove + ZK_HLOP                 ' $6E: LD L,(HL)
              long zk_regmove                           ' $6F: LD L,A
              long zk_regmove + ZK_HLOP                 ' $70: LD (HL),B
              long zk_regmove + ZK_HLOP                 ' $71: LD (HL),C
              long zk_regmove + ZK_HLOP                 ' $72: LD (HL),D
              long zk_regmove + ZK_HLOP                 ' $73: LD (HL),E
              long zk_regmove + ZK_HLOP                 ' $74: LD (HL),H
              long zk_regmove + ZK_HLOP                 ' $75: LD (HL),L
              long zk_halt                              ' $76: HALT
              long zk_regmove + ZK_HLOP                 ' $77: LD (HL),A
              long zk_regmove                           ' $78: LD A,B
              long zk_regmove                           ' $79: LD A,C
              long zk_regmove                           ' $7A: LD A,D
              long zk_regmove                           ' $7B: LD A,E
              long zk_regmove                           ' $7C: LD A,H
              long zk_regmove                           ' $7D: LD A,L
              long zk_regmove + ZK_HLOP                 ' $7E: LD A,(HL)
              long zk_nextop                            ' $7F: LD A,A (NOP)
              long(zk_math8 + (%10_11_00_0000_1100_0_10_001_0<<10) )[6]' $80..$85: ADD A,[BCDEHL]
              long zk_math8 + (%10_11_00_0000_1100_0_10_001_0<<10) + ZK_HLOP ' $86: ADD A,(HL)
              long zk_math8 + (%10_11_00_0000_1100_0_10_001_0<<10) ' $87: ADD A,A
              long(zk_math8 + (%10_11_00_0000_1100_0_01_001_0<<10) )[6]' $88..$8D: ADC A,[BCDEHL]
              long zk_math8 + (%10_11_00_0000_1100_0_01_001_0<<10) + ZK_HLOP ' $8E: ADC A,(HL)
              long zk_math8 + (%10_11_00_0000_1100_0_01_001_0<<10) ' $8F: ADC A,A
              long(zk_math8 + (%10_11_00_0000_0011_0_10_001_0<<10) )[6]' $90..$95: SUB [BCDEHL]
              long zk_math8 + (%10_11_00_0000_0011_0_10_001_0<<10) + ZK_HLOP ' $96: SUB (HL)
              long zk_math8 + (%10_11_00_0000_0011_0_10_001_0<<10) ' $97: SUB A
              long(zk_math8 + (%10_11_00_0000_0011_0_01_001_0<<10) )[6]' $98..$9D: SBC A,[BCDEHL]
              long zk_math8 + (%10_11_00_0000_0011_0_01_001_0<<10) + ZK_HLOP ' $9E: SBC A,(HL)
              long zk_math8 + (%10_11_00_0000_0011_0_01_001_0<<10) ' $9F: SBC A,A
              long(zk_logic + (%000000_110_0<<10))[6]   ' $A0..$A5: AND [BCDEHL]
              long zk_logic + (%000000_110_0<<10) + ZK_HLOP ' $A6: AND (HL)
              long zk_logic + (%000000_110_0<<10)       ' $A7: AND A
              long(zk_logic + (%001000_011_0<<10))[6]   ' $A8..$AD: XOR [BCDEHL]
              long zk_logic + (%001000_011_0<<10) + ZK_HLOP ' $AE: XOR (HL)
              long zk_logic + (%001000_011_0<<10)       ' $AF: XOR A
              long(zk_logic + (%001000_101_0<<10))[6]   ' $B0..$B5: OR [BCDEHL]
              long zk_logic + (%001000_101_0<<10) + ZK_HLOP ' $B6: OR (HL)
              long zk_logic + (%001000_101_0<<10)       ' $B7: OR A
              long(zk_math8 + (%11_00_00_0000_0011_0_10_001_0<<10) )[6]' $B8..$BD: CP [BCDEHL]
              long zk_math8 + (%11_00_00_0000_0011_0_10_001_0<<10) + ZK_HLOP ' $BE: CP (HL)
              long zk_math8 + (%11_00_00_0000_0011_0_10_001_0<<10) ' $BF: CP A
              long zk_condret+(%0101_11_00_01_1110_0<<10) ' $C0: RET NZ
              long zk_poppair+(%0_0<<10)                  ' $C1: POP BC
              long zk_jump  + (%0101_11_01_01_1110_10<<10) ' $C2: JP NZ,imm16
              long zk_jump  + (%0101_11_01_11_1111_10<<10) ' $C3: JP imm16
              long zk_jump  + (%0000_11_01_01_1110_10<<10) ' $C4: CALL NZ,imm16
              long zk_pushbc+(%0_1110<<10)              ' $C5: PUSH BC
              long zk_immmath + (%10_11_00_0000_1100_0_10_00_0<<10) ' $C6: ADD A,imm8
              long zk_rst                               ' $C7: RST 00h
              long zk_condret+(%0101_11_00_00_1110_0<<10) ' $C8: RET Z
              long zk_ret + (%0101_11_00<<10)           ' $C9: RET
              long zk_jump  + (%0101_11_01_00_1110_10<<10)' $CA: JP Z,imm16
              long zk_bitprefix + ZK_HLOP               ' $CB: bit op prefix
              long zk_jump  + (%0000_11_01_00_1110_10<<10)' $CC: CALL Z,imm16
              long zk_jump  + (%0000_11_01_11_1111_10<<10)' $CD: CALL imm16
              long zk_immmath + (%10_11_00_0000_1100_0_01_00_0<<10) ' $CE: ADC A,imm8
              long zk_rst                               ' $CF: RST 08h
              long zk_condret+(%0101_11_00_01_1101_0<<10) ' $D0: RET NC
              long zk_poppair+(%01_0<<10)                 ' $D1: POP DE
              long zk_jump  + (%0101_11_01_01_1101_10<<10)' $D2: JP NC,imm16
              long zk_immio + (%00_00<<10)                ' $D3: OUT (imm8),A
              long zk_jump  + (%0000_11_01_01_1101_10<<10)' $D4: CALL NC,imm16
              long zk_pushde+(%0_110<<10)               ' $D5: PUSH DE
              long zk_immmath + (%10_11_00_0000_0011_0_10_00_0<<10) ' $D6: SUB imm8
              long zk_rst                               ' $D7: RST 10h
              long zk_condret+(%0101_11_00_00_1101_0<<10) ' $D8: RET C
              long zk_exx                               ' $D9: EXX
              long zk_jump  + (%0101_11_01_00_1101_10<<10)' $DA: JP C,imm16
              long zk_immio + (%00_11_00<<10)             ' $DB: IN A,(imm8)
              long zk_jump  + (%0000_11_01_00_1101_10<<10)' $DC: CALL C,imm16
              long zk_ixprefix                          ' $DD: IX prefix
              long zk_immmath + (%10_11_00_0000_0011_0_01_00_0<<10) ' $DE: SBC A,imm8
              long zk_rst                               ' $DF: RST 18h
              long zk_condret+(%0101_11_00_01_1011_0<<10) ' $E0: RET PO
              long zk_poppair+(%0011_0<<10)               ' $E1: POP HL
              long zk_jump  + (%0101_11_01_01_1011_10<<10)' $E2: JP PO,imm16
              long zk_ex_hlstk                          ' $E3: EX (SP),HL
              long zk_jump  + (%0000_11_01_01_1011_10<<10)' $E4: CALL PO,imm16
              long zk_pushhl+(%0_10<<10)                  ' E5: PUSH HL
              long zk_immlogic + (%000000_110_1_0<<10)  ' $E6: AND imm8
              long zk_rst                               ' $E7: RST 20h
              long zk_condret+(%0101_11_00_00_1011_0<<10) ' $E8: RET PE
              long zk_jump_indir                          ' $E9: JP (HL)
              long zk_jump  + (%0101_11_01_00_1011_10<<10)' $EA: JP PE,imm16
              long zk_ex_dehl                           ' $EB: EX DE,HL
              long zk_jump  + (%0000_11_01_00_1011_10<<10)' $EC: CALL PE,imm16
              long zk_extprefix + ZK_HLOP               ' $ED: extension prefix
              long zk_immlogic + (%001000_011_1_0<<10)  ' $EE: XOR imm8
              long zk_rst                               ' $EF: RST 28h
              long zk_condret+(%0101_11_00_01_0111_0<<10) ' $F0: RET P
              long zk_poppair+(%00_1111_0<<10)            ' $F1: POP AF
              long zk_jump  + (%0101_11_01_01_0111_10<<10)' $F2: JP P,imm16
              long zk_irqoff                              ' $F3: DI
              long zk_jump  + (%0000_11_01_01_0111_10<<10)' $F4: CALL P,imm16
              long zk_pushaf+(%0_11111_00<<10)            ' $F5: PUSH AF
              long zk_immlogic + (%001000_101_1_0<<10)  ' $F6: OR imm8
              long zk_rst                               ' $F7: RST 30h
              long zk_condret+(%0101_11_00_00_0111_0<<10) ' $F8: RET M
              long zk_hl_to_sp                            ' $F9: LD SP,(HL)
              long zk_jump  + (%0101_11_01_00_0111_10<<10)' $FA: JP M,imm16
              long zk_irqon                               ' $FB: EI
              long zk_jump  + (%0000_11_01_00_0111_10<<10)' $FC: CALL M,imm16
              long zk_iyprefix + (%10<<10)              ' $FD: IY prefix
              long zk_immmath + (%11_00_00_0000_0011_0_10_00_0<<10) ' $FE: CP imm8
              long zk_rst                               ' $FF: RST 38h

              ' PSRAM helper table. Must be at $300
              long $0000
              long $1111
              long $2222
              long $3333
              long $4444
              long $5555
              long $6666
              long $7777
              long $8888
              long $9999
              long $AAAA
              long $BBBB
              long $CCCC
              long $DDDD
              long $EEEE
              long $FFFF


zk_rolla      mov zk_tmp8,zk_accu
zk_shiftop
              andn zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)

              bitl zk_tmp8,#7 wcz  ' left + SRA
              bitz zk_tmp8,#7 addbits 1 ' only SRA
              bitl zk_tmp8,#0 wcz  ' right
              modc _set wc ' only SLL
              modc _clr wc ' only SLA

              testb zk_flags,#ZK_CARRY_BIT wc' only RL/RR
              bitz zk_flags,#ZK_CARRY_BIT

              rcl zk_tmp8,#1 wz   ' left
              bitc zk_tmp8,#8     ' right (not SRA/SRL)
              shr zk_tmp8,#1 wz   ' right

              setq #ZK_XYMASK
              setq #ZK_SIGNXYMASK
              muxq zk_flags,zk_tmp8

        _ret_ mov zk_accu,zk_tmp8

              bitz zk_flags,#ZK_ZERO_BIT
              test zk_tmp8,#$FF wc
        _ret_ bitnc zk_flags,#ZK_OVER_BIT


zk_cio
              mov zk_optmp1,zk_opcode
              and zk_optmp1,#7<<3
              cmp zk_optmp1,#6<<3 wz
              mov zk_tmp8,#0
        if_nz call #\zk_getry
              getbyte zk_ea,zk_debc,#0
zk_immio
              call #\zk_readcode
              mov zk_ea,zk_tmp8

              mov zk_tmp8,zk_accu
              jmp #\zk_portout

              call #\zk_portin
        _ret_ mov zk_accu,zk_tmp8

              and zk_tmp8,#$FF wcz
              bitz zk_flags,#ZK_ZERO_BIT
              bitnc zk_flags,#ZK_OVER_BIT
              andn zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)
              setq #ZK_SIGNXYMASK
              muxq zk_flags,zk_tmp8

              cmp zk_optmp1,#6<<3 wz
        if_z  ret
              jmp #\zk_setry




zk_incdec8
              call #\zk_getry
              mov zk_optmp0,#1
zk_math8
              call #\zk_getrz
zk_immmath
              call #\zk_readcode
              mov zk_optmp0,zk_tmp8
              mov zk_tmp8,zk_accu

              modc _clr wc
              testb zk_flags,#ZK_CARRY_BIT wc

              ' Flag helper gunk
              mov zk_optmp1,zk_tmp8

              addx zk_tmp8,zk_optmp0
              bitl zk_flags,#ZK_NMODE_BIT
              subx zk_tmp8,zk_optmp0
              bith zk_flags,#ZK_NMODE_BIT

              xor zk_optmp1,zk_tmp8
              test zk_tmp8,#$100 wc
              bitc zk_flags,#ZK_CARRY_BIT
              and zk_tmp8,#255 wz

              setq #ZK_SIGNXYMASK
              muxq zk_flags,zk_tmp8
              ' Special nonsense for CP
              setq #ZK_XYMASK
              muxq zk_flags,zk_optmp0

              mov zk_accu,zk_tmp8
              call #\zk_setry

              xor zk_optmp1,zk_optmp0
              bitz zk_flags,#ZK_ZERO_BIT
              testb zk_optmp1,#4 wc
              bitc zk_flags,#ZK_HALF_BIT
              test zk_optmp1,#$180 wc
        _ret_ bitc zk_flags,#ZK_OVER_BIT


zk_neg
              cmp zk_accu,#$80 wz
              bitz zk_flags,#ZK_OVER_BIT
              testb zk_accu,#4 wz
              subr zk_accu,#0 wc
              bitc zk_flags,#ZK_CARRY_BIT
              testb zk_accu,#4 xorz
              bitz zk_flags,#ZK_HALF_BIT
              and zk_accu,#$FF wz
              bitz zk_flags,#ZK_ZERO_BIT
              bith zk_flags,#ZK_NMODE_BIT
              setq #ZK_SIGNXYMASK
        _ret_ muxq zk_flags,zk_accu


zk_cpl
              xor zk_accu,#$FF
              or zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)
              setq #ZK_XYMASK
        _ret_ muxq zk_flags,zk_accu

zk_math16
              modc _clr wc
zk_cmath16
              testb zk_flags,#ZK_CARRY_BIT wc

              getword zk_tmp16,zk_debc,#0 ' get BC
              getword zk_tmp16,zk_debc,#1 ' get DE
              mov zk_tmp16,zk_temphl      ' get HL/I*
              mov zk_tmp16,zk_sp          ' get SP

              mov zk_optmp1,zk_temphl
              xor zk_optmp1,zk_tmp16

              addx zk_temphl,zk_tmp16
              bitl zk_flags,#ZK_NMODE_BIT
              subx zk_temphl,zk_tmp16
              bith zk_flags,#ZK_NMODE_BIT

              xor zk_optmp1,zk_temphl
              and zk_temphl,zk_ffffh wz

              bitz zk_flags,#ZK_ZERO_BIT
              test zk_optmp1,zk_18000h wc
              bitc zk_flags,#ZK_OVER_BIT

              getbyte pa,zk_temphl,#1
              setq #ZK_SIGNXYMASK
              setq #ZK_XYMASK
              muxq zk_flags,pa

              testb zk_optmp1,#12 wc
              bitc zk_flags,#ZK_HALF_BIT
              testb zk_optmp1,#16 wc
              bitc zk_flags,#ZK_CARRY_BIT

              add zk_cycles,#7

              altd zk_hlptr
        _ret_ mov 0-0,zk_temphl


zk_daa
              mov zk_optmp0,#$00
              mov zk_tmp8,zk_accu
              cmpr zk_tmp8,#$99 wc
              testb zk_flags,#ZK_CARRY_BIT orc
        if_c  add zk_optmp0,#$60
              bitc zk_flags,#ZK_CARRY_BIT
              getnib zk_optmp1,zk_tmp8,#0
              cmpr zk_optmp1,#$9 wc
              testb zk_flags,#ZK_HALF_BIT orc
        if_c  add zk_optmp0,#$06
              testb zk_flags,#ZK_NMODE_BIT wc
              sumc zk_accu,zk_optmp0
              and zk_accu,#255 wcz
              bitz zk_flags,#ZK_ZERO_BIT
              bitnc zk_flags,#ZK_OVER_BIT ' Parity?
              testb zk_accu,#4 wc
              testb zk_tmp8,#4 xorc
              bitc zk_flags,#ZK_HALF_BIT
              setq #ZK_SIGNXYMASK
        _ret_ muxq zk_flags,zk_accu


zk_immlogic
              call #\zk_readcode
zk_logic
              call #\zk_getrz

              and zk_accu,zk_tmp8 wcz
              or zk_accu,zk_tmp8 wcz
              xor zk_accu,zk_tmp8 wcz

              bitnc zk_flags,#ZK_OVER_BIT ' parity
              bitz  zk_flags,#ZK_ZERO_BIT
              andn  zk_flags,#(1<<ZK_CARRY_BIT)|(1<<ZK_NMODE_BIT)|(1<<ZK_HALF_BIT)
              bith  zk_flags,#ZK_HALF_BIT ' Only for AND
              setq #ZK_SIGNXYMASK
        _ret_ muxq zk_flags,zk_accu


zk_pushaf
              getbyte zk_tmp16,zk_accu,#0
              rolbyte zk_tmp16,zk_flags,#0

zk_incdec16
              add zk_cycles,#2
zk_pushbc     getword zk_tmp16,zk_debc,#0 ' get BC
zk_pushde     getword zk_tmp16,zk_debc,#1 ' get DE
zk_pushhl     mov zk_tmp16,zk_temphl      ' get HL/I*
              mov zk_tmp16,zk_sp          ' get SP

              jmp #\zk_push16

              add zk_tmp16,#1
              sub zk_tmp16,#1

zk_loadimm16
              call #\zk_readcode16
              mov zk_ea,zk_tmp16   ' for LDs with (imm16)
              call #\zk_read16     ' ^^
              jmp #\zk_write16     ' ^^
zk_poppair
              call #\zk_pop16

        _ret_ setword zk_debc,zk_tmp16,#0 ' set BC
        _ret_ setword zk_debc,zk_tmp16,#1 ' set DE
              altd zk_hlptr
        _ret_ setword zk_sp,zk_tmp16,#0   ' set SP/HL/I*

              getbyte zk_accu,zk_tmp16,#1   ' set A
        _ret_ getbyte zk_flags,zk_tmp16,#0  ' set F




zk_jr         '' JR and DJNZ
              call #\zk_readcode

              getbyte pa,zk_debc,#1
              sub pa,#1 wz
              setbyte zk_debc,pa,#1
              add zk_cycles,#1

              testb zk_flags,#ZK_ZERO_BIT wz
              testb zk_flags,#ZK_CARRY_BIT wz

              modz _nz wz
        if_z  call #\zk_nextop
              ' branch taken
              add zk_cycles,#5
              signx zk_tmp8,#7
        _ret_ add zk_pc,zk_tmp8

zk_exx    '' EXX
              xor zk_debc,zk_altdebc
              xor zk_altdebc,zk_debc
              xor zk_debc,zk_altdebc
              ' Note: not affected by IX/IY substitution
              xor zk_hl,zk_althl
              xor zk_althl,zk_hl
        _ret_ xor zk_hl,zk_althl

zk_ex_dehl    '' EX DE,HL
              ' Note: not affected by IX/IY substitution
              getword zk_optmp0,zk_debc,#1
              setword zk_debc,zk_hl,#1
        _ret_ mov zk_hl,zk_optmp0


zk_ex_af  '' EX AF,AF'
              xor zk_accu,zk_altaccu
              xor zk_altaccu,zk_accu
              xor zk_accu,zk_altaccu
              xor zk_flags,zk_altflags
              xor zk_altflags,zk_flags
        _ret_ xor zk_flags,zk_altflags

zk_ex_hlstk '' EX (SP),HL
              add zk_cycles,#3 ' Should be 19. 19 - 4 - 4*3 = 3
              mov zk_ea,zk_sp
              call #\zk_read16
              altd zk_hlptr
              mov 0-0,zk_tmp16
              mov zk_tmp16,zk_temphl
              jmp #\zk_write16

zk_ld_abs16 '' LD HL,(imm16) and LD (imm16),HL
              call #\zk_readcode16
              mov zk_ea,zk_tmp16

              getword zk_tmp16,zk_debc,#0 ' get BC
              getword zk_tmp16,zk_debc,#1 ' get DE
              mov zk_tmp16,zk_temphl ' get HL/I*
              mov zk_tmp16,zk_sp ' get SP
              jmp #\zk_write16

              call #\zk_read16
        _ret_ setword zk_debc,zk_tmp16,#0 ' set BC
        _ret_ setword zk_debc,zk_tmp16,#1 ' set DE
              altd zk_hlptr
        _ret_ mov zk_sp,zk_tmp16


zk_scf
              modc _clr wc
zk_ccf
              testb zk_flags,#ZK_CARRY_BIT wc
              bitnc zk_flags,#ZK_CARRY_BIT
              bitc  zk_flags,#ZK_HALF_BIT
              bitl  zk_flags,#ZK_NMODE_BIT
              setq #ZK_XYMASK
        _ret_ muxq zk_flags,zk_accu

zk_ld_abs    '' LD A,(imm16) and LD (imm16),A
              call #\zk_readcode16
              mov zk_ea,zk_tmp16
zk_a_and_ptr '' A and (BC)/(DE) ops
              getword zk_ea,zk_debc,#0 ' get BC
              getword zk_ea,zk_debc,#1 ' get DE
              call #\zk_read8
        _ret_ mov zk_accu,zk_tmp8
              mov zk_tmp8,zk_accu
              jmp #\zk_write8

zk_regmove
              push #zk_setry
              jmp #\zk_getrz

zk_loadimm8
              push #zk_setry
              jmp #\zk_readcode


zk_halt
                or      zk_irqenable,#(1<<ZK_HALT_BIT)
        _ret_   decmod  zk_pc,zk_ffffh



              fit $400


DAT ' ZiKore Z80 init code
              orgh
              byte 0[(z80_ram+$800-$)#>0]

zk_init
              cogid pa
              decod pa
              wrword pa,#_zk_cogatn_w

              waitatn ' ROM isn't loaded yet

              setq #495
              rdlong 0,##@zk_cogbase
              setq2 #511
              rdlong 0,##@zk_lutbase

zk_doreset
              'drvl #39 ' DEBUG LED
              debug("Z80 reset START")
              mov zk_pc,#0
              'mov zk_accu,#$FF
              'mov zk_flags,#$FF
              'mov zk_sp,##$FFFF
              mov zk_irqenable,#0
              mov zk_irqhook,#0
              mov zk_nmihook,#0
              mov zk_refresh,#0
              mov zk_refreshhi,#0
              mov zk_ivector,#0
              ' Note: Bank registers do not reset (NEO-ZMC does not have a reset pin)
              call #zk_setnmihook
              call #opn_doreset
              getct zk_lastwait
              debug("Z80 reset DONE",uhex_long($1AF))

              jmp #zk_nextop


CON ' OPNBCog constants


  VOLUME_BALANCE = 0.8 ' Balance between FM/ADPCM and SSG. 1.0 is all OPN2, 0.0 is all SSG


  OVERDRIVE = 1.0

  OPN_VOLUME_MUL = trunc((float($7F7F)*float(1<<14)*VOLUME_BALANCE)/float(4096*4+3840*6+16320)*OVERDRIVE)

  ' EG magic
  EG_CLOCKDIV = 3 ' EG clock divider on real YM2612
  EG_CALLS_PER_SAMPLE = 8 ' EG Task call count
  EG_CALLS_PER_OP = 3.0 ' How many calls to process one OP
  EG_RATEDIV = ((EG_CALLS_PER_OP*4.0*4.0) / float(EG_CALLS_PER_SAMPLE))/float(EG_CLOCKDIV)
  EG_EXTRABITS = 26-10 ' How many extra bits in level variable. MUST BE 16!!!
  EG_FACTOR = EG_RATEDIV * float(1<<EG_EXTRABITS)


  ' SSG stuff
  SSG_OSC_CORR = trunc(float((10<<20))/(4.44/2.0*float(SSG_OVERSAMPLE))) ' ???
  SSG_NOISE_CORR = SSG_OSC_CORR>>1       ' Relative noise frequency
  SSG_ENV_CORR = SSG_OSC_CORR>>4         ' Relative envelope timing

  NOISE_TAP = %1001                      ' LFSR noise constants
  NOISE_MSB = 17                         '

  SSG_OVERSAMPLE = 2

  VOLUME_CORRECTION = (1.0-VOLUME_BALANCE) / float(SSG_OVERSAMPLE) * OVERDRIVE   ' PSG Volume correction value (0.0 - 1.0)
  MAX_AMPLITUDE         = float($7F7F / 3)        ' maxInt32value / numberOfChannels (this makes room for maximum "swing" on all channels)
  AMPLITUDE_DAMP_FACTOR = 0.866'0.75


  ALG_OP1_FB  = 1 << 0 ' modulate with OP1 out (special case for algo 2)
  ALG_USEACCU = 1 << 1 ' modulate with accu
  ALG_CLRACCU = 1 << 2 ' clear accu
  ALG_ADDACCU = 1 << 3 ' add to accu
  ALG_ADDOUT  = 1 << 4 ' add to output

  #0,EG_ATTACK, EG_DECAY,EG_SUSTAIN,EG_RELEASE



  OP_OFFSET = 8   ' Offset from channel to operators == Size of the per-channel registers
  OP_SIZE = 12    ' Size of an operator
  CH_OFFSET = 24  ' Offset from global registers to channels == Size of the global registers
  CH_SIZE   = OP_OFFSET + 4*OP_SIZE ' Total size of a channel
  OPN_SIZE = 4*CH_SIZE + CH_OFFSET  ' Total OPN2 register count

  SSG_SIZE = 16

  ADPA_CH_SIZE = 8
  ADPA_SIZE = ADPA_CH_SIZE*6

  ADPB_SIZE = 12

                     ''
  MATRIX_BASEPIN = 8 '' Uncomment all the places marked with DEBUG_MATRIX and
                     '' 6 of the LEDs become timing indicators that light up when a processing a channel took too long!

CON ' OPNBCog computed constants

  AMPLITUDE_LEVEL_1F = MAX_AMPLITUDE    * VOLUME_CORRECTION
  AMPLITUDE_LEVEL_1E = AMPLITUDE_LEVEL_1F * 1.0
  AMPLITUDE_LEVEL_1D = AMPLITUDE_LEVEL_1E * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_1C = AMPLITUDE_LEVEL_1D * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_1B = AMPLITUDE_LEVEL_1C * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_1A = AMPLITUDE_LEVEL_1B * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_19 = AMPLITUDE_LEVEL_1A * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_18 = AMPLITUDE_LEVEL_19 * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_17 = AMPLITUDE_LEVEL_18 * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_16 = AMPLITUDE_LEVEL_17 * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_15 = AMPLITUDE_LEVEL_16 * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_14 = AMPLITUDE_LEVEL_15 * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_13 = AMPLITUDE_LEVEL_14 * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_12 = AMPLITUDE_LEVEL_13 * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_11 = AMPLITUDE_LEVEL_12 * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_10 = AMPLITUDE_LEVEL_11 * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_0F = AMPLITUDE_LEVEL_10 * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_0E = AMPLITUDE_LEVEL_0F * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_0D = AMPLITUDE_LEVEL_0E * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_0C = AMPLITUDE_LEVEL_0D * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_0B = AMPLITUDE_LEVEL_0C * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_0A = AMPLITUDE_LEVEL_0B * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_09 = AMPLITUDE_LEVEL_0A * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_08 = AMPLITUDE_LEVEL_09 * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_07 = AMPLITUDE_LEVEL_08 * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_06 = AMPLITUDE_LEVEL_07 * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_05 = AMPLITUDE_LEVEL_06 * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_04 = AMPLITUDE_LEVEL_05 * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_03 = AMPLITUDE_LEVEL_04 * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_02 = AMPLITUDE_LEVEL_03 * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_01 = AMPLITUDE_LEVEL_02 * AMPLITUDE_DAMP_FACTOR
  AMPLITUDE_LEVEL_00 = 0.0

EG_RATE_0 = round(0.0*EG_FACTOR)
EG_RATE_1 = round(0.0*EG_FACTOR)
EG_RATE_2 = round(0.000244140625*EG_FACTOR)
EG_RATE_3 = round(0.000244140625*EG_FACTOR)
EG_RATE_4 = round(0.00048828125*EG_FACTOR)
EG_RATE_5 = round(0.00048828125*EG_FACTOR)
EG_RATE_6 = round(0.000732421875*EG_FACTOR)
EG_RATE_7 = round(0.000732421875*EG_FACTOR)
EG_RATE_8 = round(0.0009765625*EG_FACTOR)
EG_RATE_9 = round(0.001220703125*EG_FACTOR)
EG_RATE_10 = round(0.00146484375*EG_FACTOR)
EG_RATE_11 = round(0.001708984375*EG_FACTOR)
EG_RATE_12 = round(0.001953125*EG_FACTOR)
EG_RATE_13 = round(0.00244140625*EG_FACTOR)
EG_RATE_14 = round(0.0029296875*EG_FACTOR)
EG_RATE_15 = round(0.00341796875*EG_FACTOR)
EG_RATE_16 = round(0.00390625*EG_FACTOR)
EG_RATE_17 = round(0.0048828125*EG_FACTOR)
EG_RATE_18 = round(0.005859375*EG_FACTOR)
EG_RATE_19 = round(0.0068359375*EG_FACTOR)
EG_RATE_20 = round(0.0078125*EG_FACTOR)
EG_RATE_21 = round(0.009765625*EG_FACTOR)
EG_RATE_22 = round(0.01171875*EG_FACTOR)
EG_RATE_23 = round(0.013671875*EG_FACTOR)
EG_RATE_24 = round(0.015625*EG_FACTOR)
EG_RATE_25 = round(0.01953125*EG_FACTOR)
EG_RATE_26 = round(0.0234375*EG_FACTOR)
EG_RATE_27 = round(0.02734375*EG_FACTOR)
EG_RATE_28 = round(0.03125*EG_FACTOR)
EG_RATE_29 = round(0.0390625*EG_FACTOR)
EG_RATE_30 = round(0.046875*EG_FACTOR)
EG_RATE_31 = round(0.0546875*EG_FACTOR)
EG_RATE_32 = round(0.0625*EG_FACTOR)
EG_RATE_33 = round(0.078125*EG_FACTOR)
EG_RATE_34 = round(0.09375*EG_FACTOR)
EG_RATE_35 = round(0.109375*EG_FACTOR)
EG_RATE_36 = round(0.125*EG_FACTOR)
EG_RATE_37 = round(0.15625*EG_FACTOR)
EG_RATE_38 = round(0.1875*EG_FACTOR)
EG_RATE_39 = round(0.21875*EG_FACTOR)
EG_RATE_40 = round(0.25*EG_FACTOR)
EG_RATE_41 = round(0.3125*EG_FACTOR)
EG_RATE_42 = round(0.375*EG_FACTOR)
EG_RATE_43 = round(0.4375*EG_FACTOR)
EG_RATE_44 = round(0.5*EG_FACTOR)
EG_RATE_45 = round(0.625*EG_FACTOR)
EG_RATE_46 = round(0.75*EG_FACTOR)
EG_RATE_47 = round(0.875*EG_FACTOR)
EG_RATE_48 = round(1.0*EG_FACTOR)
EG_RATE_49 = round(1.25*EG_FACTOR)
EG_RATE_50 = round(1.5*EG_FACTOR)
EG_RATE_51 = round(1.75*EG_FACTOR)
EG_RATE_52 = round(2.0*EG_FACTOR)
EG_RATE_53 = round(2.5*EG_FACTOR)
EG_RATE_54 = round(3.0*EG_FACTOR)
EG_RATE_55 = round(3.5*EG_FACTOR)
EG_RATE_56 = round(4.0*EG_FACTOR)
EG_RATE_57 = round(5.0*EG_FACTOR)
EG_RATE_58 = round(6.0*EG_FACTOR)
EG_RATE_59 = round(7.0*EG_FACTOR)
EG_RATE_60 = round(8.0*EG_FACTOR)
EG_RATE_61 = round(8.0*EG_FACTOR)
EG_RATE_62 = round(8.0*EG_FACTOR)
EG_RATE_63 = round(8.0*EG_FACTOR)

DAT ' OPNBCog init code
              orgh
'===========================================================
'                Assembly OPN2 emulator
'===========================================================
opn_init
              'debug    (udec(leftp,rightp),uhex_long(sampleRate))
              'jmp #$
              loc      ptrb,#@opn_cogbase
              setq     #502-1
              rdlong   0,ptrb
              loc      ptrb,#@opn_sinexp_tab
              setq2    #255
              rdlong   $000,ptrb
              loc      ptrb,#@opn_lutbase
              setq2    #255
              rdlong   $100,ptrb

              'rdlong opn_arg2,#_clkf
              'qdiv opn_arg2,##OPN_SAMPLE_RATE
              mov opn_leftp,#AUDIO_LEFT
              mov opn_rightp,#AUDIO_RIGHT
              'getqx opn_sampleRate
              mov opn_sampleRate,##CLK_MULTIPLIER*3*4*6*6
              test opn_sampleRate,#255 wz
        if_z  mov opn_arg1,##P_DAC_75R_2V|P_OE|P_DAC_DITHER_PWM
        if_nz mov opn_arg1,##P_DAC_75R_2V|P_OE|P_DAC_DITHER_RND


              fltl     opn_leftp
              fltl     opn_rightp
              wrpin    opn_arg1,opn_leftp
              wrpin    opn_arg1,opn_rightp
              wxpin    opn_sampleRate,opn_leftp
              wxpin    opn_sampleRate,opn_rightp
              wypin    opn_dac_center,opn_leftp
              wypin    opn_dac_center,opn_rightp

              'debug(` TERM EGterm pos 10 10 title 'Envelope Parameters' SIZE 50 26 TEXTSIZE 15 UPDATE)
              'debug(` TERM OPterm pos 600 10 title 'Operator Parameters' SIZE 32 26 TEXTSIZE 15 UPDATE)
              'debug(` TERM CHterm pos 600 670 title 'Channel Parameters' SIZE 32 8 TEXTSIZE 20 UPDATE)
              'debug(` SCOPE Escope pos 0 650 title 'Envelope Scope' SIZE 512 256 TEXTSIZE 20)

              mov pb,##opn_eg_start

              rdlong adpcm_a_base,#_exr_adpa_base
              shr adpcm_a_base,#4
              rdlong adpcm_b_base,#_exr_adpb_base
              shr adpcm_b_base,#4


              'drvl #38 addpins 1 ' DEBUG LED

              drvh     opn_leftp
              drvh     opn_rightp

              jmp #\opn_mainLoop


DAT ' OPNBCog COG/LUT resident code


              org 0
'===========================================================
'                Main Loop
'===========================================================
opn_cogbase
opn_mainLoop

              call #opn_adpcm_a_run
              call #opn_adpcm_a_run
              mov opn_outl,adpa_outl
              mov opn_outr,adpa_outr
              call #opn_adpcm_b_run

              call #ssg_run

              ' reset register pointer
              rdfast #0,OPN_Address
              ' reload globals
              rflong gl_unused_alev_lfo_bfreq

              rflong gl_ch3_kcodes_mode

              rfbyte ch3_op1_detune
              rfbyte ch3_op2_detune
              rfbyte ch3_op3_detune

              rfbyte opn_tempValue ' skip pad byte

              rfword gl_ch3_op1freq
              rfword gl_ch3_op2freq
              rflong gl_ch3_op3freq_afreq
              rflong gl_keyon

              ' reset some counters
              mov opn_current_slot,#0
              mov fb_1to2_alti,fb_1to2_alti_base
              mov op_levels_alti,op_levels_alti_base

              ' handle key-ons
              mov opn_tempValue,gl_keyon
              xor opn_tempValue,prev_keyon
              and opn_tempValue,gl_keyon
              mov prev_keyon,gl_keyon
              or pending_keyon,opn_tempValue


              ' Update LFO
              getnib opn_arg1,gl_unused_alev_lfo_bfreq,#4 ' get LFO register
              bitl opn_arg1,#3 wcz ' LFO enable bit
        if_nc mov lfo_phase,#0
        if_nc mov lfo_subcount,#0
        if_nc mov lfo_am,#0
        if_nc mov lfo_fm,#0
        if_nc waitx #12*2 ' equivalent timing for stability
        if_nc jmp #.nolfo

              altgb opn_arg1,#lfo_rate_tbl
              getbyte opn_arg1
              decmod lfo_subcount,opn_arg1 wc
        if_c  incmod lfo_phase,#$7F
              mov lfo_am,lfo_phase
              testb lfo_am,#6 wz
        if_z  xor lfo_am,#$7F
              shl lfo_am,#1+2 ' +1 so we can use SHR to compute ch_am, +2 because when we add to the attenutation, it is already 0..$FFF
              mov lfo_fm,lfo_phase
              shr lfo_fm,#2
              testb lfo_phase,#3+2 wc
              and lfo_fm,#7
        if_c  xor lfo_fm,#7
              shl lfo_fm,#3 ' so we can just OR with the sensitivity to get a table index
              ' No LFO sign here, just test lfo_phase bit 4+2

.nolfo
              ' Update timers
              testb gl_ch3_kcodes_mode,#24+0 wz ' Timer A load flag
              incmod timerA_count,timerA_max wc
    if_nz_or_c getword timerA_count,gl_ch3_op3freq_afreq,#1
              testb gl_ch3_kcodes_mode,#24+2 andc ' Timer A enable flag
    if_c_and_z wrbyte #1,#opn_timerAflag
              testb gl_ch3_kcodes_mode,#24+1 wz ' Timer B load flag
              incmod timerB_count,timerB_max wc
    if_nz_or_c getbyte timerB_count,gl_unused_alev_lfo_bfreq,#3
    if_nz_or_c shl timerB_count,#4
              testb gl_ch3_kcodes_mode,#24+3 andc ' Timer B enable flag
    if_c_and_z wrbyte #1,#opn_timerBflag



              'debug(`CHterm UPDATE 0 9 ' P A  FRQ          K'  13)
              'debug(`OPterm UPDATE 0 9 '   D  L M'  13)

opn_chLoop    ' Channel loop

              mov ch_out,#0 ' reset output accu

              calld eg_return,pb wcz
              calld eg_return,pb wcz
              nop
              {
              ' Run some extra tasks.
              jmprel opn_current_ch
              jmp #opn_task_done ' No extra task for Channel 1 (already reloads globals and runs LFO)
              jmp #psg_run   ' Run PSG in Channel 2
              jmp #opn_task_done ' No extra task for Channel 3 (special mode takes all the cycles)
              jmp #psg_run   ' Run PSG in Channel 4
              jmp #psg_load  ' Load PSG in Channel 5
              jmp #psg_run   ' Run PSG in Channel 6}

opn_task_done
              ' load channel registers

              rflong ch_freq_algo_pan
              rfword opn_tempValue ' kcode (don't care)
              rfword ch_am_enable
              'debug(`CHterm 'CH `(current_ch)' 9 '`uhex_long_(ch_freq_algo_pan) `uhex_long_(ch_keycode)' 13)




              ' Compute LFO AM for this channel
              mov ch_lfoam_level,lfo_am
              getnib opn_arg1,ch_freq_algo_pan,#7
              and opn_arg1,#3
              mov opn_arg2,#7
              shr opn_arg2,opn_arg1
              shr ch_lfoam_level,opn_arg2

              ' Prepare LFO FM for this channel
              getnib opn_arg1, ch_freq_algo_pan,#6
              or opn_arg1,lfo_fm ' FM mul table index
              altgw opn_arg1,#lfo_fm_mul_tbl
              getword ch_lfofm_muls
              testb lfo_phase,#4+2 wc
              negc ch_lfofm_muls

              ' lookup algorithm bitfield
              getbyte opn_arg1,ch_freq_algo_pan,#2
              and opn_arg1,#7
              add opn_arg1,#algo_tbl-512
              rdlut ch_algobits,opn_arg1

              mov oploop_ptr,#opn_opLoop
              sets opn_detune_selfmod,#op_detune

              cmp opn_current_ch,#2-1 wz ' On YM2610, it's actually CH2
              testb gl_ch3_kcodes_mode,#24+6 andz
        if_nz callpa ch_freq_algo_pan,#opn_eval_freq
        if_nz jmp #opn_opLoop

              ' Handle CH3 special mode
              mov oploop_ptr,#opn_opLoop_ch3special
              sets opn_detune_selfmod,#ch3_op1_detune - 1
opn_opLoop_ch3special
              altd opn_current_op,#gl_ch3_op1freq
              callpa 0-0,#opn_eval_freq

              add opn_detune_selfmod,#1


opn_opLoop    ' Operator loop


              ' load operator registers
              rfword op_mul_tl
              rfword op_detune
              rflong opn_tempValue
              rflong opn_tempValue

              'debug(`OPterm 'OP `(current_slot)' 9 '`uhex_long_(op_mul_tl_dtc)' 13)

              'debug(udec(current_ch,current_op,current_slot))


              mov phase_mod,#0
              test ch_algobits,#ALG_USEACCU wc
        if_c  add phase_mod,op_accu

'{
              tjz opn_current_op,#opn_op1fb ' Feedback code is outlined. Saves 6 cycles per chan, yay!
              test ch_algobits,#ALG_OP1_FB wc ' Algorithm 2 needs to read the feedback reg....
        if_c  alts opn_current_ch,#ch_feedback1
        if_c  add phase_mod,0-0
opn_op1fbdone
                 '}

              mov op_actfreq,ch_actfreq

              ' detune
              testb  op_mul_tl,#4+2 wc ' detune sign
opn_detune_selfmod
              sumc op_actfreq,op_detune

              ' multiply
              getnib opn_arg1,op_mul_tl,#0
              shl opn_arg1,#1 wz
        if_z  mov opn_arg1,#1
              mul op_actfreq,opn_arg1

              ' get phase and accumulate
              alts opn_current_slot,#op_phase
              mov cur_phase,0-0
              altd opn_current_slot,#op_phase
              add 0-0,op_actfreq

              ' Add modulation
              shr cur_phase,#10
              add cur_phase,phase_mod

              ' Compute attenuation level
              getbyte opn_tempValue,op_mul_tl,#1 ' get TL
              shl opn_tempValue,#5
              alti op_levels_alti,#%100_111_000
              add cur_level,opn_tempValue

              ' Add LFO AM
              testb ch_am_enable,opn_current_op wc
        if_c  add cur_level,ch_lfoam_level

              fle  cur_level,opn_conFFF

              ' Lookup phase in logsin ROM
              testb     cur_phase,#8 wz
              testb     cur_phase,#9 wc
              and       cur_phase,#255
        if_z  xor       cur_phase,#255
              rdlut     opn_tempValue,cur_phase
              getword   opn_tempValue,opn_tempValue,#0 ' get sin value!!
              add       opn_tempValue,cur_level ' apply volume!!
              'fle       tempValue,maxexp  '< impossible, so don't bother

              ' Convert to linear
              getbyte   opn_tempValue2,opn_tempValue,#1
              getbyte   opn_tempValue,opn_tempValue,#0
              rdlut     opn_tempValue,opn_tempValue
              getword   opn_arg1,opn_tempValue,#1 ' get exp value
              shr       opn_arg1,opn_tempValue2
              ' C still is bit 9 of phase...


              'debug(uhex_long(cur_level),udec(opn_current_slot))
              nop

              ' Do stuff with the output
              tjnz opn_current_op,#.notfbset
              altd opn_current_ch,#ch_feedback1
              negc 0-0, opn_arg1
.notfbset
              test ch_algobits,#ALG_CLRACCU wz
        if_nz negc op_accu,#0
              test ch_algobits,#ALG_ADDACCU wz
        if_nz sumc op_accu,opn_arg1

              'shr   opn_arg1,#4 ' Reduce to 9 bit (sign bit still in C)

              test ch_algobits,#ALG_ADDOUT wz
        if_nz sumc ch_out,opn_arg1

              ' clamp (has to be per-op! i think...)
              fles ch_out,opn_clamp_max
              fges ch_out,opn_clamp_min

              add opn_current_slot,#1
              shr ch_algobits,#8
              incmod opn_current_op,#4-1 wc
        if_nc jmp oploop_ptr


              ' Debug: channel mute
              testb opn_muteChannels,opn_current_ch wc
        if_c  mov ch_out,#0

              muls ch_out,##OPN_VOLUME_MUL
              sar ch_out,#14

              testb     ch_freq_algo_pan,#31 wc ' left pan bit
        if_c  add opn_outl,ch_out
              testb     ch_freq_algo_pan,#30 wc ' right pan bit
        if_c  add opn_outr,ch_out

              incmod opn_current_ch,#4-1 wc
        if_nc jmp #opn_chLoop

              call #do_output ' <--- DAC pin write here

              'debug(udec_reg_array(#opn_rightp+1,#16))
              jmp #opn_mainLoop



opn_op1fb
              ' OP1 feedback handling
              ' down here for speed
              alts opn_current_ch,#ch_feedback2
              mov opn_tempValue,0-0
              alts opn_current_ch,#ch_feedback1
              add opn_tempValue,0-0
              alti fb_1to2_alti ,#%000_111_111
              mov 0-0,0-0

              getbyte opn_tempValue2,ch_freq_algo_pan,#2
              shr opn_tempValue2,#3 wz
              shl opn_tempValue,opn_tempValue2
              sar opn_tempValue,#10-1
        if_nz add phase_mod,opn_tempValue

              jmp #opn_op1fbdone

opn_eval_freq
              ' Compute LFO FM for this channel
              getword ch_lfofm_offset,pa,#0
              shr ch_lfofm_offset,#4
              and ch_lfofm_offset,#$7F ' top 7 bits of fnum

              muls ch_lfofm_offset,ch_lfofm_muls
              shr ch_lfofm_offset,#7+2+1


              ' Get frequency
              getword ch_actfreq,pa,#0 ' get frequency
              add ch_actfreq,ch_lfofm_offset ' Apply LFO FM
              zerox ch_actfreq,#10 ' just fnum

              getword opn_arg1,pa,#0
              shr opn_arg1,#11 ' get fblock

              shl ch_actfreq,opn_arg1
        _ret_ shr ch_actfreq,#2' got actual base frequency




' Parameters
' ----------
opn_muteChannels        long 0'%11_11
opn_leftp               long 0
opn_rightp              long 0

              'long 0[10] ' The elder gods ask for this to be here.
opn_sampleRate          long 0
opn_lpf_scas            long $1000
' Constants
' ---------
opn_dac_center          long $7F80
opn_conFFF              long $FFF
opn_clamp_min           long -4096
opn_clamp_max           long 4095
timerA_max              long $3FF
timerB_max              long $FFF ' timer B is prescaled by 16
'opn_maxexp             long $1FFF
eg_max                  long $3FF << EG_EXTRABITS
ssg_eg_threshold        long $200 << EG_EXTRABITS
ssg_envSubValue         long SSG_ENV_CORR
ssg_oscSubValue         long SSG_OSC_CORR
ssg_noiseSubValue       long SSG_NOISE_CORR
ssg_half_period         long $00008000

OPN_Address             long @opn_regbase


' intialized temp
' ---------------
opn_current_ch          long 0
opn_current_op          long 0
opn_current_slot        long 0 ' OP+CH*4
eg_slot                 long 0
opn_filter_left         long 0
opn_filter_right        long 0
adpa_outl               long 0
adpa_outr               long 0
adpa_accl               long 0
adpa_accr               long 0


' OPN2 internal state
' -------------------
op_phase                long 0[4*4]
eg_state_b              byte EG_RELEASE[4*4]
eg_levels               long ($3FF << EG_EXTRABITS)[4*4] ' EG internal levels (0 to eg_max)
op_levels               long $FFF[4*4] ' Effective levels (0 to FFF).
                        long 0[(4-($&3))&3] ' align buffer
eg_levelbuffer          long ($3FF << EG_EXTRABITS)[4] ' temp buffer for EG. must be 4-aligned
ch_feedback1            long 0[4] ' Feedback buffer stage 1 \ OP1 output is continously clocked through
ch_feedback2            long 0[4] ' Feedback buffer stage 2 / and the average of both stages is used for modultation
prev_keyon              long 0
pending_keyon           long 0
ssgeg_repeat            long 0
ssgeg_invert            long 0
lfo_phase               long 0
lfo_subcount            long 0
timerA_count            long 0
timerB_count            long 0

' ALTI base values
' ----------------
fb_1to2_alti_base       long (ch_feedback2<<9) + ch_feedback1
eg_levb_alti_base       long (eg_levelbuffer<<19) + (op_levels<<9) + eg_levelbuffer
op_levels_alti_base long (cur_level<<19) + (op_levels<<9)
eg_levb_write           long %111_000_111__111_000_000
eg_levb_transfer        long %111_000_111__000_111_111

' SSG internal state
' ------------------
ssg_OscValues       long 0
ssg_noiseValue      long $ffff
ssg_noisePeriod     long 0
ssg_phaseAccumulator1 long 0
ssg_phaseAccumulator2 long 0
ssg_phaseAccumulator3 long 0
ssg_phaseAccumulatorN long 0
ssg_envCounter      long 1
ssg_envelopeValue   long 0
ssg_envelopeInc     long 1
ssg_envHoldLevel    long 0

' ADPCM internal state
' --------------------
adpcm_active        long 0
adpa_which          long 0
adpb_nextblock      long -1


eg_rate_mantissa_tbl byte
byte EG_RATE_0>>(((encod EG_RATE_0)-7)#>0)
byte EG_RATE_1>>(((encod EG_RATE_1)-7)#>0)
byte EG_RATE_2>>(((encod EG_RATE_2)-7)#>0)
byte EG_RATE_3>>(((encod EG_RATE_3)-7)#>0)
byte EG_RATE_4>>(((encod EG_RATE_4)-7)#>0)
byte EG_RATE_5>>(((encod EG_RATE_5)-7)#>0)
byte EG_RATE_6>>(((encod EG_RATE_6)-7)#>0)
byte EG_RATE_7>>(((encod EG_RATE_7)-7)#>0)
byte EG_RATE_8>>(((encod EG_RATE_8)-7)#>0)
byte EG_RATE_9>>(((encod EG_RATE_9)-7)#>0)
byte EG_RATE_10>>(((encod EG_RATE_10)-7)#>0)
byte EG_RATE_11>>(((encod EG_RATE_11)-7)#>0)
byte EG_RATE_12>>(((encod EG_RATE_12)-7)#>0)
byte EG_RATE_13>>(((encod EG_RATE_13)-7)#>0)
byte EG_RATE_14>>(((encod EG_RATE_14)-7)#>0)
byte EG_RATE_15>>(((encod EG_RATE_15)-7)#>0)
byte EG_RATE_16>>(((encod EG_RATE_16)-7)#>0)
byte EG_RATE_17>>(((encod EG_RATE_17)-7)#>0)
byte EG_RATE_18>>(((encod EG_RATE_18)-7)#>0)
byte EG_RATE_19>>(((encod EG_RATE_19)-7)#>0)
byte EG_RATE_20>>(((encod EG_RATE_20)-7)#>0)
byte EG_RATE_21>>(((encod EG_RATE_21)-7)#>0)
byte EG_RATE_22>>(((encod EG_RATE_22)-7)#>0)
byte EG_RATE_23>>(((encod EG_RATE_23)-7)#>0)
byte EG_RATE_24>>(((encod EG_RATE_24)-7)#>0)
byte EG_RATE_25>>(((encod EG_RATE_25)-7)#>0)
byte EG_RATE_26>>(((encod EG_RATE_26)-7)#>0)
byte EG_RATE_27>>(((encod EG_RATE_27)-7)#>0)
byte EG_RATE_28>>(((encod EG_RATE_28)-7)#>0)
byte EG_RATE_29>>(((encod EG_RATE_29)-7)#>0)
byte EG_RATE_30>>(((encod EG_RATE_30)-7)#>0)
byte EG_RATE_31>>(((encod EG_RATE_31)-7)#>0)
byte EG_RATE_32>>(((encod EG_RATE_32)-7)#>0)
byte EG_RATE_33>>(((encod EG_RATE_33)-7)#>0)
byte EG_RATE_34>>(((encod EG_RATE_34)-7)#>0)
byte EG_RATE_35>>(((encod EG_RATE_35)-7)#>0)
byte EG_RATE_36>>(((encod EG_RATE_36)-7)#>0)
byte EG_RATE_37>>(((encod EG_RATE_37)-7)#>0)
byte EG_RATE_38>>(((encod EG_RATE_38)-7)#>0)
byte EG_RATE_39>>(((encod EG_RATE_39)-7)#>0)
byte EG_RATE_40>>(((encod EG_RATE_40)-7)#>0)
byte EG_RATE_41>>(((encod EG_RATE_41)-7)#>0)
byte EG_RATE_42>>(((encod EG_RATE_42)-7)#>0)
byte EG_RATE_43>>(((encod EG_RATE_43)-7)#>0)
byte EG_RATE_44>>(((encod EG_RATE_44)-7)#>0)
byte EG_RATE_45>>(((encod EG_RATE_45)-7)#>0)
byte EG_RATE_46>>(((encod EG_RATE_46)-7)#>0)
byte EG_RATE_47>>(((encod EG_RATE_47)-7)#>0)
byte EG_RATE_48>>(((encod EG_RATE_48)-7)#>0)
byte EG_RATE_49>>(((encod EG_RATE_49)-7)#>0)
byte EG_RATE_50>>(((encod EG_RATE_50)-7)#>0)
byte EG_RATE_51>>(((encod EG_RATE_51)-7)#>0)
byte EG_RATE_52>>(((encod EG_RATE_52)-7)#>0)
byte EG_RATE_53>>(((encod EG_RATE_53)-7)#>0)
byte EG_RATE_54>>(((encod EG_RATE_54)-7)#>0)
byte EG_RATE_55>>(((encod EG_RATE_55)-7)#>0)
byte EG_RATE_56>>(((encod EG_RATE_56)-7)#>0)
byte EG_RATE_57>>(((encod EG_RATE_57)-7)#>0)
byte EG_RATE_58>>(((encod EG_RATE_58)-7)#>0)
byte EG_RATE_59>>(((encod EG_RATE_59)-7)#>0)
byte EG_RATE_60>>(((encod EG_RATE_60)-7)#>0)
byte EG_RATE_61>>(((encod EG_RATE_61)-7)#>0)
byte EG_RATE_62>>(((encod EG_RATE_62)-7)#>0)
byte EG_RATE_63>>(((encod EG_RATE_63)-7)#>0)

eg_rate_shift_tbl byte
byte ((encod EG_RATE_0)-7)#>0
byte ((encod EG_RATE_1)-7)#>0
byte ((encod EG_RATE_2)-7)#>0
byte ((encod EG_RATE_3)-7)#>0
byte ((encod EG_RATE_4)-7)#>0
byte ((encod EG_RATE_5)-7)#>0
byte ((encod EG_RATE_6)-7)#>0
byte ((encod EG_RATE_7)-7)#>0
byte ((encod EG_RATE_8)-7)#>0
byte ((encod EG_RATE_9)-7)#>0
byte ((encod EG_RATE_10)-7)#>0
byte ((encod EG_RATE_11)-7)#>0
byte ((encod EG_RATE_12)-7)#>0
byte ((encod EG_RATE_13)-7)#>0
byte ((encod EG_RATE_14)-7)#>0
byte ((encod EG_RATE_15)-7)#>0
byte ((encod EG_RATE_16)-7)#>0
byte ((encod EG_RATE_17)-7)#>0
byte ((encod EG_RATE_18)-7)#>0
byte ((encod EG_RATE_19)-7)#>0
byte ((encod EG_RATE_20)-7)#>0
byte ((encod EG_RATE_21)-7)#>0
byte ((encod EG_RATE_22)-7)#>0
byte ((encod EG_RATE_23)-7)#>0
byte ((encod EG_RATE_24)-7)#>0
byte ((encod EG_RATE_25)-7)#>0
byte ((encod EG_RATE_26)-7)#>0
byte ((encod EG_RATE_27)-7)#>0
byte ((encod EG_RATE_28)-7)#>0
byte ((encod EG_RATE_29)-7)#>0
byte ((encod EG_RATE_30)-7)#>0
byte ((encod EG_RATE_31)-7)#>0
byte ((encod EG_RATE_32)-7)#>0
byte ((encod EG_RATE_33)-7)#>0
byte ((encod EG_RATE_34)-7)#>0
byte ((encod EG_RATE_35)-7)#>0
byte ((encod EG_RATE_36)-7)#>0
byte ((encod EG_RATE_37)-7)#>0
byte ((encod EG_RATE_38)-7)#>0
byte ((encod EG_RATE_39)-7)#>0
byte ((encod EG_RATE_40)-7)#>0
byte ((encod EG_RATE_41)-7)#>0
byte ((encod EG_RATE_42)-7)#>0
byte ((encod EG_RATE_43)-7)#>0
byte ((encod EG_RATE_44)-7)#>0
byte ((encod EG_RATE_45)-7)#>0
byte ((encod EG_RATE_46)-7)#>0
byte ((encod EG_RATE_47)-7)#>0
byte ((encod EG_RATE_48)-7)#>0
byte ((encod EG_RATE_49)-7)#>0
byte ((encod EG_RATE_50)-7)#>0
byte ((encod EG_RATE_51)-7)#>0
byte ((encod EG_RATE_52)-7)#>0
byte ((encod EG_RATE_53)-7)#>0
byte ((encod EG_RATE_54)-7)#>0
byte ((encod EG_RATE_55)-7)#>0
byte ((encod EG_RATE_56)-7)#>0
byte ((encod EG_RATE_57)-7)#>0
byte ((encod EG_RATE_58)-7)#>0
byte ((encod EG_RATE_59)-7)#>0
byte ((encod EG_RATE_60)-7)#>0
byte ((encod EG_RATE_61)-7)#>0
byte ((encod EG_RATE_62)-7)#>0
byte ((encod EG_RATE_63)-7)#>0

lfo_rate_tbl byte 108, 77, 71, 67, 62, 44, 8, 5

lfo_fm_mul_tbl word
word   2 ' Sens 0 val 0
word   2 ' Sens 1 val 0
word   2 ' Sens 2 val 0
word   2 ' Sens 3 val 0
word   2 ' Sens 4 val 0
word   2 ' Sens 5 val 0
word   4 ' Sens 6 val 0
word   8 ' Sens 7 val 0
word   2 ' Sens 0 val 1
word   2 ' Sens 1 val 1
word   2 ' Sens 2 val 1
word   2 ' Sens 3 val 1
word   2 ' Sens 4 val 1
word   2 ' Sens 5 val 1
word   4 ' Sens 6 val 1
word   8 ' Sens 7 val 1
word   2 ' Sens 0 val 2
word   2 ' Sens 1 val 2
word   2 ' Sens 2 val 2
word  33 ' Sens 3 val 2
word  33 ' Sens 4 val 2
word  65 ' Sens 5 val 2
word 130 ' Sens 6 val 2
word 260 ' Sens 7 val 2
word   2 ' Sens 0 val 3
word   2 ' Sens 1 val 3
word  33 ' Sens 2 val 3
word  33 ' Sens 3 val 3
word  65 ' Sens 4 val 3
word  96 ' Sens 5 val 3
word 192 ' Sens 6 val 3
word 384 ' Sens 7 val 3
word   2 ' Sens 0 val 4
word  33 ' Sens 1 val 4
word  33 ' Sens 2 val 4
word  65 ' Sens 3 val 4
word  65 ' Sens 4 val 4
word 129 ' Sens 5 val 4
word 258 ' Sens 6 val 4
word 516 ' Sens 7 val 4
word   2 ' Sens 0 val 5
word  33 ' Sens 1 val 5
word  33 ' Sens 2 val 5
word  65 ' Sens 3 val 5
word  65 ' Sens 4 val 5
word 129 ' Sens 5 val 5
word 258 ' Sens 6 val 5
word 516 ' Sens 7 val 5
word   2 ' Sens 0 val 6
word  33 ' Sens 1 val 6
word  65 ' Sens 2 val 6
word  96 ' Sens 3 val 6
word  96 ' Sens 4 val 6
word 160 ' Sens 5 val 6
word 320 ' Sens 6 val 6
word 640 ' Sens 7 val 6
word   2 ' Sens 0 val 7
word  33 ' Sens 1 val 7
word  65 ' Sens 2 val 7
word  96 ' Sens 3 val 7
word 129 ' Sens 4 val 7
word 192 ' Sens 5 val 7
word 384 ' Sens 6 val 7
word 768 ' Sens 7 val 7

adpa_stepTable
word   16,  17,   19,   21,   23,   25,   28
word   31,  34,   37,   41,   45,   50,   55
word   60,  66,   73,   80,   88,   97,  107
word  118, 130,  143,  157,  173,  190,  209
word  230, 253,  279,  307,  337,  371,  408
word  449, 494,  544,  598,  658,  724,  796
word  876, 963, 1060, 1166, 1282, 1411, 1552
word 0 ' padding

adpa_adaptionTable
byte 0,0,0,0,3,6,8,10

adpb_adaptionTable
byte 57,57,57,57,77,102,128,153

ssg_amplitudeTable  word trunc(AMPLITUDE_LEVEL_00)
                    word trunc(AMPLITUDE_LEVEL_01)
                    word trunc(AMPLITUDE_LEVEL_02)
                    word trunc(AMPLITUDE_LEVEL_03)
                    word trunc(AMPLITUDE_LEVEL_04)
                    word trunc(AMPLITUDE_LEVEL_05)
                    word trunc(AMPLITUDE_LEVEL_06)
                    word trunc(AMPLITUDE_LEVEL_07)
                    word trunc(AMPLITUDE_LEVEL_08)
                    word trunc(AMPLITUDE_LEVEL_09)
                    word trunc(AMPLITUDE_LEVEL_0A)
                    word trunc(AMPLITUDE_LEVEL_0B)
                    word trunc(AMPLITUDE_LEVEL_0C)
                    word trunc(AMPLITUDE_LEVEL_0D)
                    word trunc(AMPLITUDE_LEVEL_0E)
                    word trunc(AMPLITUDE_LEVEL_0F)
                    word trunc(AMPLITUDE_LEVEL_10)
                    word trunc(AMPLITUDE_LEVEL_11)
                    word trunc(AMPLITUDE_LEVEL_12)
                    word trunc(AMPLITUDE_LEVEL_13)
                    word trunc(AMPLITUDE_LEVEL_14)
                    word trunc(AMPLITUDE_LEVEL_15)
                    word trunc(AMPLITUDE_LEVEL_16)
                    word trunc(AMPLITUDE_LEVEL_17)
                    word trunc(AMPLITUDE_LEVEL_18)
                    word trunc(AMPLITUDE_LEVEL_19)
                    word trunc(AMPLITUDE_LEVEL_1A)
                    word trunc(AMPLITUDE_LEVEL_1B)
                    word trunc(AMPLITUDE_LEVEL_1C)
                    word trunc(AMPLITUDE_LEVEL_1D)
                    word trunc(AMPLITUDE_LEVEL_1E)
                    word trunc(AMPLITUDE_LEVEL_1F)

ssg_mask1tab
                    long 513
                    long 1026
                    long 2052
ssg_mask2tab
                    long 4104
                    long 8200
                    long 16392


opn_arg1                res 1
opn_arg2                res 1
opn_arg3                res 1
opn_arg4                res 1

' OPN2 global/channel regs
' ------------------------
gl_unused_alev_lfo_bfreq res 1
gl_ch3_kcodes_mode        res 1
' \/ The order of these 4 is important (CH3 special mode) \/
gl_ch3_op1freq            res 1
gl_ch3_op2freq            res 1
gl_ch3_op3freq_afreq      res 1
ch_freq_algo_pan          res 1

gl_keyon                  res 1
ch_am_enable              res 1

' OPN2 current operator regs
' --------------------------
op_mul_tl               res 1


' OPN2 current EG operator regs
' -----------------------------
opn_tempValue3          res 1 ' here so it can get overwritten when the EG reads operator data
eg_ar_dr_sr_rr          res 1
eg_rs_sl_ssgeg          res 1

' OPN2 temporary
' --------------
op_accu                 res 1
ch_out                  res 1
opn_outl                res 1
opn_outr                res 1
ch_algobits             res 1
cur_level               res 1
eg_oplevel              res 1
eg_opstate              res 1
ch_actfreq              res 1
op_actfreq              res 1
cur_phase               res 1
phase_mod               res 1
eg_pending_keyon        res 1
eg_keyon                res 1
eg_op_keyonoff          res 1
eg_kcode                res 1
lfo_am                  res 1
lfo_fm                  res 1
ch_lfoam_level          res 1
ch_lfofm_offset         res 1
eg_rate                 res 1
fb_1to2_alti            res 1
eg_levb_alti            res 1
op_levels_alti          res 1
oploop_ptr              res 1
ch_lfofm_muls           res 1
' \/ order of these is important
ch3_op1_detune          res 1
ch3_op2_detune          res 1
ch3_op3_detune          res 1
op_detune               res 1

' SSG temporary
' -------------
ssgregs1            res  1
ssgregs2            res  1
ssgregs3            res  1
ssgregs4            res  1
ssg_envelopePeriod  res  1
ssg_envelopeShape   res  1
ssg_envelopeAmplitude res 1
ssg_freq            res 1
ssg_amplitude       res 1

' ADPCM temporary
' ---------------
adpcm_a_base        res 1
adpcm_b_base        res 1
adpa_ptr            res 6
adpa_sample         res 6/2
adpa_stepi          res 8/4
adpb_ptr            res 1
adpb_phase          res 1
adpb_step           res 1
adpb_oldsample      res 1
adpb_newsample      res 1


' other gunk
' ----------
eg_return           res  1
opn_tempValue       res  1
opn_tempValue2      res  1


                    fit 502 ' Doesn't use interrupts, so their addresses may be reused

'===========================================================
'    LUT stuff
'===========================================================
                        org $300
opn_lutbase
''
''
''
algo_tbl byte
'' Algorithm 0:
''
'' 1->2->3->4->
''
byte ALG_CLRACCU + ALG_ADDACCU
byte ALG_USEACCU + ALG_CLRACCU + ALG_ADDACCU
byte ALG_USEACCU + ALG_CLRACCU + ALG_ADDACCU
byte ALG_USEACCU + ALG_ADDOUT
'' Algorithm 1:
''
'' 1-+
''   +->3->4->
'' 2-+
''
byte ALG_CLRACCU + ALG_ADDACCU
byte ALG_ADDACCU
byte ALG_USEACCU + ALG_CLRACCU + ALG_ADDACCU
byte ALG_USEACCU + ALG_ADDOUT
'' Algorithm 2:
''
'' 1----+
''      +->4->
'' 2->3-+
''
byte ALG_CLRACCU
byte ALG_CLRACCU + ALG_ADDACCU
byte ALG_USEACCU + ALG_CLRACCU + ALG_ADDACCU
byte ALG_USEACCU + ALG_ADDOUT + ALG_OP1_FB
'' Algorithm 3:
''
'' 1->2-+
''      +->4->
'' 3----+
''
byte ALG_CLRACCU + ALG_ADDACCU
byte ALG_USEACCU + ALG_CLRACCU + ALG_ADDACCU
byte ALG_ADDACCU
byte ALG_USEACCU + ALG_ADDOUT
'' Algorithm 4:
''
'' 1->2-+
''      +->
'' 3->4-+
''
byte ALG_CLRACCU + ALG_ADDACCU
byte ALG_USEACCU + ALG_ADDOUT
byte ALG_CLRACCU + ALG_ADDACCU
byte ALG_USEACCU + ALG_ADDOUT
'' Algorithm 5:
''
''   +->2-+
'' 1-+->3-+->
''   +->4-+
''
byte ALG_CLRACCU + ALG_ADDACCU
byte ALG_USEACCU + ALG_ADDOUT
byte ALG_USEACCU + ALG_ADDOUT
byte ALG_USEACCU + ALG_ADDOUT
'' Algorithm 6:
''
'' 1->2-+
''    3-+->
''    4-+
''
byte ALG_CLRACCU + ALG_ADDACCU
byte ALG_USEACCU + ALG_ADDOUT
byte ALG_ADDOUT
byte ALG_ADDOUT
'' Algorithm 7:
'' 1-+
'' 2-+
'' 3-+->
'' 4-+
''
byte ALG_ADDOUT
byte ALG_ADDOUT
byte ALG_ADDOUT
byte ALG_ADDOUT
''
''
''

'===========================================================
'    Output current sample
'===========================================================
do_output

#ifdef AUDIO_MIX_MONO
              add       opn_outl,opn_outr
              sar       opn_outl,#1
              fges      opn_outl,##-$7F80
              fles      opn_outl,##+$7F80
              mov       opn_outr,opn_outl
#else
              fges      opn_outl,##-$7F80
              fles      opn_outl,##+$7F80
              fges      opn_outr,##-$7F80
              fles      opn_outr,##+$7F80
#endif

              neg       opn_arg1,opn_filter_left
              neg       opn_arg2,opn_filter_right

              add       opn_arg1,opn_outl
              add       opn_arg2,opn_outr

              ' apply low-pass filter and mix PSG
              scas      opn_arg1,opn_lpf_scas
              add       opn_filter_left,0-0

              scas      opn_arg2,opn_lpf_scas
              add       opn_filter_right,0-0

              mov       opn_arg1,opn_dac_center
              mov       opn_arg2,opn_dac_center
              add       opn_arg1,opn_filter_left
              add       opn_arg2,opn_filter_right


              { ' DEBUG LED
              testp    opn_rightp wc
        if_c  drvh #38 'Took too long!
              '}

              ' wait for DAC cycle
              testp    opn_rightp wc
  if_nc       jmp #$-1
              wypin      opn_arg1,opn_leftp
       _ret_  wypin      opn_arg2,opn_rightp


'===========================================================
'    Envelope Generator (EG) section
'===========================================================
opn_eg_start
              mov ptrb,OPN_Address
              add ptrb,#CH_OFFSET
              mov eg_levb_alti,eg_levb_alti_base

              'debug(`EGterm UPDATE 0 9 ' R S  D A   SSG  K L  `uhex_long_(OPN_Address)' 13)
opn_eg_chloop
              rdbyte eg_kcode,ptrb[4]
              add ptrb,#OP_OFFSET
              mov eg_pending_keyon,pending_keyon ' buffer this to avoid partially keying a channel
              mov eg_keyon,gl_keyon

opn_eg_loop

              ' load parameters
              setq #2
              rdlong opn_tempValue3,ptrb++


              calld pb,eg_return

              'mov eg_ar_dr_sr_rr,##$3F_10_1A_31

              ' get current level/state
              alts eg_slot,#eg_levels
              mov eg_oplevel,0-0
              altgb eg_slot,#eg_state_b
              getbyte eg_opstate

              'setbyte eg_rs_sl_ssgeg,#0,#2

              ' Handle SSG-EG
              cmp eg_oplevel,ssg_eg_threshold wc ' SSG-EG only runs when level is over $200...
              testb eg_rs_sl_ssgeg,#16 + 3 wz ' and of course only when it's actually on
   if_c_or_nz waitx #2*(9-1) ' Stablize timing
   if_c_or_nz jmp #.no_ssg_eg

              testb eg_rs_sl_ssgeg,#16 + 0 wc ' Is hold mode? 1/3/5/7 (otherwise, continuous mode)
              ' Handle invert state
        if_c  testb eg_rs_sl_ssgeg,#16 + 2 wz
        if_nc testb ssgeg_invert,eg_slot wz
              testb eg_rs_sl_ssgeg,#16 + 1 xorz
              bitz ssgeg_invert,eg_slot

              cmp eg_opstate,#EG_ATTACK wz
              ' Handle hold
         if_c testb eg_rs_sl_ssgeg,#16 + 1 orz
  if_c_and_nz mov eg_oplevel,eg_max
              ' Handle restart
 if_nc_and_nz cmp eg_opstate,#EG_RELEASE wz
 if_nc_and_nz bith ssgeg_repeat,eg_slot

.no_ssg_eg


              testb eg_pending_keyon,eg_slot wc
              testb ssgeg_repeat,eg_slot orc
              testb eg_keyon,eg_slot wz
              rczl eg_op_keyonoff ' bit 0 is now keyon state and bit 1 is now pending keyon
         if_c bitl pending_keyon,eg_slot


              calld pb,eg_return


              ' if key on/off
        if_c  mov eg_opstate,#EG_ATTACK
        if_c  altd eg_slot,#op_phase
        if_c  mov 0-0,#0 ' reset phase
        if_nz mov eg_opstate,#EG_RELEASE


              ' Set SSG-EG invert on actual key-on only
        if_c  bitl ssgeg_repeat,eg_slot wcz

        if_nz  testb eg_rs_sl_ssgeg,#16 + 3 wc
        if_nz  testb eg_rs_sl_ssgeg,#16 + 2 andc
        if_nz  bitc ssgeg_invert,eg_slot

              ' Handle release for SSG-EG
              cmp eg_opstate,#EG_RELEASE wz
              testb eg_rs_sl_ssgeg,#16 + 3 andz
        if_z  mov eg_oplevel,eg_max
        if_z  bitl ssgeg_invert,eg_slot


              ' transition ATTACK to DECAY when max amplitude reached
              cmp eg_opstate,#EG_ATTACK wz
        if_z  cmp eg_oplevel,#0 wz
        if_z  mov eg_opstate,#EG_DECAY


              ' Handle attenuation change

              ' get rate
              altgb eg_opstate,#eg_ar_dr_sr_rr
              getbyte eg_rate

              'debug(udec(eg_slot,eg_opstate),uhex_long(eg_ar_dr_sr_rr))
              'debug(`EGterm 'OP `(eg_slot)' 9 '`uhex_long_(eg_ar_dr_sr_rr) `uhex_long_(eg_sl_rs_ssgeg) `uhex_byte_(eg_opstate) `uhex_long_(eg_oplevel)' 13)

              ' Apply rate scaling
              cmp eg_rate,#0 wz
              mov opn_tempValue,eg_kcode
              shr opn_tempValue,eg_rs_sl_ssgeg
        if_nz add eg_rate,opn_tempValue
              fle eg_rate,#63

              altgb eg_rate,#eg_rate_mantissa_tbl
              getbyte opn_arg2
              altgb eg_rate,#eg_rate_shift_tbl
              getbyte opn_arg3

              cmp eg_opstate,#EG_ATTACK wz
        if_nz jmp #.notattack

              ' Handle Attack
              cmp eg_rate,#62 wc ' Rates > 62 force level to 0 on keyon, but don't do anything else
              testb eg_op_keyonoff,#1 wz
  if_nc_and_z mov eg_oplevel,#0

              ' Weird attenuation-decreasement algorithm
              getword opn_tempValue,eg_oplevel,#1
              bitnot opn_tempValue,#0 addbits 15
              muls opn_tempValue,opn_arg2
              sar opn_tempValue,#4
              shl opn_tempValue,opn_arg3
        if_c  add eg_oplevel,opn_tempValue
              fges eg_oplevel,#0

              jmp #.adsrjoin
.notattack    ' Handle Decay/Sustain/Release
              shl opn_arg2,opn_arg3
              testb eg_rs_sl_ssgeg,#16+3 wz ' SSG-EG enabled?
              cmp eg_oplevel,ssg_eg_threshold wc ' SSG-EG only applies in top half of envelope..
         if_z shl opn_arg2,#2 ' ..and quadruples the rate
   if_nz_or_c add eg_oplevel,opn_arg2
.adsrjoin
              calld pb,eg_return

              fle eg_oplevel,eg_max


              ' transition DECAY TO SUSTAIN when sustain level reached
              cmp eg_opstate,#EG_DECAY wz
              getbyte opn_tempValue,eg_rs_sl_ssgeg,#1
              shl opn_tempValue,#5+EG_EXTRABITS
              cmp eg_oplevel,opn_tempValue wc
  if_nc_and_z mov eg_opstate,#EG_SUSTAIN
  if_nc_and_z mov eg_oplevel,opn_tempValue ' Hack! Force sustain level if we shot past


              ' save level/state
              altd eg_slot,#eg_levels
              mov 0-0,eg_oplevel
              altsb eg_slot,#eg_state_b
              setbyte eg_opstate


              ' Make effective level
              testb ssgeg_invert,eg_slot wc
        if_c  subr eg_oplevel,ssg_eg_threshold
              fges eg_oplevel,#0
              shr eg_oplevel,#EG_EXTRABITS - 2
              ' Save effective level for later copying
              alti eg_levb_alti,eg_levb_write
              mov 0-0,eg_oplevel


              incmod eg_slot,#16-1 wc
              test eg_slot,#3 wz
        if_nz jmp #opn_eg_loop

              ' copy effective levels for one channel all at once to avoid glitches
              alti eg_levb_alti,eg_levb_transfer
              mov 0-0,0-0
              alti eg_levb_alti,eg_levb_transfer
              mov 0-0,0-0
              alti eg_levb_alti,eg_levb_transfer
              mov 0-0,0-0
              alti eg_levb_alti,eg_levb_transfer
              mov 0-0,0-0

        if_c  jmp #opn_eg_start
              jmp #opn_eg_chloop

'===========================================================
' Read all AY registers from hub memory and convert
' them to more convenient representations.
'===========================================================
ssg_run

              mov ptra,OPN_Address
              add ptra,#OPN_SIZE
              setq      #4-1
              rdlong    ssgregs1,ptra
              getbyte   ssg_noisePeriod, ssgregs2,#2        ' reg 6
              and       ssg_noisePeriod, #$1f
              fge       ssg_noisePeriod, #2
              shl       ssg_noisePeriod, #20
              getbyte   ssg_envelopePeriod, ssgregs4,#0     ' reg 12
              rolbyte   ssg_envelopePeriod, ssgregs3,#3     ' reg 11
              shl       ssg_envelopePeriod, #16         wz
        if_z  mov       ssg_envelopePeriod, ssg_half_period ' 0 == half the period of 1
              getbyte   opn_arg1, ssgregs2,#3               ' reg 7
              setd      ssg_oscValues, opn_arg1

              mov opn_arg3,#SSG_OVERSAMPLE
ssg_sampleloop
'===========================================================
' Calculate AY samples channel 1-3
'===========================================================
              mov      ch_out, #0                          '  DC offset
'-----------------------------------------------------------
'        Envelope shaping -> envelopeAmplitude
'-----------------------------------------------------------
Envelope      sub      ssg_envCounter, ssg_envSubValue   wc ' Handle envelope incrementation
  if_c        add      ssg_envCounter, ssg_envelopePeriod
  if_c        add      ssg_envelopeValue, ssg_envelopeInc
              fle      ssg_envCounter, ssg_envelopePeriod
'-----------------------------------------------------------
              getbyte   ssg_envelopeShape, ssgregs4,#1      ' reg 13
              test     ssg_envelopeShape, #16            wz ' Handle envelope "reset bit" ( Extra bit added by Ahle2 )
  if_z        neg      ssg_envelopeValue, #0
  if_z        mov      ssg_envelopeInc, #1
  if_z        mov      ssg_envCounter, ssg_envelopePeriod
  if_z        or       ssg_envelopeShape, #16
  if_z        wrbyte   ssg_envelopeShape, ptra[13/1]        '<-IMPORTANT, sets bit 5 ("reset bit") of envelope shape register in hub ram
  if_z        bith     ssgregs4,#12         ' fix for oversampling
'-----------------------------------------------------------
              test     ssg_envelopeShape, #8             wc ' Handle envelope continue = 0
              test     ssg_envelopeShape, #4             wz
 if_nc_and_z  mov      ssg_envelopeShape, #9
 if_nc_and_nz mov      ssg_envelopeShape, #15
'-----------------------------------------------------------
              test     ssg_envelopeShape, #2             wz ' Sets the envelope hold level
              muxz     ssg_envHoldLevel, #31                '
'-----------------------------------------------------------
              test     ssg_envelopeValue, #32            wz ' Check if > 31
              test     ssg_envelopeShape, #1             wc ' Check hold bit
  if_nz_and_c mov      ssg_envelopeInc, #0                  ' Hold envelope
  if_nz_and_c mov      ssg_envelopeValue, ssg_envHoldLevel  '
'-----------------------------------------------------------
  if_nz       test     ssg_envelopeShape, #2             wc ' Check and handle envelope alternation
  if_nz_and_c neg      ssg_envelopeInc, ssg_envelopeInc
  if_nz_and_c add      ssg_envelopeValue, ssg_envelopeInc
'-----------------------------------------------------------
              mov      ssg_envelopeAmplitude, ssg_envelopeValue
              test     ssg_envelopeShape, #4             wc ' Check and handle envelope invertion (attack)
  if_nc       xor      ssg_envelopeAmplitude, #31           '(Move Value or ~Value to envelopeAmplitude)

'-----------------------------------------------------------
'     Waveform shaping noise -> bit 3 of oscValues
'-----------------------------------------------------------
Noise1        sub      ssg_phaseAccumulatorN, ssg_noiseSubValue wc ' Noise generator
  if_nc       jmp      #.nonoisetick
              add      ssg_phaseAccumulatorN, ssg_noisePeriod
              test     ssg_noiseValue, #NOISE_TAP        wc
              bitc     ssg_noiseValue, #NOISE_MSB
              shr      ssg_noiseValue, #1                wc
  if_c        xor      ssg_oscValues, #8

.nonoisetick
              mov opn_tempValue,#2
.chanlp
              altgw    opn_tempValue,#ssgregs1
              getword  ssg_freq
              shl      ssg_freq, #20
              altgb    opn_tempValue,#ssgregs3
              getbyte  ssg_amplitude

              test     ssg_amplitude, #16                wz ' Selects envelope or fixed amplitude
  if_nz       mov      ssg_amplitude, ssg_envelopeAmplitude ' depending on bit 5 of amplitude register 1
  if_z        shl      ssg_amplitude,#1
              and      ssg_amplitude,#31

              cmp      ssg_freq, ##10<<20                wc
              altd     opn_tempValue,#ssg_phaseAccumulator1
  if_nc       sub      0-0, ssg_oscSubValue              wc ' Square wave generator
              altd     opn_tempValue,#ssg_phaseAccumulator1
  if_c        add      0-0, ssg_freq
  if_c        bitnot   ssg_oscValues, opn_tempValue

              alts     opn_tempValue,#ssg_mask1tab
              test     ssg_oscValues, 0-0                wz
              alts     opn_tempValue,#ssg_mask2tab
  if_nz       test     ssg_oscValues, 0-0                wz
              altgw    ssg_amplitude,#ssg_amplitudeTable
              getword  ssg_amplitude
              sumnz    ch_out, ssg_amplitude                ' Tone on/off, Noise on/off

              djnf opn_tempValue,#.chanlp

              add opn_outl,ch_out
              add opn_outr,ch_out
        _ret_ djnz opn_arg3,#ssg_sampleloop


fit 1024

DAT ' OPNBCog hub resident code

              orgh

opn_adpcm_b_run
              'ret
              loc ptra,#adpb_regbase

              setq #1
              rdlong opn_arg3,ptra[0] ' get repeat flag, pan flags, start/end address

              rdlong opn_tempValue3,#adpcm_pollbox+6*4 wz
              'modcz _clr,_nz wcz ' If outstanding memory rq, ignore commands
        {if_x0} rdbyte opn_tempValue,ptra[8] wcz ' NZ-> got command. NC-> key-on, C-> dump
        'if_x0 drvh #38
        if_x0 wrbyte #0,ptra[8]
        if_x0 bitl adpcm_active,#7
        if_10 neg adpb_nextblock,#1
        if_00 getword adpb_nextblock,opn_arg3,#1
        if_00 shl adpb_nextblock,#4

              tjf adpb_nextblock,#.norq
              tjnz opn_tempValue3,#.nosample ' Stall if previous request isn't done
              add adpb_nextblock,adpcm_b_base
              'debug(ubin_byte(adpcm_active),uhex_long(adpb_nextblock,adpcm_b_base,adpb_ptr,adpb_phase))
              wrlong adpb_nextblock,#adpcm_pollbox+6*4
              testbn adpcm_active,#7 wc ' C if key-on
        if_nc neg adpb_nextblock,#1
        if_c  bith adpcm_active,#7
        if_c  jmp #.key_on
.norq

              rdword opn_tempValue,ptra[##9]
              'debug(uhex_long(adpb_phase,opn_tempValue))
              add adpb_phase,opn_tempValue
              cmpsub adpb_phase,##$1_0000 wc
        if_nc jmp #.nosample

              mov adpb_oldsample,adpb_newsample

              '' Get sample and decode
              mov opn_tempValue,adpb_ptr
              and opn_tempValue,#63
              shr opn_tempValue,#1 wc ' odd/even nibble
              add opn_tempValue,##adpcm_buffers+6*32
              rdbyte opn_tempValue,opn_tempValue
        if_nc shr opn_tempValue,#4
              bitl opn_tempValue,#3 addbits 7 wcz
              altgb opn_tempValue,#adpb_adaptionTable
              getbyte opn_tempValue3
              shl opn_tempValue,#1
              add opn_tempValue,#1

              mul opn_tempValue,adpb_step
              shr opn_tempValue,#3
              sumc adpb_newsample,opn_tempValue
              fges adpb_newsample,##-32768
              fles adpb_newsample,##+32767

              mul adpb_step,opn_tempValue3
              shr adpb_step,#6
              fge adpb_step,#127
              fle adpb_step,##24576

              '' Increment ptr and check end address
              add adpb_ptr,#1
              getword opn_tempValue,opn_arg4,#0
              shl opn_tempValue,#9
              sub opn_tempValue,adpb_ptr wz
              testbn opn_arg3,#4 wc ' Check repeat flag
        if_11 bitl adpcm_active,#7 wcz ' will keep both bits set if we're actually active
        if_11 wrbyte #0,ptra[6] ' set end flag
    if_not_01 jmp #.norep_retrigger
.key_on       ' If we enter with NC, we repeat. If we enter with C, we key-on...
        'if_c  wrbyte #1,ptra[6] ' clear end flag
              mov adpb_oldsample,#0
              mov adpb_newsample,#0
              mov adpb_phase,#0 ' Doing this for repeat feel wrong..
              getword adpb_ptr,opn_arg3,#1
              shl adpb_ptr,#9
              mov adpb_step,#127
              mov opn_tempValue,#0 ' for safety
.norep_retrigger
              testb adpcm_active,#7 wc
              ' For repeat, we actually need to check one block early for the load
              cmp opn_tempValue,#32 wz
        if_11 getword adpb_nextblock,opn_arg3,#1
        if_11 shl adpb_nextblock,#4
        if_11 skip #%1111

              test adpb_ptr,#31 wz
        if_11 mov adpb_nextblock,adpb_ptr
        if_11 shr adpb_nextblock,#5
        if_11 add adpb_nextblock,#1

.nosample
              ' Linear interpolation (slightly low quality for speends)
              getword opn_tempValue,adpb_phase,#0
              shr opn_tempValue,#2
              mov opn_tempValue2,adpb_oldsample
              scas adpb_newsample,opn_tempValue
              adds opn_tempValue2,0-0
              scas adpb_oldsample,opn_tempValue
              subs opn_tempValue2,0-0

              rdbyte opn_tempValue,ptra[$B]
              muls opn_tempValue2,opn_tempValue
              sar opn_tempValue2,#8+1
              muls opn_tempValue2,##OPN_VOLUME_MUL
              sar opn_tempValue2,#14

              testb adpcm_active,#7 wz
              testb opn_arg3,#7+8 wc
        if_11 add opn_outl,opn_tempValue2
              testb opn_arg3,#6+8 wc
        if_11 add opn_outr,opn_tempValue2

              ret


opn_adpcm_a_run
              'ret
              '' Remarkably similar to YM2608's rhythm generator
              '' Called twice per sample
              'debug(ubin_byte(adpcm_active))
              mov ptra,adpa_which
              mul ptra,#ADPA_CH_SIZE
              add ptra,##adpa_regbase

              mov opn_arg4,adpa_which
              mul opn_arg4,#4
              add opn_arg4,#@adpcm_pollbox
              rdlong opn_tempValue3,opn_arg4 wz
              modcz _clr,_nz wcz ' If outstanding memory rq, ignore commands
        if_x0 rdbyte opn_tempValue,ptra[0] wcz ' NZ-> got command. NC-> key-on, C-> dump
        'if_x0 drvh #38
        if_x0 wrbyte #0,ptra[0]
        if_x0 bitnc adpcm_active,adpa_which

              modcz _nc_and_nz,_z wcz ' Set C if key-on

        'if_c  wrbyte #1,ptra[2] ' clear end flag
        if_nc altgw adpa_which,#adpa_sample
              getword opn_arg1,opn_conFFF,#1
        if_nc altgb adpa_which,#adpa_stepi
              getbyte opn_arg2,opn_conFFF,#3
              alts adpa_which,#adpa_ptr
              mov opn_arg3,0-0
        if_c  rdword opn_arg3,ptra[2] ' start address
        if_c  shl opn_arg3,#9 ' 16*16 byte blocks + nibble index

              test opn_arg3,#31 wz ' beginning of new block: time to request the next one
        if_z  tjnz opn_tempValue3,#.rqwait ' oh no, previous request hasn't come through...
              ' Generate new request
              mov opn_tempValue,opn_arg3
              shr opn_tempValue,#5 ' get block id
        if_nc add opn_tempValue,#1 ' if not first block, we actually want the next one
              add opn_tempValue,adpcm_a_base
              testb adpcm_active,adpa_which andz
        if_z  wrlong opn_tempValue,opn_arg4
        if_c  jmp #.rqwait ' if first block, have to wait for request to come through

              ' Get sample from buffer
              mov opn_tempValue,adpa_which
              shl opn_tempValue,#6
              setq #63
              muxq opn_tempValue,opn_arg3
              shr opn_tempValue,#1 wc ' odd even nibble flag
              add opn_tempValue,##adpcm_buffers
              rdbyte opn_tempValue,opn_tempValue
        if_nc shr opn_tempValue,#4
              bitl opn_tempValue,#3 addbits 7 wcz
              altgb opn_tempValue,#adpa_adaptionTable
              getbyte opn_tempValue3
              shl opn_tempValue,#1
              add opn_tempValue,#1
              ' Do decode
              altgw opn_arg2,#adpa_stepTable
              getword opn_tempValue2
              'debug(udec(adpa_which,opn_tempValue2,opn_tempValue,opn_arg2))
              mul opn_tempValue2,opn_tempValue wz ' Force NZ
              shr opn_tempValue2,#3
              sumc opn_arg1,opn_tempValue2
              subs opn_arg2,#1
              adds opn_arg2,opn_tempValue3
              fges opn_arg2,#0
              fles opn_arg2,#48
.rqwait
              ' Increment pointer
              wrnz opn_tempValue ' 0 if we're waiting, 1 if not
              'mov opn_tempValue,#1
              altr adpa_which,#adpa_ptr
              add opn_arg3,opn_tempValue ' Note that arg3 is not actually incremented

              signx opn_arg1,#11

              altsb adpa_which,#adpa_stepi
              setbyte opn_arg2
              altsw adpa_which,#adpa_sample
              setword opn_arg1

              ' Do mixing
              rdbyte opn_arg2,ptra[1] ' pan/level
              not opn_tempValue,opn_arg2
              and opn_tempValue,#$1F
              getbyte opn_tempValue2,gl_unused_alev_lfo_bfreq,#1
              xor opn_tempValue2,#$3F
              add opn_tempValue,opn_tempValue2
              fle opn_tempValue,#63

              mov opn_tempValue2,opn_tempValue
              and opn_tempValue2,#7
              subr opn_tempValue2,#15
              muls opn_arg1,opn_tempValue2
              mov opn_tempValue2,opn_tempValue
              shr opn_tempValue2,#3
              and opn_tempValue2,#7
              sar opn_arg1,opn_tempValue2
              sar opn_arg1,#1 ' ???
              muls opn_arg1,##OPN_VOLUME_MUL
              sar opn_arg1,#14
              testb adpcm_active,adpa_which wz
              testb opn_arg2,#7 wc
        if_11 add adpa_accl,opn_arg1
              testb opn_arg2,#6 wc
        if_11 add adpa_accr,opn_arg1

              ' Check sample end
              rdword opn_tempValue,ptra[3]
              shl opn_tempValue,#9
              add opn_tempValue,#1
            {
            cmp opn_tempValue,opn_arg3 wc
      if_nc_or_nz jmp #.nodebug
            debug("OPN Hazard! ",udec(adpa_which),uhex_long(opn_tempValue,opn_arg3))
            cogstop #5
            jmp #$
.nodebug    '}
              xor opn_tempValue,opn_arg3
        if_z  zerox opn_tempValue,#19+1 wz ' only bottom 20 bits are used for compare (previous Z is active bit)
        if_z  bitl adpcm_active,adpa_which
        if_z  wrbyte #0,ptra[2] ' set end flag

              incmod adpa_which,#5 wc
        if_c  mov adpa_outl,adpa_accl
        if_c  mov adpa_outr,adpa_accr
        if_c  mov adpa_accl,#0
        if_c  mov adpa_accr,#0

              ret


DAT ' OPNBCog I/O interface
        orgh


opn_statusread
              mov zk_tmp8,#0

              testb zk_ea,#0 wz
              testb zk_ea,#1 wc
        if_01 jmp #.ssg
        if_10 jmp #.adpcm_end
        if_11 ret wcz

              rdword zk_memtmp0 ,#opn_timerAflag ' timer B in high byte
              testb zk_memtmp0,#0 wc
              bitc zk_tmp8,#0
              testb zk_memtmp0,#8 wc
              bitc zk_tmp8,#1
              ret wcz

.ssg
              rdword zk_memtmp1,#opn_register
              cmp zk_memtmp1,#$10 wc
              loc ptrb,#ssg_regbase
              add ptrb,zk_memtmp1
        if_b  rdbyte zk_tmp8,ptrb
              ret wcz

.adpcm_end
              '' TODO
              'mov zk_tmp8,#$FF
              loc ptrb,#adpa_regbase+3*ADPA_CH_SIZE + 2
              rdword zk_memtmp0,ptrb[-3*ADPA_CH_SIZE/2] wz
              bitz zk_tmp8,#0
              rdword zk_memtmp0,ptrb[-2*ADPA_CH_SIZE/2] wz
              bitz zk_tmp8,#1
              rdword zk_memtmp0,ptrb[-1*ADPA_CH_SIZE/2] wz
              bitz zk_tmp8,#2
              rdword zk_memtmp0,ptrb[ 0*ADPA_CH_SIZE/2] wz
              bitz zk_tmp8,#3
              rdword zk_memtmp0,ptrb[ 1*ADPA_CH_SIZE/2] wz
              bitz zk_tmp8,#4
              rdword zk_memtmp0,ptrb[ 2*ADPA_CH_SIZE/2] wz
              bitz zk_tmp8,#5

              rdword zk_memtmp0,##adpb_regbase+6 wz
              bitz zk_tmp8,#7

              ret wcz



opn_portwrite
              and zk_tmp8,#255 ' make sure we only get one byte
              testb zk_ea,#0 wc
        if_nc jmp #.address
              loc ptrb,#opn_regbase
              rdword zk_memtmp1,#opn_register
              'debug("OPNB write: ",uhex_word(zk_memtmp1),uhex_byte(zk_tmp8))
              testb zk_ea,#1 wc
              testb zk_memtmp1,#8 wz
    if_z_ne_c ret wcz
              cmp zk_memtmp1,#$130 wc
        if_11 jmp #.adpcm_a
              cmp zk_memtmp1,#$28 wz
        if_e  jmp #.keyon ' Only on first port!
              cmp zk_memtmp1,#$30 wc
        if_b  jmp #.common_reg ' Only on first port!

              ' All the channel registers use bits 0..1 and the port to select them
              mov zk_memtmp3,zk_memtmp1
              and zk_memtmp3,#3 wcz
    if_not_10 ret wcz
              sub zk_memtmp3,#1
              testb zk_memtmp1,#8 wc
        if_c  add zk_memtmp3,#2 ' got channel no
              mov pa,zk_memtmp3
              mul pa,#CH_SIZE
              add ptrb,pa
              add ptrb,#CH_OFFSET
              '' Also precompute operator no
              mov zk_memtmp2,zk_memtmp1
              rev zk_memtmp2
              shr zk_memtmp2,#28
              and zk_memtmp2,#3

              getnib pa,zk_memtmp1,#1
              cmp pa,#$C wc
        if_c  cmpsub pa,#$3 wc
        if_nc ret wcz
              mul pa,#16
              jmprel pa
.opn_chreg_base
              orgh .opn_chreg_base + ($3-3)*16*4 '' $3x MUL/DT
              mov zk_memtmp1,zk_memtmp2
              mul zk_memtmp1,#OP_SIZE
              add ptrb,zk_memtmp1
              wrbyte zk_tmp8,ptrb[OP_OFFSET+0] ' write MUL/DT
              jmp #.update_detune_faster

              orgh .opn_chreg_base + ($4-3)*16*4 '' $4x TL
              and zk_tmp8,#$7f
              mul zk_memtmp2,#OP_SIZE
              add ptrb,zk_memtmp2
              wrbyte zk_tmp8,ptrb[OP_OFFSET+1] ' write TL
              ret wcz

              orgh .opn_chreg_base + ($5-3)*16*4 '' $5x AR/RS
              mul zk_memtmp2,#OP_SIZE
              add ptrb,zk_memtmp2

              mov zk_memtmp0,zk_tmp8
              and zk_memtmp0,#$1F
              shl zk_memtmp0,#1
              wrbyte zk_memtmp0,ptrb[OP_OFFSET+4] ' write AR
              shr zk_tmp8,#6
              xor zk_tmp8,#3
              wrbyte zk_tmp8,ptrb[OP_OFFSET+8] ' write RS
              ret wcz

              orgh .opn_chreg_base + ($6-3)*16*4 '' $6x DR/AM
              ' Set AM bit
              rdbyte zk_memtmp0,ptrb[6]
              testb zk_tmp8,#7 wc
              bitc zk_memtmp0,zk_memtmp2
              wrbyte zk_memtmp0,ptrb[6]

              mul zk_memtmp2,#OP_SIZE
              add ptrb,zk_memtmp2
              and zk_tmp8,#$1F
              shl zk_tmp8,#1
              wrbyte zk_tmp8,ptrb[OP_OFFSET+5] ' write DR
              ret wcz
              orgh .opn_chreg_base + ($7-3)*16*4 '' $7x SR
              mul zk_memtmp2,#OP_SIZE
              add ptrb,zk_memtmp2
              and zk_tmp8,#$1F
              shl zk_tmp8,#1
              wrbyte zk_tmp8,ptrb[OP_OFFSET+6] ' write SR
              ret wcz

              orgh .opn_chreg_base + ($8-3)*16*4 '' $8x RR/SL
              mul zk_memtmp2,#OP_SIZE
              add ptrb,zk_memtmp2

              getnib zk_memtmp0,zk_tmp8,#0
              shl zk_memtmp0,#2
              add zk_memtmp0,#2
              wrbyte zk_memtmp0,ptrb[OP_OFFSET+7] ' write RR
              getnib zk_memtmp0,zk_tmp8,#1
              cmp zk_memtmp0,#$F wz
        if_z  mov zk_memtmp0,#$10
              wrbyte zk_memtmp0,ptrb[OP_OFFSET+9] ' write SL
              ret wcz

              orgh .opn_chreg_base + ($9-3)*16*4 '' $9x SSG-EG
              mul zk_memtmp2,#OP_SIZE
              add ptrb,zk_memtmp2
              wrbyte zk_tmp8,ptrb[OP_OFFSET+10] ' write SSG-EG
              ret wcz

              orgh .opn_chreg_base + ($A-3)*16*4 '' $Ax Frequency

              testb zk_memtmp1,#3 wc
        if_c  jmp #.ch3extrafreq
              loc pa,#opn_frqhi
              add pa,zk_memtmp3
              testb zk_memtmp1,#2 wc
        if_nc jmp #.lofreq
              wrbyte zk_tmp8,pa
              ret wcz

              orgh .opn_chreg_base + ($B-3)*16*4 '' $Bx ALGO/FB/PAN/LFOsens
              testbn zk_memtmp1,#3 wc
        if_nc ret wcz ' unused register $B8..$BF

              testb zk_memtmp1,#2 wc ' NC = algo/FB register; C = pan/LFOsens
        if_nc and zk_tmp8,#$3F
        if_c  and zk_tmp8,#$F7
        if_nc wrbyte zk_tmp8,ptrb[2]
        if_c  wrbyte zk_tmp8,ptrb[3]
              ret wcz

              ' --------------------------------

.lofreq
              rdbyte zk_memtmp0,pa
              rolbyte zk_memtmp0,zk_tmp8,#0
              'debug("got freq for ch",udec_(zk_memtmp3),uhex_word(zk_memtmp0))
              zerox zk_memtmp0,#13
              wrword zk_memtmp0,ptrb[0]
              ' Compute kcode
              mov zk_tmp8,zk_memtmp0
              shr zk_tmp8,#11-2
              shr zk_memtmp0,#7
              and zk_memtmp0,#$F
              sub zk_memtmp0,#6
              fges zk_memtmp0,#0
              fles zk_memtmp0,#3
              setq #%11100
              muxq zk_memtmp0,zk_tmp8
              wrbyte zk_memtmp0,ptrb[4]

              mov zk_memtmp2,#3
.dtlp
              call #.update_detune
              djnf zk_memtmp2,#.dtlp
              ret wcz



.ch3extrafreq
              test zk_memtmp1,#$100 wc
        if_c  ret wcz
              mov zk_memtmp2,zk_memtmp3
              decmod zk_memtmp2,#2 ' get operator N
              debug("CH3 special write to ",uhex_byte(zk_memtmp1)," is operator ",udec(zk_memtmp2))

              loc pa,#opn_frqhi+4
              add pa,zk_memtmp2
              testb zk_memtmp1,#2 wc
        if_c  wrbyte zk_tmp8,pa
        if_c  ret wcz

              loc ptrb,#opn_regbase+CH_OFFSET+(2*CH_SIZE) ' Always channel 3
              mov zk_memtmp3,#2 ' Always channel 3

              rdbyte zk_memtmp0,pa
              rolbyte zk_memtmp0,zk_tmp8,#0
              zerox zk_memtmp0,#13
              loc pa,#opn_regbase+12
              add pa,zk_memtmp2
              add pa,zk_memtmp2
              wrword zk_memtmp0,pa
              ' Compute kcode
              mov zk_tmp8,zk_memtmp0
              shr zk_tmp8,#11-2
              shr zk_memtmp0,#7
              and zk_memtmp0,#$F
              sub zk_memtmp0,#6
              fges zk_memtmp0,#0
              fles zk_memtmp0,#3
              setq #%11000
              muxq zk_memtmp0,zk_tmp8
              loc pa,#opn_regbase+4
              add pa,zk_memtmp2
              wrbyte zk_memtmp0,pa

              ' fall through

.update_detune
              mov zk_memtmp1,zk_memtmp2
              mul zk_memtmp1,#OP_SIZE
              add ptrb,zk_memtmp1
              rdbyte zk_tmp8,ptrb[OP_OFFSET+0] ' read MUL/DT
.update_detune_faster
              sub ptrb,zk_memtmp1

              rdbyte zk_memtmp0,ptrb[4] ' channel kcode
              '' Do detune adjustment
              loc pa,#detune_adjustment
              shl zk_memtmp0,#2
              shr zk_tmp8,#4
              setq #3
              muxq zk_memtmp0,zk_tmp8
              add pa,zk_memtmp0
              rdbyte zk_memtmp0,pa
              add ptrb,zk_memtmp1
              wrbyte zk_memtmp0,ptrb[OP_OFFSET+2] ' write detune lookup
              sub ptrb,zk_memtmp1

              cmp zk_memtmp3,#2 wz 'Is CH3?
              cmp zk_memtmp2,#3 wc ' is not OP4?
        if_nc_or_nz ret wcz
              ' update detune for CH3 special
              loc pb,#opn_regbase+4
              add pb,zk_memtmp2
              rdbyte zk_memtmp0,pb ' operator kcode
              '' Do detune adjustment
              loc pa,#detune_adjustment
              shl zk_memtmp0,#2
              'shr zk_tmp8,#4
              setq #3
              muxq zk_memtmp0,zk_tmp8
              add pa,zk_memtmp0
              rdbyte zk_memtmp0,pa
              add pb,#4
              wrbyte zk_memtmp0,pb ' write detune lookup
              ret wcz

.common_reg
              cmp zk_memtmp1,#$10 wc
        if_b  jmp #.ssg
              cmp zk_memtmp1,#$1C wcz
        if_b  jmp #.adpcm_b
        if_e  jmp #.adpcm_endmask
              cmp zk_memtmp1,#$2B wcz
        'if_e wrbyte zk_tmp8,ptrb[1] ' DAC enable
        if_ne cmp zk_memtmp1,#$29 wz
        if_nc_or_z ret wcz ' Also return on nonexistant registers $2C..$2F and $29
              cmp zk_memtmp1,#$2A wz
        'if_e wrbyte zk_tmp8,ptrb[0] ' DAC data
        if_e  ret wcz
              cmp zk_memtmp1,#$27 wz
        if_e  jmp #.tctrl   ' CH3 special mode and timer ctrl
              cmp zk_memtmp1,#$26 wz
        if_e  wrbyte zk_tmp8,ptrb[3] ' Timer B freq
        if_e  ret wcz
              cmp zk_memtmp1,#$22 wz
        if_e  wrbyte zk_tmp8,ptrb[2] ' LFO ctrl
        if_e  ret wcz
              cmp zk_memtmp1,#$24 wcz
        if_b  ret wcz ' Return on unused registers $00..$21 and $23
              ' Must be Timer A frequency
              rdword zk_memtmp0,ptrb[18/2]
        if_e  shl zk_tmp8,#2
        if_e  setq ##%11_11111100
        if_a  setq #%11
              muxq zk_memtmp0,zk_tmp8
              wrword zk_memtmp0,ptrb[18/2]
              ret wcz

.ssg
              add ptrb,zk_memtmp1
              cmp zk_memtmp1,#$0D wz
        if_z  and zk_tmp8,#$0F
              wrbyte zk_tmp8,ptrb[##OPN_SIZE]
              ret wcz
              'nop

.tctrl
              'debug(".tctrl ",uhex_byte_(zk_tmp8),uhex_word(zk_pc))
              wrbyte zk_tmp8,ptrb[7]
              testb zk_tmp8,#4 wc ' Timer A reset
        if_c  wrbyte #0,#opn_timerAflag
              testb zk_tmp8,#5 wc ' Timer B reset
        if_c  wrbyte #0,#opn_timerBflag
              ret wcz


.keyon
              getnib zk_memtmp3,zk_tmp8,#1
              and zk_tmp8,#%111
              test zk_tmp8,#%011 wcz
    if_not_10 ret wcz ' invalid channel
              sub zk_tmp8,#1
              test zk_tmp8,#%100 wc
        if_c  sub zk_tmp8,#2
              rdlong zk_memtmp0,ptrb[20/4]
              altsn zk_tmp8,#zk_memtmp0
              setnib zk_memtmp3
              wrlong zk_memtmp0,ptrb[20/4]
              ret wcz

.adpcm_a
              cmp zk_memtmp1,#$100 wz
        if_z  jmp #.adpcm_a_keyon
              cmp zk_memtmp1,#$101 wz ' Global level
        if_z  and zk_tmp8,#$3F
        if_z  wrbyte zk_tmp8,ptrb[1]
              sub zk_memtmp1,#$108 wc
    if_z_or_c ret wcz
              ' ok, got per-channel reg
              loc ptrb,#adpa_regbase
              mov zk_memtmp0,zk_memtmp1
              and zk_memtmp0,#7
              cmp zk_memtmp0,#6 wc
        if_ae ret wcz
              mul zk_memtmp0,#ADPA_CH_SIZE
              add ptrb,zk_memtmp0
              'debug(uhex_long(ptrb,#@adpa_regbase,zk_memtmp1),uhex_byte(zk_tmp8))
              cmpsub zk_memtmp1,#8 wc
        if_nc wrbyte zk_tmp8,ptrb[1] ' pan/level
              shr zk_memtmp1,#3
              add ptrb,zk_memtmp1
        if_c  wrbyte zk_tmp8,ptrb[4] ' addresses
              ret wcz

.adpcm_a_keyon
              testb zk_tmp8,#7 wc ' is dump?
        if_c  mov zk_memtmp0,#255
        if_nc mov zk_memtmp0,#1

              loc ptrb,#adpa_regbase+3*ADPA_CH_SIZE
              testb zk_tmp8,#0 wc
        if_c  wrbyte zk_memtmp0,ptrb[-3*ADPA_CH_SIZE]
              testb zk_tmp8,#1 wc
        if_c  wrbyte zk_memtmp0,ptrb[-2*ADPA_CH_SIZE]
              testb zk_tmp8,#2 wc
        if_c  wrbyte zk_memtmp0,ptrb[-1*ADPA_CH_SIZE]
              testb zk_tmp8,#3 wc
        if_c  wrbyte zk_memtmp0,ptrb[ 0*ADPA_CH_SIZE]
              testb zk_tmp8,#4 wc
        if_c  wrbyte zk_memtmp0,ptrb[ 1*ADPA_CH_SIZE]
              testb zk_tmp8,#5 wc
        if_c  wrbyte zk_memtmp0,ptrb[ 2*ADPA_CH_SIZE]

              ret wcz

.adpcm_b
              cmp zk_memtmp1,#$16 wz
        if_nz cmp zk_memtmp1,#$17 wz
        if_nz cmp zk_memtmp1,#$18 wz
        if_z  ret wcz ' we use these unused registers for nefarious purposes, so we can't let it be overwritten
              loc ptrb,#adpb_regbase-$10
              add ptrb,zk_memtmp1
              wrbyte zk_tmp8,ptrb
              cmp zk_memtmp1,#$10 wz
        if_nz ret wcz
              testb zk_tmp8,#0 wz
              testb zk_tmp8,#7 wc
        if_x1 wrbyte #255,ptrb[$18-$10]
        if_10 wrbyte #1,ptrb[$18-$10]
              ret wcz

.adpcm_endmask
              loc ptrb,#adpa_regbase+3*ADPA_CH_SIZE + 2
              testb zk_tmp8,#0 wc
        if_c  wrword #257,ptrb[-3*ADPA_CH_SIZE/2]
        if_nc wrbyte #0,ptrb[-3*ADPA_CH_SIZE + 1]
              testb zk_tmp8,#1 wc
        if_c  wrword #257,ptrb[-2*ADPA_CH_SIZE/2]
        if_nc wrbyte #0,ptrb[-2*ADPA_CH_SIZE + 1]
              testb zk_tmp8,#2 wc
        if_c  wrword #257,ptrb[-1*ADPA_CH_SIZE/2]
        if_nc wrbyte #0,ptrb[-1*ADPA_CH_SIZE + 1]
              testb zk_tmp8,#3 wc
        if_c  wrword #257,ptrb[ 0*ADPA_CH_SIZE/2]
        if_nc wrbyte #0,ptrb[ 0*ADPA_CH_SIZE + 1]
              testb zk_tmp8,#4 wc
        if_c  wrword #257,ptrb[ 1*ADPA_CH_SIZE/2]
        if_nc wrbyte #0,ptrb[ 1*ADPA_CH_SIZE + 1]
              testb zk_tmp8,#5 wc
        if_c  wrword #257,ptrb[ 2*ADPA_CH_SIZE/2]
        if_nc wrbyte #0,ptrb[ 2*ADPA_CH_SIZE + 1]
              testb zk_tmp8,#7 wc
        if_c  wrword #257,##adpb_regbase+6
        if_nc wrbyte #0,##adpb_regbase+6+1
              ret wcz


.address
              testb zk_ea,#1 wc
              bitc zk_tmp8,#8
              wrword zk_tmp8,#opn_register
              ret wcz

opn_doreset
              loc ptrb,#opn_regbase
              setq #6-1
              wrlong #0,ptrb++
              mov zk_memtmp0,#4
.chlp
              wrlong ##$C0_00_00_00,ptrb++ ' Pan initializes to center
              wrlong #0,ptrb++

              mov zk_memtmp1,#4
.oplp
              wrlong ##$00_00_7F_00,ptrb++ ' Maximum (=quietest) TL
              wrlong ##$3E_00_3E_00,ptrb++ ' Maximum DR/RR so the chip actually resets
              wrlong #0,ptrb++
              djnz zk_memtmp1,#.oplp
              djnz zk_memtmp0,#.chlp
              wrword #0,#opn_timerAflag
              ret wcz




detune_adjustment byte ' table used to compute detune amount
byte   0,  0,  1,  2 ,    0,  0,  1,  2 ,    0,  0,  1,  2 ,    0,  0,  1,  2
byte   0,  1,  2,  2 ,    0,  1,  2,  3 ,    0,  1,  2,  3 ,    0,  1,  2,  3
byte   0,  1,  2,  4 ,    0,  1,  3,  4 ,    0,  1,  3,  4 ,    0,  1,  3,  5
byte   0,  2,  4,  5 ,    0,  2,  4,  6 ,    0,  2,  4,  6 ,    0,  2,  5,  7
byte   0,  2,  5,  8 ,    0,  3,  6,  8 ,    0,  3,  6,  9 ,    0,  3,  7, 10
byte   0,  4,  8, 11 ,    0,  4,  8, 12 ,    0,  4,  9, 13 ,    0,  5, 10, 14
byte   0,  5, 11, 16 ,    0,  6, 12, 17 ,    0,  6, 13, 19 ,    0,  7, 14, 20
byte   0,  8, 16, 22 ,    0,  8, 16, 22 ,    0,  8, 16, 22 ,    0,  8, 16, 22

DAT ' OPNBCog register area
        orgh
        alignl

opn_regbase long 0[OPN_SIZE/4]
ssg_regbase long 0[SSG_SIZE/4]
adpa_regbase long 0[ADPA_SIZE/4]
adpb_regbase long 0[ADPB_SIZE/4]
opn_frqhi   byte 0[4+3]

        alignl

'' YM2612 global registers (6 + 6*14 = 90 longs)
'' -----------------------
'' byte unused,adpa_level
'' byte lfo
'' byte timerBfreq
'' byte ch3_kcodes[3]
'' byte ch3_mode '(also timer stuff)
'' byte ch3_detune[3]
'' byte glpad
'' word ch3_specialfreqs[3]
'' word timerAfreq
'' long key_on
'' 6x channel regs
''

'' YM2612 channel registers (2 + 4*3 = 14 longs)
'' ------------------------
'' word frequency
'' byte algorithm '(also S1 feedback)
'' byte pan_lfo
'' byte keycode_cache ' (not a real register)
'' byte ch_padding1
'' byte am
'' byte ch_padding2
'' 4x operator regs
''

'' YM2612 operator registers (= 3 longs)
'' -------------------------
'' byte mul_dt
'' byte tl
'' byte detune_cache ' (not a real register)
'' byte op_pad1
'' byte ar
'' byte dr
'' byte sr
'' byte rr
'' byte rs
'' byte sl
'' byte ssg_eg
'' byte op_pad2
''

'' ADPCM-A channel registers
'' ------------------------
'' byte command (OPN resets this to zero. write 1 to key-on, 255 to dump)
'' byte level_pan (as written)
'' byte end_flag (OPN sets on channel end)
'' byte mask_flag (Purely for register interface)
'' word start_addr
'' word end_addr

'' ADPCM-B registers
'' ------------------------
'' byte repflag (technically entire last command byte, but we only care about the repeat bit)
'' byte pan
'' word start_addr
'' word end_addr
'' byte end_flag
'' byte mask_flag
'' byte command (OPN resets this to zero. write 1 to key-on, 255 to dump)
'' word delta_n (note: unaligned)
'' byte volume




DAT ' MEMORY
              orgh
alignl
mk_romque_area
              word 0[MK_ROMQUE_SIZE]
              byte 0[4] ' padding
mk_romio_area
              byte 0[16]
              byte 0[4] ' padding

adpcm_buffers
              byte 0[2*7*16]

              byte 0[32-($&31)]' alignment

mk_vectorcache_bios
              long 0[32]
              long 0[32] ' even when BIOS vectors are banked in, it's only the first 32
mk_vectorcache_game
              long 0[64]

vshrink_lookup
              file "SHRINK.DAT"

              long 0[16] ' padding for sprite clipping
draw_buffer
              long 0[(320+16)*2]
' temporary data associated with sprite rendering (4 lines * 96 sprites))
' format is as such:
'   2 longs buffer area for CROM data
'   long CROM pointer (minus 1: end of active list)
'   word %PPPP_PPPP_SSSS_xxxH
'     P -> palette
'     S -> H shrink value
'     H -> mirror flag
'   word X position + 15
spr_buffer    long 0[96*4*4]

              orgh $1_0000
main_ram
              byte 0[$1_0000] ' 68k RAM

palette32
              long 0[256*16*2] ' Palette has two banks for some reason

vram_low
              word 0[$8000]
vram_high
              word 0[$800] ' Note: reordered for speed

              orgh INPUT_LOAD
input_code
              file "neoyume_input.binary"

              orgh UPPER_LOAD-$2_0000
fix_tiles
              file "MENUFIX.DAT"
opn_sinexp_tab          file "OPN2_ROM.DAT" ' Quarter sine and exponent ROM, interleaved.

              orgh UPPER_LOAD
m1_rom ' M1 ROM overwrites upcode
upcode_base
              file "neoyume_upper.binary"
